#!/bin/bash
# rus - rebuild update sequence - to rebuild system as required when a key package major update occurs
source /usr/local/sbin/script_header_brendlefly
#  0.0.7 - adds pick_binutils() function, -s option
#  0.0.8 - stop/start cloudsync packages/rsyncd before/after
BUILD=0.0.8

# To Do - assumes cronie; generalize for other cron systems

# To Do -- re-do rebuild w/updated toolchain sequence according to new (2020) best practices
# see https://forums.gentoo.org/viewtopic-t-1118276-start-0.html
# see https://wiki.gentoo.org/wiki/Upgrading_GCC#Quick_guide_to_GCC_upgrades
# see https://wiki.gentoo.org/wiki/Project:Toolchain
#
# updates ([headers], glibc, binutils, libtool)
# ( below from wiki gcc-upgrade)
# rebuild gcc
# source /etc/profile
# gcc-config
# rebuild libtool, binutils
# binutils-config
# source /etc/profile
# rebuild glibc
# locale-gen
# source /etc/profile
# mount /boot
# emerge @world (rebuild whole tree)
# source /etc/profile
# etc-update
# perl-cleaner --all
# emerge --sync
# emerge -auDN @world (update only)
# revdep-rebuild
# emerge --depclean --deep
# other emerge clean-up/maintenance as needed (eclean emaint et al).
# (end wiki suggestions)
# reboot
# rebuild kernel
# rebuild boot loader w/ rebuilt kernel (grub filo etc)

# PORTDIR, PKGDIR, DISTDIR must be evaluated in this order if e.g. PKGDIR=${PORTDIR}/packages
eval $( grep ^PORTDIR /etc/portage/make.conf )
eval $( grep ^PKGDIR /etc/portage/make.conf )

status_file="/root/bin/rus-status"

key_packages1=(
'sys-libs/glibc'
'sys-devel/binutils'
'sys-devel/libtool'
'sys-devel/gcc'
)

key_packages2=(
'sys-kernel/linux-headers'
'sys-devel/gcc-config'
)

# Notes on command sequence:
#   -b = --buildpkg (i.e. build a new binary package)
#   -k = --usepkg (i.e. use binary package if available)
#   -e = --emptytree (i.e. reinstall entire dependency tree)
#   FEATURES="-getbinpkg" deselects -g (i.e. use local binaries only, if -k is used)
command_sequence=(
'pkgsync stop'
'rm -rfv ${PKGDIR}'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -av ${key_packages1[@]} ${key_packages2[@]} --keep-going'
'pick_gcc'
'pick_binutils'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avb ${key_packages1[@]} --keep-going'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke system --keep-going'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke world --keep-going'
'pkgsync start'
)

# declarative future tense
msg1_sequence=(
'Stop syncing packages with other nodes'
'Remove PKGDIR'
'Rebuild toolchain'
'Select gcc'
'Select binutils'
'Rebuild toolchain packages with new gcc, binutils'
'Rebuild system packages with new toolchain'
'Rebuild world packages with new toolchain'
'Re-start syncing packages with other nodes'
)

# active present tense
msg2_sequence=(
'Stoping package syncing with other nodes'
'Removing PKGDIR'
'Rebuilding toolchain'
'Selecting gcc'
'Selecting binutils'
'Rebuilding toolchain packages with new gcc, binutils'
'Rebuilding system packages with new toolchain'
'Rebuilding world packages with new toolchain'
'Re-starting package syncing with other nodes'
)

answer=""   # response to prompt
status=0    # what step are we on?

### ToDO - add command line processor
[[ $1 == "-r" ]] && read status < ${status_file}
[[ $1 == "-s" ]] && read status < ${status_file} && message "Next step: ${status} -- ${msg1_sequence[${status}]}" && exit

#----------[ functions ]-------------------------------------
get_number()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; echo; echo; CUU; SCP; message_n "$ps [0-9]: " && read answer;
#while ! expr "${answer:0:1}" : [0-9] >/dev/null;  # answer not a regex match
while ! expr "${answer:0:1}" : \[0-9\] >/dev/null;  # answer not a regex match
do RCP; echo -en "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$ps [0-9]: " && read answer; done; }

get_answer()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; echo; echo; CUU; SCP; message_n "$ps [yngYNG]: " && read answer;
#while ! expr "${answer:0:1}" : [yngYNG] >/dev/null;  # answer not a regex match
while ! expr "${answer:0:1}" : \[yngYNG\] >/dev/null;  # answer not a regex match
do RCP; echo -en "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$ps [yngYNG]: " && read answer; done; }

pick_gcc()          # pick the appropriate gcc
{ gcc-config -l; get_number "Select gcc profile from list above";
message "setting gcc-config $answer" && gcc-config ${answer};
message "sourcing /etc/profile" && source /etc/profile; }

pick_binutils()          # pick the appropriate gcc
{ binutils-config -l; get_number "Select binutils profile from list above";
message "setting binutils-config $answer" && binutils-config ${answer};
message "sourcing /etc/profile" && source /etc/profile; }

pkgsync()            # stop/start syncing packages
{
action="$1"
echo "action: ${action}"
cslinelist=($(grep -n cloudsync /etc/crontab | cut -d':' -f1))
if [[ "${action}" == "stop" ]]
then
  echo "commenting out cloudsync cron job in crontab";
  for ((i=0; i<${#cslinelist[@]}; i++))
  do
    echo "maybe comment line: ${cslinelist[i]}"
    sed -i "${cslinelist[i]} s|^.|#&|" /etc/crontab;
  done;
  echo "stopping cronie"
  /etc/init.d/cronie stop
  echo "stopping rsyncd"
  /etc/init.d/rsyncd stop
elif [[ "${action}" == "start" ]]
then
  echo "un-commenting cloudsync cron job in crontab"
  # if it is not already commented, then comment it
  for ((i=0; i<${#cslinelist[@]}; i++))
  do
    echo "maybe uncomment line: ${cslinelist[i]}"
    sed -i "${cslinelist[i]} s|^#||" /etc/crontab
  done
  echo "restarting cronie"
  /etc/init.d/cronie restart
  echo "restarting rsyncd"
  /etc/init.d/rsyncd restart
else
  echo "Invalid action passed to pkgsync; exiting"
  exit
fi
echo "done pkgsync ${action}"
}

#----------[ main script ]-----------------------------------
# display script kick-off separator
separator "joetoo Rebuild Update Sequence -- rus-${BUILD}"
# must be root
message "Checking root UID... "&& checkroot
message "Setup with PKGDIR = ${PKGDIR}"

for ((i=status; i<${#command_sequence[@]}; i++))
do
  [[ ! $answer == [gG] ]] && answer="" && \
    separator "${msg1_sequence[i]}" "rus-${BUILD} Now starting"
    get_answer "Are you ready to execute step ${i} -- ${BYon}${msg1_sequence[i]}${Boff}?"
  if [[ $answer == [YyGg] ]]
  then
    message_n "${LBon}Now executing step ${i} -- ${BYon}${msg2_sequence[i]}${LBon}...${Boff}"
    eval ${command_sequence[i]}; result="$?"; right_status "${result}"
    if [[ ${result} ]]
    then
      message "Step ${i} -- ${BYon}${msg1_sequence[i]}${Boff} -- complete"
      message "Saving [${i}] to ${status_file}"
      echo $i > ${status_file}
    else
      message "Step ${i} -- ${BYon}${msg1_sequence[i]}${Boff} -- ${BRon}failed${Boff}"
      echo $(($i-1)) > ${status_file}
      message "Quitting..."
    fi
  else
    message "User chose ${BRon}NOT${Boff} to execute step ${i} -- ${BYon}${msg1_sequence[i]}${Boff}."
    message "Saving [((${i}-1))] to ${status_file}"
    echo $(($i-1)) > ${status_file}
    message "Quitting..."
    exit
  fi
done

echo
message "rus complete.  recommend verification with something line --"
message 'eix-update && FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke1 --keep-going $(eix -Ic | grep -v "07/0[1-9]/2023" | cut -d" " -f2 | grep /)'

