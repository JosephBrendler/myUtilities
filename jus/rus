#!/bin/bash
# rus - rebuild update sequence - to rebuild system as required when a key package major update occurs
source /usr/local/sbin/script_header_brendlefly
#  0.0.7 - adds pick_binutils() function, -s option
#  0.0.8 - stop/start cloudsync packages/rsyncd before/after
BUILD=0.0.8

# To Do - assumes cronie; generalize for other cron systems

# To Do -- re-do rebuild w/updated toolchain sequence according to new (2020) best practices
# see https://forums.gentoo.org/viewtopic-t-1118276-start-0.html
# see https://wiki.gentoo.org/wiki/Upgrading_GCC#Quick_guide_to_GCC_upgrades
# see https://wiki.gentoo.org/wiki/Project:Toolchain
#
# updates ([headers], glibc, binutils, libtool)
# ( below from wiki gcc-upgrade)
# rebuild gcc
# source /etc/profile
# gcc-config
# rebuild libtool, binutils
# binutils-config
# source /etc/profile
# rebuild glibc
# locale-gen
# source /etc/profile
# mount /boot
# emerge @world (rebuild whole tree)
# source /etc/profile
# etc-update
# perl-cleaner --all
# emerge --sync
# emerge -auDN @world (update only)
# revdep-rebuild
# emerge --depclean --deep
# other emerge clean-up/maintenance as needed (eclean emaint et al).
# (end wiki suggestions)
# reboot
# rebuild kernel
# rebuild boot loader w/ rebuilt kernel (grub filo etc)

# PORTDIR, PKGDIR, DISTDIR must be evaluated in this order if e.g. PKGDIR=${PORTDIR}/packages
eval $( grep ^PORTDIR /etc/portage/make.conf )
eval $( grep ^PKGDIR /etc/portage/make.conf )

status_file="/root/bin/rus-status"

key_packages1=(
'sys-libs/glibc'
'sys-devel/binutils'
'sys-devel/libtool'
'sys-devel/gcc'
)

key_packages2=(
'sys-kernel/linux-headers'
'sys-devel/gcc-config'
)

# Notes on command sequence:
#   -b = --buildpkg (i.e. build a new binary package)
#   -k = --usepkg (i.e. use binary package if available)
#   -e = --emptytree (i.e. reinstall entire dependency tree)
#   FEATURES="-getbinpkg" deselects -g (i.e. use local binaries only, if -k is used)
command_sequence=(
'pkgsync stop'
'rm -rfv ${PKGDIR}'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -av ${key_packages1[@]} ${key_packages2[@]} --keep-going'
'pick_gcc'
'pick_binutils'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avb ${key_packages1[@]} --keep-going'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke system --keep-going'
'FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke world --keep-going'
'pkgsync start'
)

# declarative future tense
msg1_sequence=(
'Stop syncing packages with other nodes'
'Remove PKGDIR'
'Rebuild toolchain'
'Select gcc'
'Select binutils'
'Rebuild toolchain packages with new gcc, binutils'
'Rebuild system packages with new toolchain'
'Rebuild world packages with new toolchain'
'Re-start syncing packages with other nodes'
)

# active present tense
msg2_sequence=(
'Stoping package syncing with other nodes'
'Removing PKGDIR'
'Rebuilding toolchain'
'Selecting gcc'
'Selecting binutils'
'Rebuilding toolchain packages with new gcc, binutils'
'Rebuilding system packages with new toolchain'
'Rebuilding world packages with new toolchain'
'Re-starting package syncing with other nodes'
)

answer=""   # response to prompt
status=0    # what step are we on?

### ToDO - add command line processor
[[ $1 == "-r" ]] && read status < ${status_file}
[[ $1 == "-s" ]] && read status < ${status_file} && message "Next step: ${status} -- ${msg1_sequence[${status}]}" && exit

#----------[ functions ]-------------------------------------
get_number()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; echo; echo; CUU; SCP; message_n "$ps [0-9]: " && read answer;
#while ! expr "${answer:0:1}" : [0-9] >/dev/null;  # answer not a regex match
while ! expr "${answer:0:1}" : \[0-9\] >/dev/null;  # answer not a regex match
do RCP; echo -en "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$ps [0-9]: " && read answer; done; }

get_answer()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; echo; echo; CUU; SCP; message_n "$ps [yngYNG]: " && read answer;
while ! expr "${answer:0:1}" : \[yngYNG\] >/dev/null;  # answer not a regex match
do RCP; echo -en "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$ps [yngYNG]: " && read answer; done; }

pick_gcc()          # pick the appropriate gcc
{ gcc-config -l; get_number "Select gcc profile from list above";
message "setting gcc-config $answer" && gcc-config ${answer};
message "sourcing /etc/profile" && source /etc/profile; }

pick_binutils()          # pick the appropriate gcc
{ binutils-config -l; get_number "Select binutils profile from list above";
message "setting binutils-config $answer" && binutils-config ${answer};
message "sourcing /etc/profile" && source /etc/profile; }

pkgsync()            # stop/start syncing packages
{
action="$1"
echo; message "action: ${action}"
cslinelist=($(grep -n cloudsync /etc/crontab | cut -d':' -f1))
if [[ "${action}" == "stop" ]]
then
  message "commenting out cloudsync cron job in crontab";
  for ((i=0; i<${#cslinelist[@]}; i++))
  do
    message "maybe comment line: ${cslinelist[i]}"
    sed -i "${cslinelist[i]} s|^.|#&|" /etc/crontab;
  done;
  message "stopping rsyncd"
  /etc/init.d/rsyncd stop
  message "restarting cronie"
  /etc/init.d/cronie restart
elif [[ "${action}" == "start" ]]
then
  message"un-commenting cloudsync cron job in crontab"
  # if it is not already commented, then comment it
  for ((i=0; i<${#cslinelist[@]}; i++))
  do
    message "maybe uncomment line: ${cslinelist[i]}"
    sed -i "${cslinelist[i]} s|^#||" /etc/crontab
  done
  message "restarting rsyncd"
  /etc/init.d/rsyncd restart
  message "restarting cronie"
  /etc/init.d/cronie restart
else
  E_message "Invalid action passed to pkgsync; exiting"
  exit
fi
message "done pkgsync ${action}"
}

#----------[ main script ]-----------------------------------
# display script kick-off separator
separator "joetoo Rebuild Update Sequence -- rus-${BUILD}"
# must be root
message "Checking root UID... "&& checkroot
message "Setup with PKGDIR = ${PKGDIR}"

#for ((i=status; i<${#command_sequence[@]}; i++))
while [[ status -lt ${#command_sequence[@]} ]]
do
  [[ ! $answer == [gG] ]] && answer="" && \
    separator "${msg1_sequence[status]}" "rus-${BUILD} Now starting"
    get_answer "Are you ready to execute step ${status} -- ${BYon}${msg1_sequence[status]}${Boff}?"
  if [[ $answer == [YyGg] ]]
  then
    message_n "${LBon}Now executing step ${status} -- ${BYon}${msg2_sequence[status]}${LBon}...${Boff}"
    eval ${command_sequence[status]}; result="$?"; right_status "${result}"
    if [[ ${result} ]]
    then
      message "Step ${status} -- ${BYon}${msg1_sequence[status]}${Boff} -- complete"
      message "Saving [${status}] to ${status_file}"
    else
      E_message "Step ${status} -- ${BYon}${msg1_sequence[status]}${Boff} -- ${BRon}failed${Boff}"
      E_message "Quitting..."
    fi
  else
    E_message "User chose ${BRon}NOT${Boff} to execute step ${status} -- ${BYon}${msg1_sequence[status]}${Boff}."
    E_message "Saving [((${status}-1))] to ${status_file}"
    E_message "Quitting..."
    exit
  fi
  # increment number of next step and store in status_file
  let status++;
  echo $status > ${status_file}
done

echo
message "rus complete.  recommend verification with something line --"
message 'eix-update && FEATURES="$FEATURES -distcc -distcc-pump -getbinpkg" emerge -avbke1 --keep-going $(eix -Ic | grep -v "07/0[1-9]/2023" | cut -d" " -f2 | grep /)'

