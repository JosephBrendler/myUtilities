#!/bin/bash
#   script header with basic functions
# Author: brendlefly 19 Jul 2014
#

#---[ Define common variables for use in various scripts ]---
BUILD="0.0.0 (19620207)"  #redefine in base script
ROOT_UID=0       # Only users with $UID 0 have root privileges
#  Error message used by various scripts
E_NOTROOT="Must be root to run this script."
E_ROOT="Please run this script as user, not root."
E_BAD_ARGS="Improperly formatted command line argument."

TRUE=0    # will evaluate to be logically true in a boolean operation
FALSE=""  # will evaluate to be logically false in a boolean operation
  # play with test function:
  # test() { [ $1 ] && echo "$1 is true" || echo "$1 is false"; }
VERBOSE=$FALSE
verbosity=1

#--[ Easy ANSI Escape sequences to put color in my scripts ]---
#  see http://en.wikipedia.org/wiki/ANSI_escape_code
#  see also http://ascii-table.com/ansi-escape-sequences.php

CSI="\033["             # control sequence initiator == hex "\x1b["
#---[ Select Graphics Rendition on/off ]---------------------------
BOLD="1"       # bold on
UL="4"         # underline on
BLINK="5"      # slow blink on
BLINKFAST="6"  # fast blink on
REVERSE="7"        # image: inverse (reverse video)
ULoff="24"     # underline off
BLINKoff="25"  # blink off
SGRoff="0"     # Bold off (reset all SGR (e.g. blink, underline)
#---[ Set Text Color, Foreground ]---------------------------------
BLACK="30"     # foreground black
RED="31"       # foreground red
GREEN="32"     # foreground green
YELLOW="33"    # foreground yellow
BLUE="34"      # foreground blue
MAG="35"       # foreground magenta (it's like fucia)
LBLUE="36"     # foreground light blue (cyan)
WHITE="37"     # foreground white (cyan)
#---[ Set Background Color ]---------------------------------------
BACKoff="40"   # background black
RBACK="41"     # background red
GBACK="42"     # background green
YBACK="43"     # background yellow
BBACK="44"     # background blue
MBACK="45"     # background magenta
LBACK="46"     # background light blue (cyan)
WBACK="47"     # background white
#---[ My Favorite Colors (terminate with ${Boff} ]-----------------
BRon="${CSI}${RED};${BOLD}m"
BGon="${CSI}${GREEN};${BOLD}m"
BYon="${CSI}${YELLOW};${BOLD}m"
BBon="${CSI}${BLUE};${BOLD}m"
BMon="${CSI}${MAG};${BOLD}m"
LBon="${CSI}${LBLUE};${BOLD}m"
BWon="${CSI}${WHITE};${BOLD}m"
RVon="${CSI}${REVERSE}m"
Boff="${CSI}${SGRoff}m"          # Bold off (reset all SGR (e.g. blink, underline)
#---[ Here setting background as well ]-----------------------------
BBonY="${CSI}${BLUE};${YBACK};${BOLD}m"
color()        # set both foreground and background color; optional bold
{
  local FG=""  # foreground
  local BG=""  # optional background
  local B=""  # optional bold (applies to both foreground/background regardless of position in sequence)
  case $# in
    1 ) if [[ "$1" =~ 3[0-7] ]]; then FG="$1"; else E_message "Invalid color() argument, $# given"; exit 1; fi ;;
    2 ) if [[ "$1" =~ 3[0-7] && "$2" =~ [01] ]]; then FG="$1"; B=";$2";
      elif [[ "$1" =~ 3[0-7] && "$2" =~ 4[0-7] ]]; then FG="$1"; BG=";$2";
      else E_message "Invalid color() arguments, $# given"; exit 1; fi ;;
    3 ) if [[ "$1" =~ 3[0-7] && "$2" =~ [01] && "$3" =~ 4[0-7] ]]; then FG="$1"; B=";$2"; BG=";$3";
      elif [[ "$1" =~ 3[0-7] && "$2" =~ 4[0-7] && "$3" =~ [01] ]]; then FG="$1"; BG=";$2"; B=";$3";
      else E_message "Invalid color() arguments, $# given"; exit 1; fi ;;
    * ) E_message "Invalid color() arguments"; exit 1
  esac
#  echo "case $#: \$1=[$1]   \$3=[$3]   \$2=[$2]   \$4=[$4]"
#  echo "case $#: FG=[$FG]   BG=[$BG]   B1=[$B1]   B2=[$B2]"
  echo -e "${CSI}${FG}${B1}${BG}${B}m"
}

#---[ Box Drawing escape sequence stuff ]--------------------------
#  See: https://en.wikipedia.org/wiki/Box-drawing_character
ESCon='\e(0'
ESCoff='\e(B'
H_wall='\x71'
V_wall='\x78'
UL_wall='\x6C'
UR_wall='\x6B'
LL_wall='\x6D'
LR_wall='\x6A'
# we can also use unicode characters, which do not require the esc seq intro
uH_wall='\u2500'
uV_wall='\u2502'
uUL_wall='\u250C'
uUR_wall='\u2510'
uLL_wall='\u2514'
uLR_wall='\u2518'
uD_H_wall='\u2550'
uD_V_wall='\u2551'
uD_UL_wall='\u2554'
uD_UR_wall='\u2557'
uD_LL_wall='\u255A'
uD_LR_wall='\u255D'

#---[ Cursor Movement Commands ]-----------------------------------
SCP()  # save the current cursor position
{ echo -en "${CSI}s" && return 0 || return 1; }
RCP()  # restore the cursor to the saved position
{ echo -en "${CSI}u" && return 0 || return 1; }
HCU()  # Hide the cursor (Note: the trailing character is lowercase L)
{ echo -en "${CSI}?25l" && return 0 || return 1; }
SCU()  # Show the cursor
{ echo -en "${CSI}?25h" && return 0 || return 1; }
HVP()  # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{
  local row col
  [ ! -z "$1" ] && row=$1 || row=1
  [ ! -z "$2" ] && col=$2 || col=1
  echo -en "${CSI}${row};${col}f" && return 0 || return 1
}
CUP()  # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{
  local row col
  [ ! -z "$1" ] && row=$1 || row=1
  [ ! -z "$2" ] && col=$2 || col=1
  echo -en "${CSI}${row};${col}H" && return 0 || return 1
}
CLR()  # Clear the screen
{ echo -en "${CSI}2J" && return 0 || return 1; }
CUU()  # Move the cursor up ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} + 1 ))"A" && return 0 || return 1; }
CUD()  # Move the cursor down ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} - 1 ))"B" && return 0 || return 1; }
CUF()  # Move the cursor forward ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} ))"C" && return 0 || return 1; }
CUB()  # Move the cursor back ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} ))"D" && return 0 || return 1; }
CPR()  # Report the current position (row, col) of the cursor [tip: hit return again]
{ perl -e '$/ = "R";' -e 'print "\033[6n";my $x=<STDIN>;my($n, $m)=$x=~m/(\d+)\;(\d+)/;print "Col: $m, Row: $n\n";'; }

# ---[ common function blocks ]------------------------------------------

checkroot()     # Run as root, of course.
{ if [ "$UID" -ne "$ROOT_UID" ]; then E_message "${E_NOTROOT}"; echo; exit 1; else return 0; fi; }

checknotroot()  # Run as not root, of course.
{ if [ "$UID" -eq "$ROOT_UID" ]; then E_message "${E_ROOT}"; echo; exit 1; else return 0; fi; }

checkboot()     # check to see if the /boot partition is properly mounted (look for grub)
{ if [ -d "/boot/grub" ]; then return 0; else E_message "${BRon}/boot not properly mounted${Boff}";
    return 1; fi; }

message()       # echo a simply formatted message (arg $1) to the screen
{ echo -e "${BGon}*${Boff} ${1}" && return 0 || return 1; }

message_n()     # echo -n a simply formatted message (arg $1) to the screen
{ echo -en "${BGon}*${Boff} ${1}" && return 0 || return 1; }

E_message()     # echo a simply formatted error message (arg $1) to the screen
{ echo -e "${BRon}*${Boff} ${1}" && return 0 || return 1; }

E_message_n()   # echo -n a simply formatted error message (arg $1) to the screen
{ echo -en "${BRon}*${Boff} ${1}" && return 0 || return 1; }

d_message()     # pass argument $1 to message() if "external" boolean VERBOSE tests true
{ [[ $VERBOSE && $2 -le $verbosity ]] && message "$1"; }

d_message_n()   # pass argument $1 to message_n() if "external" boolean VERBOSE tests true
{ [[ $VERBOSE && $2 -le $verbosity ]] && message_n "$1"; }

dE_message()    # pass argument $1 to E_message() if "external" boolean VERBOSE tests true
{ [[ $VERBOSE && $2 -le $verbosity ]] && E_message "$1"; }

dE_message_n()  # pass argument $1 to E_message() if "external" boolean VERBOSE tests true
{ [[ $VERBOSE && $2 -le $verbosity ]] && E_message_n "$1"; }

d_echo()        # echo all arguments if "external" boolean VERBOSE tests true
{ [[ $VERBOSE && $2 -le $verbosity ]] && echo "$@"; }

status_color()  # emit to stdout the escape seq for color based on arg $1 (T/F Y/N 1/0)
{ case $1 in "1"|"y"|"Y"|$TRUE) echo -en ${BGon};; "0"|"n"|"N"|$FALSE) echo -en ${BRon};; \
                             *) echo -en ${BYon};; esac ; }

TrueFalse()     # echo to stdout "True" or "False", depending on truth of arg $1
{  [[ $1 ]] && echo -en "True" || echo -en "False" ; }

prompt()        # set external variable $answer based on reponse to prompt $1
{ ps=$1; SCP; echo -en "$ps [Y/n]: "
  while read answer && [[ ! "${answer:0:1}" =~ [yYnN] ]];  # answer not a regex match
    do case ${answer:0:1} in [yY1]|"$TRUE") answer="n";; [nN0]|"$FALSE") answer="x";; esac
  RCP; echo -en "$(repeat ' ' $(termwidth))"; RCP; message_n "$ps [Y/n]: " ; done; }

alpha_words()   # alphabetize the words in a quoted input string
{ echo $(for x in $@; do echo $x; done | sort -db ) ; }

vercomp()       # compare two version numbers return [0:equal|1:greaterthan|2:lessthan]
{ if [[ "$1" == "$2" ]]; then return 0; else first=$(echo -en "$1\n$2" | sort -V | head -n1);
  [[ "$first" == "$2" ]] && return 1 || return 2; fi }

show_result()   # show the result of vercomp comparison, in english
{ case $1 in 1) echo "${LBon}>${Boff}";; 2) echo "${BRon}<${Boff}";; \
             0) echo "${BGon}=${Boff}";; *) echo "${BYon}*** Error ***${Boff}";; esac }

my_date()       # echo a simply formatted date string (DDD MM dd hh:mm:ss AP TZ yyyy)
{
  day=$(date +%a); month=$(date +%b); monthday=$(date +%d); year=$(date +%Y)
  timeofday=$(date +%X); timezone=$(date +%Z)
  echo "$day $month $monthday $timeofday $timezone $year"
}

my_short_date() # echo a short formatted date string (yyyymmdd)
{
  month=$(date +%b); monthday=$(date +%d); year=$(date +%Y); timehack=$(date +%H:%M:%S);
  echo "${monthday}${month}${year}-${timehack}";
}

repeat()        # output a repeated string of character (arg $1) of length (arg $2)
{
  local i thing limit
  thing="$1"; limit=$2; out_str=""; i=0
  while [ $i -lt $limit ]; do out_str="${out_str}${thing}"; let "i++"; done
  echo -en "$out_str" && return 0 || return 1
}

termwidth()     # calculate and output the width of the terminal
{ echo -n $(stty size | sed 's/[0-9]* *//') && return 0 || return 1; }

termheight()    # calculate and output the height of the terminal
{ echo -n $(stty size | cut -d' ' -f1) && return 0 || return 1; }

separator()     # draw a horizontal line with a simple title (arg $1) and preface (arg $2)
{
  # to facilitate separation of portions of the output of various scripts
  # include a title preface (arg $2 or $(hostname) if $2 is not provided
  local msg preface msg_len
  [ ! -z "$2" ] && preface="$2" || preface=$(hostname)
  msg="${BYon}---[${BRon} $preface ${LBon}$1 ${BYon}]"
  msg_len=$(( ${#msg} - $(( ${#BYon} + ${#BRon} + ${#BBon} + ${#BYon} + ${#Boff} )) ))
  echo -en "$msg" && \
  echo -n $(repeat "-" $(( $(termwidth) - $(( $msg_len + ${#Boff} )) )) ) && echo -e ${Boff} && \
  return 0 || return 1
}

right_status()  # output 8 char [ ok/fail ] status at the right margin
{ # test message_n "good_test" ; right_status $?
  #      E_message_n "fail_test" && cat unexistent 2>/dev/null; right_status $?
  local status msg lpad rpad
  if [ $1 -eq 0 ]; then msg="${BGon}Ok${Boff}"; lpad=2; rpad=2
  else msg="${BRon}Fail${Boff}"; lpad=1; rpad=1; fi
  msg="${BBon}[$(repeat ' ' $lpad)${msg}$(repeat ' ' $rpad)${BBon}]${Boff}"
  let "msg_len=8"    # it's always 8, I made it that way
  # go to start of line, *then* move fwd to the right distance (9 chars) from the right margin
  echo -en "\r" && CUF $(( $(termwidth) - $msg_len -1 )) && echo -e "$msg" && return 0 || return 1
}

d_right_status()  # output 8 char [ ok/fail ] status at the right margin, if $VERBOSE
{ # test d_message_n "good_test" 1; d_right_status $? 1
  #      dE_message_n "fail_test" 1 && cat unexistent 2>/dev/null; d_right_status $? 1
  local status msg lpad rpad
  if [ $1 -eq 0 ]; then msg="${BGon}Ok${Boff}"; lpad=2; rpad=2
  else msg="${BRon}Fail${Boff}"; lpad=1; rpad=1; fi
  msg="${BBon}[$(repeat ' ' $lpad)${msg}$(repeat ' ' $rpad)${BBon}]${Boff}"
  let "msg_len=8"    # it's always 8, I made it that way
  # go to start of line, *then* move fwd to the right distance (9 chars) from the right margin
  [[ $VERBOSE && $2 -le $verbosity ]] && echo -en "\r" && CUF $(( $(termwidth) - $msg_len -1 )) && \
    echo -e "$msg" && return 0 || return 1
}

countdown()     # output text message (arg $2, optional), and count-down seconds (arg $1)
{
  # special note: use base#number notation with prefix 10# to ensure interpretation as base 10
  # store current minutes and seconds
  min=10#$(date +%M) ; sec=10#$(date +%S)
  wait_time=10#60  #default = 1 minute
  [[ ! -z $1 ]] && wait_time="10#${1}"
  # if wait time is greater than 60 seconds, convert to minutes and seconds, else calculate it
  if [[ "${wait_time}" -ge "60" ]]
  then
    wait_min=$(( ${wait_time} / 60 ))  ;  wait_sec=$(( ${wait_time} % 60 ))
  else
    wait_min=10#0  ;  wait_sec=${wait_time}
  fi
  tgt_min="$(( ${min} + ${wait_min} ))"  ;  tgt_sec="$(( ${sec} + ${wait_sec} ))"
  if [[ "${tgt_sec}" -ge "60" ]]
  then
    tgt_min="$(( ${tgt_min} + 1 ))"  ; tgt_sec="$(( ${tgt_sec} % 60 ))"
  fi
  min="$(date +%M)"  ;  sec="$(date +%S)"
  rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
  # default message is "Pausing, ", else get from arg $2
  [[ ! -z $2 ]] && wait_msg="$2" || wait_msg="Pausing,"
  while [[ "${rem}" -gt "0" ]]
  do
    echo -en "\r${wait_msg} Time: "$(date +%H:%M:%S)
    sleep 0.1
    min="10#$(date +%M)"  ;  sec="10#$(date +%S)"
    rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
    echo -n "    $rem seconds left..."
  done
  echo

  return 0
}

sh_countdown()  # count-down seconds (arg $1)
{
  # special note: bb sh cannot use base#number notation with prefix 10# to ensure interpretation as base 10
  if [[ ! -z $1 ]]
  then
    rem_time="${1}"
  else
    message "no argument given, defaulting to 30 seconds"
    rem_time=30
  fi

  # execute countdown
  while [[ "${rem_time}" -gt "0" ]]
  do
    [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
    echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
    sleep 1
    let "rem_time--"
  done
  [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
  echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
  echo

  return 0
}

progress()      # display an arrow depicting progress (visualize $1 of $2 steps complete)
{
  [ $# -ne 2 ] && E_message "${BRon}Error - two arguments required (${BYon}step ${BRon}and ${BYon}number_of_steps${BRon})${Boff}"
  step=$1; number_of_steps=$2
  #---[ user configurable variables ]---------------------------------------------------------------------------------------------
  margin=10; marker="-"
  #---[ analytically determined variables ]---------------------------------------------------------------------------------------
  range=$(( $(termwidth) - 3 - $(( $margin * 2 )) ))   # the -3 accounts for the two brackets (|) and the arrow head (>)
  myprogress=$(( $range * $step / $number_of_steps ))    # this is how many $marker to draw to represent a single step of progress
  start=$(($margin + 1)); end=$(( $(termwidth) - $margin -1 ))
  myrow=$(termheight)
  startofline=$(($start +1))
  [ $step -lt $number_of_steps ] && endofline=$(($startofline + $myprogress)) || endofline=$(($end - 2))
  lengthofline=$(($endofline - $startofline + 1))
  percent=$((100 * $step / $number_of_steps))
  middlestart=$(( $(( $(termwidth) / 2 )) - $(( ${#percent} / 2 )) - 4 ))
  if [ $percent -ge 90 ]; then pct_color=${BGon}; else
  if [ $percent -lt 70 ]; then pct_color=${BRon}; else pct_color=${BYon}; fi; fi
  #---/ action: move to start, draw "|", draw line and ">", move to end and draw "|",
  #     move middle, show percent, return to original position /------------------------------------------------------------------
  SCP; CUP $myrow $start; echo -en "|"
  repeat $marker $lengthofline; echo -en ">"
  CUP $myrow $end; echo -en "|"
  CUP $myrow $middlestart; echo -en "( ${pct_color}$percent%${Boff} )"; RCP
}

watchdistcc()   # until interrupted, display the count of distcc compile jobs done for clients
{ CLR; while [ 1 ]; do CUP 1 1; echo | count_distcc_jobs 2>/dev/null; sleep 2; done; }

summarize_me()  # list contents of this script header (employ me with "source" or ".")
{
  echo
  separator "script_header_brendlefly-$BUILD | content summary" && \
  message "This script header defines some ${BYon}common variables${Boff} for" && \
  message "  use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}" && \
  message "  ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and" && \
  message "  ${BYon}cursor${Boff} movement in my scripts, and it provides a number of" && \
  message "  useful ${BGon}functions${Boff}, for some routine tasks, as described below\n" && \
  grep "()" /usr/local/sbin/script_header_brendlefly | grep -v "grep" && echo && \
  msg="${BGon}* ${Boff}  ${BYon}About to run:\n        ${BBon}message${Boff}" && \
  msg="${msg}  ${BYon}\""'${BYon}VERBOSE is currently ' && \
  msg="${msg}${BGon}\$(${BBon}status_color ${BRon}\$VERBOSE${BGon})${Boff}" && \
  msg="${msg}${BGon}\$( [[ ${BRon}\$VERBOSE ${BGon}]] && ${BBon}echo ${Boff}-en true ${BGon}|| ${BBon}echo ${Boff}-en false" && \
  msg="${msg}${BGon})${BYon}\"${BGon}; ${BBon}echo${Boff}" && echo -e "${msg}" && \
  echo && \
  message "  ${BYon}VERBOSE is currently $(status_color $VERBOSE)$( [[ $VERBOSE ]] && echo -en true || echo -en false)" && echo && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 1 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}2 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 2 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 2${Boff}  " && \
  vercomp 1 2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0 ${BYon}to${BWon} 1.2.1${Boff}  " && \
  vercomp 1.2.0 1.2.1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0-r1 ${BYon}to${BWon} 1.2.0${Boff}  " && \
  vercomp 1.2.0-r1 1.2.0; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1..1 ${BYon}to${BWon} 1.2${Boff}  " && \
  vercomp 1..1 1.2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.0 ${BYon}to${BWon} 1.0-r10${Boff}  " && \
  vercomp 1.0 1.0-r10; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  " && \
  vercomp 3.4 3.4-r2; echo -e "$(show_result $?)" && echo && \
  message "  ${BYon}About to run:\n        ${BBon}sh_countdown ${Boff}6 ${BGon}&& \\ ${Boff}" && \
  echo -e "        ${BBon}message_n${Boff} "'"\\nFinishing with status of summarization --->" '"${BGon}; ${BBon}right_status ${BRon}"'$?'"${BGon}; ${BBon}echo${Boff}" && \
  echo && \
  sh_countdown 6 && \
  message_n "\nFinishing with status of summarization --->" ; right_status $?; echo

  return 0
}
