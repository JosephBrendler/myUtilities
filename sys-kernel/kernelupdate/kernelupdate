#!/bin/bash
# kernelupdate -- Joe Brendler 11 May 2024
# adapted from kernelupdate-dom0 of October 2021,
#   makeU-distrib-tar of February 2022, and
#   installU_onServer of February 2022
# generalized from kernelupdate-embedded, to (cross)build kernels for any platform
# including SBCs, big amd64 machines, xen domU PVs
#
# Notes:
# (1) dropped dom0 build support in favor of simple gentoo-kernel 20250507
#
# (2) Interactive support allows you to copy the ${manual_prefix} string and use it to
#   manually issue the sequence of commands that accomplishes a kernel update
#
# (3) this whole process assumes you have already cloned/linked the kernel sources
#
# (4) you can either "seed" build dir with .config or interactively (manually)
#   make one with, e.g. # eval ${make_me} imx_v8_defconfig
#
# (5) first run of kernelupdate for any given "model" creates directory structure
#
# To build cross compiler, start clean, and if stable versions are available use "-S" --
#   TARGET=armv7a-unknown-linux-gnueabihf
#   crossdev --clean --target ${TARGET}
#   crossdev -S -t ${TARGET}
# If a specific version of part of the toolchain is needed use this --
#   crossdev --b ~2.40 --g ~12.3 --k ~2.37 --l ~6.1 --target ${TARGET}
# may need to first run "nodist_path" and preface above with "FEATURES=${FEATURES} -distcc"
#
# see README_* instructions on getting kernel sources, manual process, etc.
#
# see also https://www.raspberrypi.com/documentation/computers/linux_kernel.html
#

#---[ execute setup and initialization, as required ]-------------------------
source /usr/sbin/script_header_joetoo

# source make.conf b/c we can't use e.g. PORTDIR="${ROOT}var/db/repos/gentoo"
d_message_n "sourcing make.conf to setting PORTDIR, PKGDIR, DISTDIR ..." 1
source /etc/portage/make.conf ; d_right_status $? 1

# default configuration 
# (config at /etc/${PN}.conf will overwrite/override this, and cmdline will override that )
VERBOSE=$TRUE
verbosity=1

d_message_n "assigning PN = $(basename $0)" 1
PN=$(basename $0) || die "failed to assign PN"
d_right_status $TRUE 1

# identify CONF_DIR (normally /etc/${PN}/${PN}.conf)
[[ -e /etc/${PN}/${PN}.conf ]] && CONF_DIR="/etc/${PN}" || die "CONF_DIR [/etc/${PN}/${PN}.conf] does not exist"

# source BUILD and BPN, then source script_header_joetoo_extended
# ( so the latter can get local.usage, local.cmdline_arguments, etc. which it locates at /etc/${BPN}/ )
d_message_n "sourcing BUILD and BPN" 1
source ${CONF_DIR%/}/BPN || die "failed to source BPN"
source ${CONF_DIR%/}/BUILD || die "failed to source BUILD"
debug_do 'echo -e -n " (BUILD: $BUILD ; BPN: $BPN)"' 1
d_right_status $TRUE 1
d_message_n "sourcing /usr/sbin/script_header_joetoo_extended" 1
source /usr/sbin/script_header_joetoo_extended || die "failed to source /usr/sbin/script_header_joetoo_extended"
d_right_status $TRUE 1

#-----[ edit this section to set default values ]------------------------------------
# ( override later with .conf and/or command line )
user="joe"
makeopts=" -j9 -l5"
features=" -userpriv -distcc"
arch="arm"
cross_compile="armv7a-unknown-linux-gnueabihf-"
model="rk3288-tinker-s"
image="zImage"
kernel="kernel7.img"
dtb_folder="rockchip"
overlay_folder="rockchip/overlay"
build_root="/home/${user}/My_${model}_project"
#my_devel_dir="/home/${user}/myUtilities/sys-kernel"
#my_devel_dir_credentials="/home/${user}/myUtilities/.git/.credentials"
sshkey_rsa="/home/${user}/.ssh/id_rsa"
sshkey_ecdsa="/home/${user}/.ssh/id_ecdsa"
sshkey_ed25519="/home/${user}/.ssh/id_ed25519"
package_category_dir="/home/${user}/joetoo/sys-kernel"
github_ebuild_repo_credentials="/home/${user}/joetoo/.git/.credentials"
host_dir=${build_root%/}/"domU_kernel_images"
INTERACTIVE=${FALSE}
RESUME=${FALSE}
answer=""
newanswer=""
SSH_AUTH_SOCK="/home/${user}/.ssh/ssh-agent.sock"
joetoo_kernel_webserver="raspi56403.brendler"

#-----[ override defaults above with (eselected) ${PN}.conf ]-------------------------
message_n "sourcing ${CONF_DIR%/}/${PN}.conf ..."
source ${CONF_DIR%/}/${PN}.conf || die "failed to source ${CONF_DIR%/}/${PN}.conf"
right_status $TRUE

#  source joetoo's custom setnodistpath tool, to drop distcc and ccache from PATH
message "${BMon}About to source ${BGon}setnodistpath${Boff} ..."
source /usr/bin/setnodistpath || die "failed to source /usr/bin/setnodistpath"
echo -e "   ${BMon}(readable) PATH includes: ${BWon}${PATH}${Boff}" | sed 's|:|\ :\ |g'
echo

# identify local variables by section, to make it easier to display configuration
# do this after sourcing config so some variables can be optionally excluded from varlist
config_parmlist="PN BPN bool.INTERACTIVE bool.RESUME starting_step stopping_step bool.VERBOSE"
config_parmlist+=" verbosity CONF_DIR user"
config_parmlist+=" model arch cross_compile makeopts features"
config_parmlist+=" image kernel lv.dtb_folder lv.overlay_folder lv.build_root"

auto_parmlist="lv.model_dir lv.KBUILD_OUTPUT lv.KERNEL_DIR lv.model_config lv.package_category_dir"
auto_parmlist+=" lv.github_ebuild_repo_credentials SSH_AUTH_SOCK lv.ebuild_dir lv.status_file"
[[ "${model:0:3}" !=  "dom" ]] && auto_parmlist+=" lv.host_dir"
auto_parmlist+=" BREAK sources_dir version_number lv.build_root lv.config_dir lv.build_dir"
auto_parmlist+=" kernel_basename lv.kernel_image_name"

output_parmlist="lv.distrib_dir lv.boot_dir lv.module_dir lv.lib_dir lv.host_dir"
output_parmlist+=" lv.publish_tarball_cmd_file"
output_parmlist+=" lv.publish_ebuild_cmd_file"
output_parmlist+=" joetoo_kernel_webserver"
copypaste_parmlist="lv.make_model lv.manual_prefix lv.make_me"

varlist="${config_parmlist} ${auto_parmlist} ${output_parmlist} ${copypaste_parmlist}"



# append "/" to dtb_folder and overlay_folder if missing and not null
#( [[ ${#dtb_folder} -gt 0 ]] && [[ ! "${dtb_folder: -1}" == "/" ]] ) && dtb_folder+="/"
#( [[ ${#overlay_folder} -gt 0 ]] && [[ ! "${overlay_folder: -1}" == "/" ]] ) && overlay_folder+="/"
# don't need these, since I adopted ${xxx_dir%/}/ instead

#-----[ you should not need to edit anything below this point ]---------------------------------------
sources_dir="${build_root%/}/linux"
config_dir="${build_root%/}/kernelconfigs"
build_dir="${build_root%/}/build"
status_file="${build_dir%/}/status"
model_dir="${build_dir%/}/${model}"
model_config="${model_dir%/}/.config"
kernel_basename="linux-${model}_joetoo_kernelimage"
distrib_dir="${model_dir%/}/tmp/distrib"
lib_dir="${distrib_dir%/}/lib"
boot_dir="${distrib_dir%/}/boot"
module_dir="<TBD>"  # to be set after make modules_install

# create the build directory structure if it does not exist (-p makes parents)
[[ ! -d "${build_root}" ]]  && mkdir -pv -m 755 "${build_root}"  && chown ${user}:${user} "${build_root}"
[[ ! -d "${config_dir}" ]]  && mkdir -pv -m 755 "${config_dir}"  && chown ${user}:${user} "${config_dir}"
[[ ! -d "${build_dir}" ]]   && mkdir -pv -m 755 "${build_dir}"   && chown ${user}:${user} "${build_dir}"
[[ ! -d "${model_dir}" ]]   && mkdir -pv -m 755 "${model_dir}"   && chown ${user}:${user} "${model_dir}"

# create the staging directory structure if it does not exist
[[ ! -d "${distrib_dir}" ]] && mkdir -pv -m 755 "${distrib_dir}" && chown ${user}:${user} "${distrib_dir}"
[[ ! -d "${lib_dir}" ]]     && mkdir -pv -m 755 "${lib_dir}"     && chown ${user}:${user} "${lib_dir}"
[[ ! -d "${boot_dir}" ]]    && mkdir -pv -m 755 "${boot_dir}"    && chown ${user}:${user} "${boot_dir}"
[[ "${model}" == "domU" ]] && \
[[ ! -d "${host_dir}" ]]    && mkdir -pv -m 755 "${host_dir}"    && chown ${user}:${user} "${host_dir}"

# set up the parts of the make command
make_prefix="MAKEOPTS="
make_prefix+="\"${makeopts}\" "
make_prefix+=" FEATURES="
make_prefix+="\"${features}\""
make_prefix+=" KERNEL_DIR=\"${sources_dir}\""

make_arch="ARCH=${arch} CROSS_COMPILE=${cross_compile}"
make_where="KBUILD_OUTPUT=${model_dir%/}/"
## drop this ; cd to sources_dir (may confuse where to find .config)
#make_src="-C ${sources_dir}"

# set up the cross-building make command for sbcs or domU
#make_model+="make KBUILD_OUTPUT=${model_dir%/}/ ARCH=${arch} CROSS_COMPILE=${cross_compile} "
#make_model="${make_prefix} ${make_where} ${make_arch} make ${make_src}"
make_model="${make_prefix} ${make_where} ${make_arch} make"

# set up the host build command for manual use, assuming already in ${sources_dir}
manual_prefix="${make_prefix} ${make_where} ${make_arch}"

# used to pick one of (make_model or make0) above based on model selection
make_me="${make_model}"

# get and set kernel version number and image name
old_dir=$PWD
# if this is the first-run for this model, sources_dir won't exist, so assign a placeholder for kernelversion
# after assigning/displaying config, sanity_check() will provide README-instructions
# instead of running command_sequence
if [[ ! -e "${sources_dir}" ]] ; then
    version_number="<TBD>"
else
    message "Old pwd: ${old_dir}" && cd ${sources_dir%/} && message "Now working in $PWD"
    version_number=$(eval ${make_me} -s kernelversion)
    # domU using gentoo-sources, will get version line "X.Y.Z-gentoo"
    #   but for domU, I don't want the "-gentoo" part, so strip it
fi
# if this build is for a domU, then fix the version number
if [ "${model}" == "domU" ] ; then
    version_number="${version_number/-gentoo/}"
fi
# build the kernel_image_name
d_message "version_number: ${version_number}" 3
kernel_image_name="${kernel_basename}-${version_number}"

# build pathnames for publish_tarball_cmd_file and publish_ebuild_cmd_file
#devel_dir="${my_devel_dir%/}"
ebuild_dir="${package_category_dir%/}/${kernel_basename}"
publish_tarball_cmd_file="${build_dir%/}/publish_tarball_${kernel_image_name}"
publish_ebuild_cmd_file="${build_dir%/}/publish_ebuild_${kernel_image_name}"

d_message "done setup and auto-configure" 3

# 20240724 - removed 'publish_ebuild' from sequence; now using consolidated linux-joetoo-kernelimage.${PV}.ebuild
#            (found that the consolidated ebuild doesn't work until ALL of the candidate kernels are actually built)
# 20250112 - put back 'publish_ebuild' for all but dom0; now using separate linux-${model_joetoo-kernelimage.${PV}.ebuilds
# 20250507 - dropped dom0 build (use gentoo-kernel w savedconfig instead)
# 20250920 - started rewrite to use script_header_joetoo_extended run_sequence and cmdline processing
# 20250928 - started migration of joetoo-kernels from github to joetoo_kernel_webserver
command_sequence=(
'cache_commit_signing_key'
'backup_config'
'make_mrproper'
'cp -v ${config_dir%/}/.config.bak ${model_config}'
'warn_oldconfig'
'eval ${make_me} oldconfig'
'eval ${make_me} prepare'
'eval ${make_me} menuconfig'
'save_new_config'
'eval ${make_me}'
'clean_distrib_dirs'
'install_kernel'
'install_modules'
'install_dtbs'
'make_tarball'
'publish_tarball'
'publish_ebuild'
)

msg1_sequence=(
'cache commit-signing key'
'back-up config'
'clean with make mrproper'
'restore backup .config file'
'warn about oldconfig'
'do eval ${make_me} oldconfig'
'do eval ${make_me} prepare'
'do eval ${make_me} menuconfig'
'save new config'
'do eval ${make_me}'
'clean output directories'
'install the kernel in package'
'install modules in package'
'install dtbs in package'
'make package tarball'
'publish package tarball'
'publish package ebuild'
)

msg2_sequence=(
'caching commit-signing key'
'backing-up config'
'cleaning with make mrproper'
'restoring backup .config file'
'warning about oldconfig'
'doing eval ${make_me} oldconfig'
'doing eval ${make_me} prepare'
'doing eval ${make_me} menuconfig'
'saving new config'
'doing eval ${make_me}'
'cleaning output directories'
'installing the kernel in package'
'installing modules in package'
'installing dtbs in package'
'making package tarball'
'publishing package tarball'
'publishing package ebuild'
)
d_message "done setting command sequence" 3

# set default starting and stopping step (override w cmdline)
starting_step=0
stopping_step=$(( ${#command_sequence[@]} -1 ))

#-----[ functions ]--------------------------------------------------

cache_commit_signing_key() {
    sudo -u ${user} echo "test" > /home/${user}/cachetest && \
    sudo -u ${user} gpg --clearsign /home/${user}/cachetest && \
    sudo -u ${user} rm /home/${user}/cachetest.asc; result=$?
    return $result
}

warn_oldconfig() {
  message "${BYon}Note: ${Mon}invalid old configs may not work with ${Gon}make oldconfig${Boff}"
  message "  ${BMon}==> if you see \"${Boff}Restarting config ... ${BMon}\"${Boff}"
  message "  ${BMon}in the next step, hit <CTRL>-C to end this program${Boff}"
  message "  ${LBon}then copy/paste the ${Gon}make_me=${LBon} assignment above,${Boff}"
  message "  ${LBon}cd sources_dir${Boff}"
  message "  ${LBon}[ ${Yon}note: sources_dir = ${sources_dir} ${LBon}]${Boff}"
  message "  ${LBon}run ${BBon}${sources_dir%/}/ # ${Gon}eval \${make_me} olddefconfig${Boff}"
  message "  ${BYon}and then restart this program with e.g. ${Gon}${PN} -r${Boff}"
  echo
  response=""
  msg="${BYon}Do you want run ${Gon}eval \${make_me} olddefconfig ${BYon} now? ${Boff}\n"
  msg+="${BWon}   (Y: yes, run it; N: no, abort; S: skip, to next step) ${Boff}"
  new_prompt "${msg}"
  d_message "response: $response" 5
  case ${response:0:1} in
    [yY] ) eval ${make_me} olddefconfig ; result=$?;
      if [ $result -eq 0 ] ; then
        d_message "make olddefconfig succeeded" 1
      else
        E_message "make olddefconfig failed"
        return 1
      fi
      ;;
    [sS] ) d_message "skipping as instructed" 2 ; return 0 ;;
    [nN] ) E_message "negative answer; aborting" ; return 1 ;;
    *    ) die "invalid newanser (should never happen)" ;;
  esac
  return 0
}

make_mrproper() {
  # clean up both the sources and build directories
  message "Now working in $PWD (should be sources directory)"
  clean_make_me="MAKEOPTS=\"${makeopts}\" FEATURES=\"${features}\" "
  clean_make_me+="make ARCH=${arch} CROSS_COMPILE=${cross_compile} "
  d_message "Cleaning sources directory [ ${sources_dir} ] ..." 1
  eval ${clean_make_me} mrproper || die "failed to clean_make_me mrproper"
  d_message "Cleaning ${model} build directory [ ${model_dir} ] ..." 1
  eval ${make_me} mrproper || die "failed to make_me mrproper"
  d_message "*Completely* cleaning ${model} build directory ..." 1
  # CAUTION: this will destroy your system if KBUILD_OUTPUT is unassigned
  if [ ! -z "${KBUILD_OUTPUT" ] ; then
    answer=""
    message "${BYon}Caution: About to remove KBUILD_OUTPUT filestructure with ${BRon}rm -r ${KBUILD_OUTPUT}/* ${KBUILD_OUTPUT}/*${Boff} "
    prompt "${BWon}(Y: Ok to continue ; N: No, abort)"
    if [[ "${answer}" == [yY] ]] ; then
      rm -r ${KBUILD_OUTPUT}/* ${KBUILD_OUTPUT}/* || die "failed while trying to delete KBUILD_OUTPUT filestructure"
    else
      die "aborting, as instructed"
    fi
  else
    die "KBUILD_OUTPUT [${KBUILD_OUTPUT}] appears to be null; not running rm command; exiting"
  fi
  return 0
}

backup_config() {
  if [[ -f ${model_config} ]]
  then
    cp -v ${model_config} ${config_dir%/}/.config.bak
  else
    msg="Config file [ ${model_config} ] not found.\n"
    msg+="${BYon} Please put a .config file in model build directory [ ${model_dir} ],\n"
    msg+=" or manually run an appropriate \"make xxx_defconfig\" command in model build directory${Boff}"
    E_message "$msg"
    exit
  fi
  return 0
}

save_new_config() {
  cp -v ${model_config} ${config_dir%/}/.config.${model}-${version_number} && return 0 || return 1
}

# leaving this here for reference, but it is depracated, since I now
# build all targets (kernel images, modules, and dtbs) with # eval "${make_me}"
make_dtbs() {
  # make dtbs for this model SBC, if this is not a domU build
  [ ! "${model:0:3}" == "dom" ] && eval "${make_me} dtbs"
  result=$? ; return $result

}

clean_distrib_dirs()
{
  message "${LBon}Cleaning the distribution staging directory...${Boff}"
  for x in $lib_dir $boot_dir
  do
    [[ -d $x ]] && find ${x%/}/ -mindepth 1 -iname '*' -delete
  done
  message "${LBon}Cleaning the tarball and ebuild publishing directory...${Boff}"
  find ${distrib_dir} -iname '*.tar.bz2' -delete
  find ${build_dir} -mindepth 1 -maxdepth 1 -iname 'publish*' -delete
  message "${BYon}Contents of ${distrib_dir} --"
  message "${BWon} --[ Should contain only empty boot and lib dirs ]-- ${Boff}"
  tree -a -L 2 ${distrib_dir%/}/
}

verify_boot_mount() {
  # if boot needs to be mounted, ensure it is, or try to mount it...
  if grep -v '^#' /etc/fstab | grep boot >/dev/null 2>&1  && \
    ! grep "/boot" /proc/mounts >/dev/null 2>&1
  then
    message "/boot is not mounted, trying to mount it now..."
    ! $(mount /boot) && \
     ( E_message "Failed to mount /boot" ; exit 1 ) || \
      message "Succeeded in mounting /boot ; continuing..."
  else
    message "Verified /boot is mounted ; continuing..."
  fi
  return 0
}

install_kernel()
{
    # stage kernel
    cd ${sources_dir} && message "Now working in $PWD"
    message "${LBon}Installing the kernel ...${Boff}"
    # if this is a domU kernel, install to host_dir (xen host use for guests) and boot_dir for tarball
    if [[ "${model}" == "domU" ]] ; then
        eval "INSTALL_PATH=${host_dir} ${make_me} install"
        eval "INSTALL_PATH=${boot_dir} ${make_me} install"
    else
        # Otherwise install to boot_dir for tarball. Start with make install
        echo -e -n "${BWon}"
        eval "INSTALL_PATH=${boot_dir} ${make_me} install" | sed 's|^|    |'
        #   also copy the proper image manually to the proper deployed kernel name
        #   as specified in the confg file
        echo -e -n "${BMon}"
        cp -av ${model_dir%/}/arch/${arch}/boot/${image} \
             ${boot_dir%/}/${kernel}-${version_number} | sed 's|^|    |'
        echo -e -n "${Boff}"
        # for extra assurance, copy all kernels found here, named as built
        # ${image} specified in config file should be one of --
        #  "Image" (uncompressed, raw kernel binary)
        #  "zImage" (self-extracting, compressed kernel image, loads itself in low memory for older bootloaders/systems)
        #  "Image.gz" (the Image file compressed using the gzip; requires the bootloader to decompress it)
        #  "bzImage" (Big zImage) allows decompression into high memory for larger kernels
        #  (see docs to determine which is needed)
        k_out_dir="${model_dir%/}/arch/${arch}/boot/"
        d_message "k_out_dir: $k_out_dir" 5
        message "${LBon}Also staging other kernel image formats ...${Boff}"
        k_name_list="Image zImage Image.gz bzImage vmlinuz vmlinux"
        for k_name in ${k_name_list} ; do
            d_message "looking for k_name: [${k_name}] in k_out_dir: [${k_out_dir%}]" 4
            # if there is one of these, copy it
            d_message "${BYon}----- will examine each line in the following -----${Boff}" 4
            debug_do 'echo -e -n "${BMon}"; find ${k_out_dir%} -name "${k_name}"; echo -e -n "${Boff}"' 4
            d_message "${BYon}------- will examine each line in the above -------${Boff}" 4
            for file in $(find ${k_out_dir%} -name "${k_name}") ; do
                d_message "${BWon}copying file [$file]${Boff}" 5
                echo -e -n "${BMon}"
                cp -av ${file} ${boot_dir%/}/ | sed 's|^|    |'
                echo -e -n "${Boff}"
            done
        done
    fi
    return 0
}

install_modules()
{
  # stage modules
  cd ${sources_dir} && message "Now working in $PWD"
  message "${LBon}Installing modules ...${Boff}"
  # stage modules for tarball
  eval "${make_me} INSTALL_MOD_PATH=${distrib_dir} modules_install"

  # identify the new module directory
  message_n "re-setting module_dir"
  module_dir=$( basename $( find ${lib_dir%/}/modules/  -maxdepth 1  -iname ${version_number}*  -type d ) ) || \
      die "failed to assign module_dir"
  echo -e -n " (${module_dir})"
  right_status $TRUE

  # fix the build and source symlinks
  message "${LBon}Fixing the ${lib_dir%/}/modules/${module_dir%/}/build symlink...${Boff}"
  cd ${lib_dir%/}/modules/${module_dir} && message "Now working in $PWD"
  rm -v build 2>/dev/null
  ln -snfv /usr/src/linux build
  message "${LBon}Fixing the ${lib_dir%/}/modules/${module_dir%/}/source symlink...${Boff}"
  rm -v source 2>/dev/null
  ln -snfv /usr/src/linux source
  cd $old_dir && message "Now working in $PWD"
  return 0
}

install_dtbs()
{
    # note - dtb_folder and overlay_folder are relative to build/${model}/arch/${ARCH}/boot/dts/
    cd ${sources_dir} && message "Now working in $PWD"
    message "${LBon}Installing device tree and overlay [.dtb and .dtbo] files ...${Boff}"
    mkdir -p ${boot_dir%/}/dts/${dtb_folder}
    eval "${make_me} INSTALL_DTBS_PATH=${boot_dir%/}/dts/${dtb_folder%/}/ dtbs_install"

    message "In case of error in dtbs_install, will try to manually copy ..."
    # manually install dtb files from dtb_folder (omit subdirectories like "overlays")
    for file in $(find ${model_dir%/}/arch/${arch}/boot/dts/${dtb_folder%/}/ -maxdepth 1 -mindepth 1 -type f -iname '*.dtb' -or -iname 'README*')
    do cp -av ${file} ${boot_dir%/}/dts/${dtb_folder%/}/ ; done
    # manually install dtbo files from overlay_folder (omit .tmp, .cmd files, and omit subdirectories for now)
    mkdir -p ${boot_dir%/}/dts/${overlay_folder%/}/
    for file in $(find ${model_dir%/}/arch/${arch}/boot/dts/${overlay_folder%/}/ -maxdepth 1 -mindepth 1 -type f -iname '*.dtb*' -and -not -iname '\.*')
    do cp -av ${file} ${boot_dir%/}/dts/${overlay_folder%/}/ ; done
    # copy the overlay_folder's README file(s) if it/they exist(s)
    for file in $(find ${model_dir%/}/arch/${arch}/boot/dts/${overlay_folder%/}/ -maxdepth 1 -type f -iname 'README*')
    do cp -av ${file} ${boot_dir%/}/dts/${overlay_folder%/}/ ; done
    # copy the one dtb file we need up to boot
    message "${LBon}Staging the dtb file for tarball ...${Boff}"
    cp -av ${boot_dir%/}/dts/${dtb_folder%/}/${model}.dtb ${boot_dir%/}/

    # for extra assurance, copy the entire dts folder...
    message "${LBon}Also staging the entire dts folder for tarball (just in case) ...${Boff}"
    mkdir -p ${boot_dir%/}/entire_source_dts
    cp -av ${model_dir%/}/arch/${arch}/boot/dts ${boot_dir%/}/entire_source_dts/
    return 0
}

make_tarball()
{
    message "${BGon}Entering $distrib_dir${Boff}"
    cd $distrib_dir
    d_message "pwd: $(pwd)" 2

    # create staged tar archive
    message "${LBon}Creating the tar archive ...${Boff}"

    # create tarball from staged contents; don't include kernel sources
    tar_command="tar "
    tar_command+="  --exclude lib/modules/${module_dir%/}/source/"
    tar_command+="  --exclude lib/modules/${module_dir%/}/build/"
    tar_command+="  -cvjf ${kernel_image_name}.tar.bz2 ./boot ./lib"
    eval $tar_command && \
    message "${BYon}Complete.  Your tarball is located in the ${LBon}${distrib_dir}${BYon} directory${Boff}" || \
    E_message "${BRon}Something went wrong -- refer to output above${Boff}"
    cd $old_dir && message "Now working in $PWD"
    return 0
}

publish_tarball() {
    # Migrating joetoo-kernels from github to raspi56403.brendler as of 28 Sep 2025
    # So this script no longer needs to publish to github.  Instead it will
    # will use scp to transfer (as ${user}) these files to ${user}'s home directory
    # on raspi56403.brendler, and we will rely on a cron job on raspi56403.brendler
    # to move these files up to the web server
    d_message "joetoo_kernel_webserver: $joetoo_kernel_webserver" 3
    publish_tarball_command_sequence=()

    # set SSH_AUTH_SOCK env var to a fixed value and test whether ${SSH_AUTH_SOCK} is valid
    # if not valid,  remove the old one, then start ssh-agent using ${SSH_AUTH_SOCK}
    # check for ssh keys, and add if they are not already loaded copy the new tarball
    # to joetoo_kernel_webserver

    publish_tarball_command_sequence+=( \
        "#!/bin/bash" \
        'export SSH_AUTH_SOCK="'"${SSH_AUTH_SOCK}"'"' \
        "ssh-add -l 2>/dev/null >/dev/null" \
        '[ $? -ge 2 ] && ssh-agent -a ${SSH_AUTH_SOCK} >/dev/null' \
        "echo 'ssh-agent added, listing keys ...'" \
        "ssh-add -l" \
        '[[ -z $(ssh-add -l | grep -v "no identities") ]] && for x in ${sshkey_rsa} ${sshkey_ecdsa} ${sshkey_ed25519}; do ssh-add ${x}; done' \
        'echo' )

    # change ownership for upload
    message_n 'changing ownership for upload ...'
    chown -R ${user}:${user} ${distrib_dir%/}/${kernel_image_name}.tar.bz2 ; right_status $?

    # now actually copy the tarball to the webserver with scp
    publish_tarball_command_sequence+=( \
        "echo; message_n 'copying tarball package to webserver ...'" \
        "scp ${distrib_dir%/}/${kernel_image_name}.tar.bz2 ${joetoo_kernel_webserver}:/home/${user}/" \
        )

    # now output the publish_tarball_command_sequence arrat into a file (script)
    echo; message "Building publish_tarball_cmd_file [ ${publish_tarball_cmd_file} ]..."
    # actually build the publish_tarball_cmd_file from the publish_tarball_command_sequence
    # first command uses single ">", to initialize the file; then others use ">>"
    echo ${publish_tarball_command_sequence[0]} > ${publish_tarball_cmd_file}
    for ((i=1; i<${#publish_tarball_command_sequence[@]}; i++))
    do
        message_n "adding line $i: [ "
        echo -n ${publish_tarball_command_sequence[$i]}
        echo -n " ] ..."
        echo ${publish_tarball_command_sequence[$i]} >> ${publish_tarball_cmd_file}
        right_status $?
    done

    message "leaving $(pwd)" &&  cd ${old_dir} && message "Now working in $(pwd)"
    separator "${FUNCNAME[0]}" "(script contents)"
    cat ${publish_tarball_cmd_file} | sed 's|^|    |'
    message_n "setting permissions on ${publish_tarball_cmd_file} ... "
    chown ${user}:${user} ${publish_tarball_cmd_file} && \
    chmod +x ${publish_tarball_cmd_file} ; right_status $?

    # now actually execute the publication by running the publication command file
    separator "${FUNCNAME[0]}" "(executing script)"
    sudo -u ${user} ${publish_tarball_cmd_file}

    result=$? ; return $result
}

publish_ebuild() {
    # tried retiring this and consolidating all kernels of a given version in one ebuild
    #   (but then you have to build all 12 kernels before anyone can use the ebuild)
    #   (so I'm going back to an ebuild for the kernel for each model)

    publish_ebuild_command_sequence=()
    publish_ebuild_command_sequence=('#!/bin/bash' \
        'export SSH_AUTH_SOCK="'"${SSH_AUTH_SOCK}"'"' \
        "ssh-add -l 2>/dev/null >/dev/null" \
        '[ $? -ge 2 ] && ssh-agent -a ${SSH_AUTH_SOCK} >/dev/null' \
        "echo 'ssh-agent added, listing keys ...'" \
        "ssh-add -l" \
        "source ${github_ebuild_repo_credentials}" \
        "echo" \
        "cd ${ebuild_dir%/}/" \
        "echo new PWD: \${PWD}" \
        "git pull" )

    # if the ebuild_dir does not exist, create it
    if [[ ! -d "${ebuild_dir}" ]] ; then
      mkdir -pv -m 755 "${ebuild_dir}"
      chown -R ${user}:${user} "${ebuild_dir}"
      publish_ebuild_command_sequence+=("git add ./")
    else
      d_message "${ebuild_dir} already exists; not creating." 3
    fi

    # move to the ebuild dir
    message "pwd: $(pwd)" && cd ${ebuild_dir} && message "Now working in $$(pwd)"

    NEW_TEMPLATE=$FALSE
    new_template="${CONF_DIR%/}/template_linux-MODEL_joetoo_kernelimage-0.0.0.ebuild"
    old_template="${ebuild_dir%/}/linux-${model}_joetoo_kernelimage-0.0.0.ebuild"
    # if the ebuild dir does not contain a template ebuild, then populate it
    if [[ ! -f $old_template ]] ; then
      # populate ebuild template if needed
      if [[ -f $new_template ]] ; then
        message_n "published ebuild template does not exist; creating one ..."
        cp $new_template $old_template ; right_status $?
        chown -R ${user}:${user} "${ebuild_dir%/}/"
        publish_ebuild_command_sequence+=("git add linux-${model}_joetoo_kernelimage-0.0.0.ebuild")
        NEW_TEMPLATE=$TRUE
      else
	E_message "${BRon}Error: ${Boff} $new_template does not exist" 3
      fi
    else
      d_message "$old_template already exists; not creating." 3
    fi

    # if the ebuild dir contains a template that has changed, then replace it (shouldn't run if above just did)
    if [[ $(diff $new_template $old_template) ]] ; then
        message_n "ebuild template has been updated; replacing old one ..."
        cp $new_template $old_template ; right_status $?
        chown -R ${user}:${user} "${ebuild_dir%/}/"
        publish_ebuild_command_sequence+=("git add linux-${model}_joetoo_kernelimage-0.0.0.ebuild")
        NEW_TEMPLATE=$TRUE
    fi

    NEW_METADATA=$FALSE
    new_metadata="${CONF_DIR%/}/template_linux-MODEL_joetoo_kernelimage-0.0.0.metadata.xml"
    old_metadata="${ebuild_dir%/}/metadata.xml"
    # if the ebuild dir does not contain a metadata file, then populate it
    message "CONF_DIR: ${CONF_DIR}"
    if [[ ! -f $old_metadata ]] ; then
      # populate metadata.xml if needed
      if [[ -f $new_metadata ]] ; then
        cp  $new_metadata $old_metadata
        chown -R ${user}:${user} "${ebuild_dir%/}/"
        publish_ebuild_command_sequence+=("git add /metadata.xml")
        NEW_METADATA=$TRUE
      else
	E_message "${BRon}Error: ${Boff} $new_metadata does not exist" 3
      fi
    else
      d_message "$old_metadata already exists; not creating." 3
    fi
    # if the ebuild dir contains a metadata file that has changed, then replace it (shouldn't run if above just did)
    if [[ $(diff $new_metadata $old_metadata) ]] ; then
        message_n "ebuild metadata has been updated; replacing old one ..."
        cp $new_metadata $old_metadata ; right_status $?
        chown -R ${user}:${user} "${ebuild_dir%/}/"
        publish_ebuild_command_sequence+=("git add ${ebuild_dir%/}/metadata.xml")
        NEW_METADATA=$TRUE
    fi

    ## don't bother with finding latest version ; just use template
    # enumerate existign ebuilds and determine the most recent "old version" of the ebuild
#    ebuild_list=()
#    message_n "enumerating existing ebuilds for $kernel_basename ..."
#    for x in $(find ${ebuild_dir} -type f -iname "linux-*" | sort)
#    do
#      ebuild_list+=("${x}")
#    done ; right_status $?
    # the ebuild dir will contain at least the 0.0.0 template (populated above during first run of this script for this model)
#    message_n "finding most recent existing ebuild version ..."
#    old_version=$(echo ${ebuild_list[$((${#ebuild_list[@]}-1))]} | sed "s|${ebuild_dir%/}/${kernel_basename}-||" | sed 's|.ebuild||')
    old_version="0.0.0"
    right_status $?
    message "old version: ${old_version}"

    # determine the new version number and kernel image name
    # ebuild naming syntax forbids the "-gentoo" in the image name, and domU using gentoo-sources will be named that way, so fix it
    message_n "determining new version number and kernel image name ..."
    new_version="$(echo ${version_number} | sed 's/-gentoo//')" && \
    version_number="${new_version}" && \
    new_kernel_image_name="$(echo ${kernel_image_name} | sed 's/-gentoo//')" && \
    kernel_image_name="${new_kernel_image_name}"
    right_status $?
    message "new version: ${version_number}"

    # create the new ebuild file
    message "ebuild_dir: ${ebuild_dir}"
    message "kernel_basename: ${kernel_basename}"
    message "old ebuild full pathname: ${ebuild_dir%/}/${kernel_basename}-${old_version}.ebuild"
    message "new ebuild full pathname: ${ebuild_dir%/}/${kernel_image_name}.ebuild"
    cp ${ebuild_dir%/}/${kernel_basename}-${old_version}.ebuild ${ebuild_dir%/}/${kernel_image_name}.ebuild
    # don't chown -R ${variable}/ -- if variable is null, it will dork up your filesystem
#    chown -R ${user}:${user} ${ebuild_dir%/}/
    chown -R ${user}:${user} ${ebuild_dir%/}
    # remove the old Manifest file
    rm ${ebuild_dir%/}/Manifest 2>/dev/null

    # build the git command sequence
    publish_ebuild_command_sequence+=( \
        "pkgdev manifest -f -d ${DISTDIR}" \
        "git status" \
        "git add Manifest" \
        "git add ../../metadata/md5-cache/sys-kernel/${kernel_image_name}" \
        "git add ${kernel_image_name}.ebuild")
    # if we created new template file above, then add the new hash file, too
    [[ $NEW_TEMPLATE ]] && publish_ebuild_command_sequence+=( \
         "git add ../../metadata/md5-cache/sys-kernel/${kernel_basename}-${old_version}")
#    [[ $NEW_METADATA ]] && publish_ebuild_command_sequence+=( \
#         "git add ../../metadata/md5-cache/sys-kernel/metadata.xml")
    # cntinue building the git command sequence
    publish_ebuild_command_sequence+=( \
        "git commit -s -m \"adding ${kernel_image_name}\"" \
        'eval "git push git@github.com:${gituser}/${gitrepo}.git master"' \
        'git push' \
        '' )

    # actually build the publish_ebuild_cmd_file from the publish_ebuild_command_sequence
    # first command uses single ">", to initialize the file; then others use ">>"
    echo ${publish_ebuild_command_sequence[0]} > ${publish_ebuild_cmd_file}
    for ((i=1; i<${#publish_ebuild_command_sequence[@]}; i++))
    do
        message_n "adding line $i: [ "
        echo -n ${publish_ebuild_command_sequence[$i]}
        echo -n " ] ..."
        echo ${publish_ebuild_command_sequence[$i]} >> ${publish_ebuild_cmd_file}
        right_status $?
    done

#    message_n "loading ssh key if needed ..."
#    [[ -z $(ssh-add -l | grep -v "no identities") ]] && ssh-add ${gitsshkey} ; right_status $?

    cd ${old_dir} && message "Now working in $PWD"
    separator "contents of ${publish_ebuild_cmd_file}... " $(hostname)
    cat ${publish_ebuild_cmd_file}
    echo
    message_n "setting permissions on ${publish_ebuild_cmd_file}... "
    chown ${user}:${user} ${publish_ebuild_cmd_file} && \
    chmod +x ${publish_ebuild_cmd_file} ; right_status $?

    # now actually execute the publication by running the publication command file
    separator "now executing commands in ${publish_ebuild_cmd_file}... " $(hostname)
    sudo -u ${user} ${publish_ebuild_cmd_file}

    result=$? ; return $result
}


display_config()
{
    longest=$(get_longest ${varlist})

    message "${BMon}Current Configuration:${Boff}"
    display_vars ${longest} "CONF_DIR"
    echo
    separator "From Config File and/or command line" $(hostname)
    display_vars ${longest} ${config_parmlist}
    echo
    separator "Auto-configured" $(hostname)
    display_vars ${longest} ${auto_parmlist}
    echo
    separator "Output Information" $(hostname)
    display_vars ${longest} ${output_parmlist}
    echo
    separator "Copy/Paste Information" $(hostname)
    cplongest=$(get_longest ${copypaste_parmlist})
    display_vars ${cplongest} ${copypaste_parmlist}
    echo
    message "${Mon}If building manually${Boff} --"
    message "  ${Mon}first${Boff} cd ${sources_dir}"
    message "  ${Mon}then${Boff} copy/paste the make_me or manual_prefix variable assignment --"
    message "  ${Gon}manual_prefix='${manual_prefix}'${Boff}"
    echo
    message "  ${Gon}make_me='${make_me}'${Boff}"
    echo
    message "${Mon}then use e.g.${Boff} --"
    msg1='eval ${manual_prefix}'
    msg2="./scripts/kconfig/merge_config.sh .config ${Boff}<path-to-config-fragment>"
    message "${Gon}${msg1} ${msg2}${Boff}"
    message "or"
    msg2="make menuconfig${Boff}"
    message "${Gon}${msg1} ${msg2}${Boff}"
    echo
    msg1='eval ${make_me} olddefconfig'
    message "or"
    message "${Gon}${msg1}${Boff}"
    echo
    return 0
}

make_sources_message() {
    # pull text from ${CONF_DIR%/}/README-instructions
    # ignore lines beginning with two #s (i.e. "##")
    # echo lines beginning with one "#" in light blue
    # ehco other lines in bright white
    #
    d_message "running make_sources_message() ..." 3
    d_message "CONF_DIR: ${CONF_DIR}" 3
    d_message_n "README-instructions file" 3
    [ -f ${CONF_DIR%/}/README-instructions ] && d_message "found" 3 || dE_message "not found!" 3
    while read line
    do
      d_message "considering line: $line" 5
      if [ "${line:0:1}" == "#" ] ; then
        if [ "${line:1:1}" != "#" ] ; then    # do not print those lines starting "##" at all
            echo -e ${LBon}${line}${Boff}    # emphasize in light blue the comment lines beginning "#"
        fi
      else
        echo -e ${BWon}${line}${Boff}        # emphasize in bright white only the lines that do not begin with "#"
      fi
    done < ${CONF_DIR%/}/README-instructions

    result=$? ; return $result
}

sanity_check() {
    # veryfy the sanity of the combination of arguments on the command line
    ### this is carried over from jus example, but it is not used here (yet)

    ### posible future additional sanity checks like this...
    #BOGUSTEST=${FALSE}
    #[[ ! $INTERACTIVE ]] && [[ $RESUME ]] && [[ $BOGUSTEST ]] \
    #   E_message "Dangerous option combination: noninteractive and resume" && \
    #   usage && exit 1

    d_message "running sanity_check() ..." 3
    d_message "sources_dir: ${sources_dir}" 3
    answer=""
    if [[ $starting_step -eq 0 ]]
    then
      # if a sources directory has not been linked, advise the user about this
      if [[ ! -e "${sources_dir}" ]]
      then
        separator "${PN}" "Manual Prerequisites"
        E_message "${BRon}sources_dir [ ${sources_dir} ] does not exist${Boff}"
        make_sources_message
        exit
      else
        # confirm the current configuration before executing main script
        prompt "${BYon}Starting ${PN}.\n Please confirm configuration above.\n${LBon}Continue? ${Boff}?"
        [[ ! $answer == [Yy] ]] && return 1
      fi
    else
      # resume operation at some step other than 0
      do_first_prompt="${BMon}Resuming at step [ ${BWon}$starting_step${BMon} ] --[ ${BGon}${command_sequence[${starting_step}]}${BMon} ]--${Boff}\n"
      do_first_prompt+="${BYon}Please verify configuration above.${Boff}"
      prompt "${do_first_prompt}\n${LBon} Continue? ${Boff}?"
      [[ ! $answer == [yY] ]] && return 1
    fi
    return 0
}

#-----[ main script ]------------------------------------------------
checkroot
separator "${PN}-${BUILD}" $(hostname)
starting_step=0

validate_status_file ${status_file} || die "failed to validate_status_file"

process_cmdline "${@}" || die "failed to process command line"

display_config || die "failed display_config"
#sh_countdown 2

sanity_check || die "failed sanity_check"

run_sequence ${status_file} || die "failed run_sequence"

final_msg="${BMon}Components, including kernel image [ ${image} ], modules, overlays, "
final_msg+="and dtb files, as appropriate for model [ ${model} ], successfully staged in "
final_msg+="${build_dir%/}/${model} and published in ${kernel_image_name}.ebuild${Boff}"
message "${final_msg}"
