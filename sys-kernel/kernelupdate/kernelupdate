#!/bin/bash
#
# 20260219 - this s a complete rewrite of kernelupdate, using the new joetoo cli and messaging framework

script_header_installed_dir="/usr/sbin"
#script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo
# source script_header
header="${script_header_installed_dir%/}/script_header_joetoo"

echo "header: $header"

if [ -f "$header" ]; then . "$header"; else printf '%s' "failed to source header; cannot continue"; exit 1; fi
printf '%s' "Checking for header commands to confirm sourcing"
if command -v toc >/dev/null 2>&1 && command -v run_sequence >/dev/null 2>&1 ; then
handle_result $? ; else printf '%s\n' "Failed; header not sourced; cannot continue"; exit 1; fi

#-----[ variables ]----------------------------------------------------

# NOTE: varlist variables are initialized by app_configure() and displayed by show_config();
# the basic set of varlist variables is defined in script_header_joetoo and can be extended
# either in the using script or in its .conf files.
# An example is provided in the joetoo_cli_example script and in the template joetoo_cli_example.conf
#
# BREAK tells display_vars to add a newline spacer in its output
# $LOCALIZED exemplifies use of the joetoo pseudo-boolean data type for POSIX scripts
# $EXAMPLE and $DEFAULTS are pseudo-booleans defined in joetoo_cli_example_local.cmdline_arg_handler
# $INITIALIZED_ME and $SOURCED_ME exemplify use of the joetoo yn data type
# Note how each is named and how these types are prefixed in the varlist, to inform initialize_vars
# and display_vars how to handle them.
# $longone is a long string defined in script_header_joetoo to test and illustrate smart wrapping
# by the smart_wrap_n() function. its name is prefixed "lv." in this localized extension of varlist
# to indicate (long variable), so display_vars will use smart_wrap_n() to display the content of
# $longone (which is long-one btw, not long-gone)
#
# CAVEAT: varlist is instantiated when script_header_joetoo is sourced (above), so it IS safe to add
# variable names to it in a "variables" section at the top of your main script, but note that
# the standard joetoo cli script layout calls app_configure() after that --
# so anything you add to varlist before app_configure will be over-written when app_configure
# calls initialize_var. which sets all bool. to $FALSE, all yn. to "no" and all others to ""
#
# Bottom line: you can append variable names to varlist at the top of your script, but if you do, you
# ALSO need to reassign them AFTER app_configure runs. Thus it is "easier" to just append
# variable names to varlist in the .conf file, which app_configure() loads AFTER it calls
# initialize_vars, but be sure to also assign them, b/c they will not be initialized otherwise
#LOCALIZED=$FALSE; INITIALIZED_ME="no"
#varlist="${varlist} BREAK bool.LOCALIZED yn.INITIALIZED_ME"

#-----[ edit this section to set default values ]------------------------------------
# ( .conf loaded by script_header_joetoo's app_configure() will override these )
# ( _user can also overriede on command line )
_user="joe"                                           ### this is going to be an issue
                                                       # the program must be run by root
                                                       # joetoo cli now assigns "_user" by looking at
                                                       # who is logged in and running the app
                                                       # so I will have to refactor what kernelupdate is doing
                                                       # i.e. knowing what _user ssh keys to use for github
makeopts=" -j9 -l5"
features=" -userpriv -distcc"
arch="arm"
cross_compile="armv7a-unknown-linux-gnueabihf-"
model="rk3288-tinker-s"
image="zImage"
kernel="kernel7.img"
dtb_folder="rockchip"
overlay_folder="rockchip/overlay"
build_root="/home/${_user}/My_${model}_project"
#my_devel_dir="/home/${_user}/myUtilities/sys-kernel"
#my_devel_dir_credentials="/home/${_user}/myUtilities/.git/.credentials"
sshkey_rsa="/home/${_user}/.ssh/id_rsa"
sshkey_ecdsa="/home/${_user}/.ssh/id_ecdsa"
sshkey_ed25519="/home/${_user}/.ssh/id_ed25519"
package_category_dir="/home/${_user}/joetoo/sys-kernel"
github_ebuild_repo_credentials="/home/${_user}/joetoo/.git/.credentials"
host_dir="${build_root%/}/domU_kernel_images"
INTERACTIVE="$FALSE"
RESUME="$FALSE"
answer=""
SSH_AUTH_SOCK="/home/${_user}/.ssh/ssh-agent.sock"
joetoo_kernel_webserver="raspi56403.brendler"

# NOTE: these are set by script_header_joetoo and populated by app_configure
# so YOU don't have to do it here
#varlist="PN BUILD user logFile status_file config_dir config_files verbosity"
#varlist="${varlist} num_cmds starting_step stopping_step BREAK"
#varlist="${varlist} bool.INTERACTIVE bool.RESUME bool.LOGGING bool.QUIET bool.DEBUG"
#varlist="${varlist} bool.handle_local_arg_EXISTS bool.handle_local_compound_arg_EXISTS"
#varlist="${varlist} bool.handle_local_usage_EXISTS"
#varlist="${varlist} app_customization_root local_cmdline_arg_handler"

# identify local variables by section, to make it easier to display configuration
# do this after sourcing config so some variables can be optionally excluded from varlist
# NOTE: user is who is running the program (root) whereas _user is who are we running it for
#   (i.e. whose ssh keys are we going to use, whose /home/ directory, etc (for me, that is joe)
config_parmlist="_user"
config_parmlist+=" model arch cross_compile makeopts features"
config_parmlist+=" image kernel lv.dtb_folder lv.overlay_folder lv.build_root"

auto_parmlist="lv.model_dir lv.KBUILD_OUTPUT lv.KERNEL_DIR lv.model_config lv.package_category_dir"
auto_parmlist+=" lv.github_ebuild_repo_credentials SSH_AUTH_SOCK lv.ebuild_dir lv.status_file"
[[ "${model:0:3}" !=  "dom" ]] && auto_parmlist+=" lv.host_dir"
auto_parmlist+=" BREAK sources_dir version_number lv.build_root lv.config_dir lv.build_dir"
auto_parmlist+=" kernel_basename lv.kernel_image_name"

output_parmlist="lv.distrib_dir lv.boot_dir lv.module_dir lv.lib_dir lv.host_dir"
output_parmlist+=" lv.publish_tarball_cmd_file"
output_parmlist+=" lv.publish_ebuild_cmd_file"
output_parmlist+=" joetoo_kernel_webserver"
copypaste_parmlist="lv.make_model lv.manual_prefix lv.make_me"

header_varlist="$varlist"
varlist="${header_varlist} ${config_parmlist} ${auto_parmlist} ${output_parmlist} ${copypaste_parmlist}"

# append "/" to dtb_folder and overlay_folder if missing and not null
#( [[ ${#dtb_folder} -gt 0 ]] && [[ ! "${dtb_folder: -1}" == "/" ]] ) && dtb_folder+="/"
#( [[ ${#overlay_folder} -gt 0 ]] && [[ ! "${overlay_folder: -1}" == "/" ]] ) && overlay_folder+="/"
# don't need these, since I adopted ${xxx_dir%/}/ instead

#-----[ functions ]----------------------------------------------------

initialize_command_sequence() # (POSIX) initialize command sequence for joetoo cli framework
{ ics_ret=0
  _ics_FLAGGED=$FALSE
  info_msg_n "creating tempfile for command sequnce"
  cmd_seq_file=$(mktemp /tmp/${PN}.XXXXXX)
  info_handle_result $? "$cmd_seq_file" '' || _ics_FLAGGED=$TRUE

  info_msg_n "setting trap to remove tempfile on EXIT"
  trap 'rm -f "$cmd_seq_file"' EXIT
  info_handle_result $? "trap set" ''  || _ics_FLAGGED=$TRUE

  notice_msg_n "initializing command sequence"
  num_cmds=0   # global variable holding the length of the sequence
# heredoc needs to be on the left edge; no leading whitespace
# initialize/clear the command sequence file
# format for each line of heredoc content is:
#   command_string${US}description_string
#   where: command_string is POSIX executable
#   and:   ${US} is teletype era unit separator char \037 pre-cooked with printf
#   and:   description_string is a human-readable description of the command
while IFS= read -r _ics_entry; do
      [ -z "$_ics_entry" ] && continue
      # write directly to the file instead of using  ' set -- "$@" '
      printf '%s\n' "$_ics_entry" >> "$cmd_seq_file"
      num_cmds=$(( num_cmds + 1 ))
done <<EOF
backup_config${US}back-up config
make_mrproper${US}clean with make mrproper
cp -v ${config_dir%/}/.config.bak ${model_config}${US}restore backup .config file
warn_oldconfig${US}warn about oldconfig
eval ${make_me} oldconfig${US}do eval ${make_me} oldconfig
eval ${make_me} prepare${US}do eval ${make_me} prepare
eval ${make_me} menuconfig${US}do eval ${make_me} menuconfig
save_new_config${US}save new config
eval ${make_me}${US}do eval ${make_me}
clean_distrib_dirs${US}clean output directories
install_kernel${US}install the kernel in package
install_modules${US}install modules in package
install_dtbs${US}install dtbs in package
make_tarball${US}make package tarball
publish_tarball${US}publish package tarball
publish_ebuild${US}publish package ebuild
EOF
  handle_result $? "num_cmds: $num_cmds" '' || _ics_FLAGGED=$TRUE

  info_msg_n "initailizing starting_step"
  starting_step=1
  info_handle_result $? "$starting_step" '' || _ics_FLAGGED=$TRUE

  info_msg_n "initializing stopping step"
  stopping_step="$num_cmds"
  info_handle_result $? "$stopping_step" '' || _ics_FLAGGED=$TRUE

  [ "$_ics_FLAGGED" ] && ics_ret=1
  export num_cmds
  export cmd_seq_file
  unset -v _ics_entry _ics_FLAGGED _ics_result
  return $ics_ret
}
# @usage initialize_command_sequence || die "failed to initialize_command_sequence"
# @vars sets global num_cmds, cmd_seq_file
# @vars initializes global starting_step=1, stopping_step=$num_cmds
# @rule creates a temporary file for command execution and sets an EXIT trap for cleanup
# @rule command sequency entry format 'command_string${US}description_string'
# @cont where: command_string is POSIX executable
# @cont and:   ${US} is teletype era unit separator char \037 pre-cooked with printf
# @cont and:   description_string is a human-readable description of the command
# @ret 0 on success; 1 on failure


kernelupdate_configure()
{ # 20260218 - this function created to defer this initialization untill after app_configure() has run
  # so that it will properly set variables and not immediately erase them
  local kc_ret=0

#-----[ re-do base config in case app_configure 
#-----[ override defaults above with (eselected) ${PN}.conf ]-------------------------


# source make.conf b/c we can't use e.g. PORTDIR="${ROOT}var/db/repos/gentoo"
notice_msg_n "sourcing make.conf to set PORTDIR"
PORTDIR=$(source /etc/portage/make.conf; echo $PORTDIR)
handle_result $? "$PORTDIR" ""
notice_msg_n "sourcing make.conf to set PKGDIR"
PKGDIR=$(source /etc/portage/make.conf; echo $PKGDIR)
handle_result $? "$PKGDIR" ""
notice_msg_n "sourcing make.conf to set DISTDIR"
DISTDIR=$(source /etc/portage/make.conf; echo $DISTDIR)
handle_result $? "$DISTDIR" ""

#  source joetoo's custom setnodistpath tool, to drop distcc and ccache from PATH
notice_msg_n "sourcing ${BGon}setnodistpath${Boff} ..."
source /usr/bin/setnodistpath
handle_result $? "" "" || die "failed to source /usr/bin/setnodistpath"

notice_msg_n "   ${BMon}(readable) PATH includes:"
echo_msg "${BWon}$(printf '%s' $PATH | tr ':' ' ')${Boff}"

_user=joe
build_root="/home/${_user}/My_${model}_project"
sshkey_rsa="/home/${_user}/.ssh/id_rsa"
sshkey_ecdsa="/home/${_user}/.ssh/id_ecdsa"
sshkey_ed25519="/home/${_user}/.ssh/id_ed25519"
package_category_dir="/home/${_user}/joetoo/sys-kernel"
github_ebuild_repo_credentials="/home/${_user}/joetoo/.git/.credentials"
host_dir="${build_root%/}/domU_kernel_images"
SSH_AUTH_SOCK="/home/${_user}/.ssh/ssh-agent.sock"
joetoo_kernel_webserver="raspi56403.brendler"

sources_dir="${build_root%/}/linux"
config_dir="${build_root%/}/kernelconfigs"
build_dir="${build_root%/}/build"
status_file="${build_dir%/}/status"
model_dir="${build_dir%/}/${model}"
model_config="${model_dir%/}/.config"
kernel_basename="linux-${model}_joetoo_kernelimage"
distrib_dir="${model_dir%/}/tmp/distrib"
lib_dir="${distrib_dir%/}/lib"
boot_dir="${distrib_dir%/}/boot"
module_dir="<TBD>"  # to be set after make modules_install

# create the build directory structure if it does not exist (-p makes parents)
[[ ! -d "${build_root}" ]]  && mkdir -pv -m 755 "${build_root}"  && chown "${_user}":"${_user}" "${build_root}"
[[ ! -d "${config_dir}" ]]  && mkdir -pv -m 755 "${config_dir}"  && chown "${_user}":"${_user}" "${config_dir}"
[[ ! -d "${build_dir}" ]]   && mkdir -pv -m 755 "${build_dir}"   && chown "${_user}":"${_user}" "${build_dir}"
[[ ! -d "${model_dir}" ]]   && mkdir -pv -m 755 "${model_dir}"   && chown "${_user}":"${_user}" "${model_dir}"

# create the staging directory structure if it does not exist
[[ ! -d "${distrib_dir}" ]] && mkdir -pv -m 755 "${distrib_dir}" && chown "${_user}":"${_user}" "${distrib_dir}"
[[ ! -d "${lib_dir}" ]]     && mkdir -pv -m 755 "${lib_dir}"     && chown "${_user}":"${_user}" "${lib_dir}"
[[ ! -d "${boot_dir}" ]]    && mkdir -pv -m 755 "${boot_dir}"    && chown "${_user}":"${_user}" "${boot_dir}"
[[ "${model}" == "domU" ]] && \
[[ ! -d "${host_dir}" ]]    && mkdir -pv -m 755 "${host_dir}"    && chown "${_user}":"${_user}" "${host_dir}"

# set up the parts of the make command
# NOTE: this does not set the environment variables directly, it creates a string that will do so when evaluated as (part of) a command
make_prefix="MAKEOPTS="
make_prefix+="\"${makeopts}\" "
make_prefix+=" FEATURES="
make_prefix+="\"${features}\""
make_prefix+=" KERNEL_DIR=\"${sources_dir}\""

make_arch="ARCH=${arch} CROSS_COMPILE=${cross_compile}"
make_where="KBUILD_OUTPUT=${model_dir%/}/"
## drop this ; cd to sources_dir (may confuse where to find .config)
#make_src="-C ${sources_dir}"

# set up the cross-building make command for sbcs or domU
#make_model+="make KBUILD_OUTPUT=${model_dir%/}/ ARCH=${arch} CROSS_COMPILE=${cross_compile} "
#make_model="${make_prefix} ${make_where} ${make_arch} make ${make_src}"
make_model="${make_prefix} ${make_where} ${make_arch} make"

# set up the host build command for manual use, assuming already in ${sources_dir}
manual_prefix="${make_prefix} ${make_where} ${make_arch}"

# used to pick one of (make_model or make0) above based on model selection
make_me="${make_model}"

# get and set kernel version number and image name
old_dir="$PWD"
# if this is the first-run for this model, sources_dir won't exist, so assign a placeholder for kernelversion
# after assigning/displaying config, sanity_check() will provide README-instructions
# instead of running command_sequence
if [[ ! -e "${sources_dir}" ]] ; then
    version_number="<TBD>"
else
    notice_msg "Old pwd: ${old_dir}" && cd "${sources_dir%/}" && notice_msg "Now working in $PWD"
    version_number=$(eval ${make_me} -s kernelversion)
    # domU using gentoo-sources, will get version line "X.Y.Z-gentoo"
    #   but for domU, I don't want the "-gentoo" part, so strip it
fi
# if this build is for a domU, then fix the version number
if [ "${model}" == "domU" ] ; then
    version_number="${version_number/-gentoo/}"
fi
# build the kernel_image_name
info_msg "version_number: ${version_number}"
kernel_image_name="${kernel_basename}-${version_number}"

# build pathnames for publish_tarball_cmd_file and publish_ebuild_cmd_file
#devel_dir="${my_devel_dir%/}"
ebuild_dir="${package_category_dir%/}/${kernel_basename}"
publish_tarball_cmd_file="${build_dir%/}/publish_tarball_${kernel_image_name}"
publish_ebuild_cmd_file="${build_dir%/}/publish_ebuild_${kernel_image_name}"

notice_msg "done setup and auto-configure"

  return $kc_ret
}


display_config()
{
    longest=$(get_longest ${varlist})


    notice_msg "${BMon}Current Configuration:${Boff}"
    display_vars ${longest} "config_dir"
    separator "$(hostname) $PN-$BUILD" "(joetoo header configuration)"
    display_vars ${longest} ${header_varlist}
    echo
    separator "$(hostname) $PN-$BUILD" "(from .conf and/or command line)"
    display_vars ${longest} ${config_parmlist}
    echo
    separator "$(hostname) $PN-$BUILD" "(Auto-configured)"
    display_vars ${longest} ${auto_parmlist}
    echo
    separator "$(hostname) $PN-$BUILD" "(output information)"
    display_vars ${longest} ${output_parmlist}
    echo
    separator "$(hostname) $PN-$BUILD" "(copy/paste information)"
    cplongest=$(get_longest ${copypaste_parmlist})
    display_vars ${cplongest} ${copypaste_parmlist}
    echo
    separator "$(hostname) $PN-$BUILD" "(manual build tips)"
    notice_msg "${Mon}If building manually${Boff} --"
    notice_msg "  ${Mon}first${Boff} cd ${sources_dir}"
    notice_msg "  ${Mon}then${Boff} copy/paste the make_me or manual_prefix variable assignment --"
    notice_msg "  ${Gon}manual_prefix='${manual_prefix}'${Boff}"
    echo
    notice_msg "  ${Gon}make_me='${make_me}'${Boff}"
    echo
    notice_msg "${Mon}then use e.g.${Boff} --"
    msg1='eval ${manual_prefix}'
    msg2="./scripts/kconfig/merge_config.sh .config ${Boff}<path-to-config-fragment>"
    notice_msg "${Gon}${msg1} ${msg2}${Boff}"
    notice_msg "or"
    msg2="make menuconfig${Boff}"
    notice_msg "${Gon}${msg1} ${msg2}${Boff}"
    echo
    msg1='eval ${make_me} olddefconfig'
    notice_msg "or"
    notice_msg "${Gon}${msg1}${Boff}"
    echo
    return 0
}



#-----[ main script ]----------------------------------------------------

app_configure || die "failed to app_configure"

# re-assign varlist variables appended at the top of the script and thus
# over-written by app_configure
kernelupdate_configure || die "failed to kernelupdate_configure"

d_do display_config "$debug"  # show config prior to processing cmdline only at info/debug verbosity
debug_msg "(BEFORE process_cmdline)"

process_cmdline "$@" || die "failed to process_cmdline"

display_config
info_msg "(AFTER process_cmdline)"

run_sequence "$status_file" "$starting_step" "$stopping_step"
result=$?
separator "$PN-$BUILD" "(Done)"
notice_msg_n "$PN complete. Results:"
handle_result $result "exemplary success" "exemplary failure"
exit $result
