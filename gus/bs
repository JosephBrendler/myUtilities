#!/bin/bash
# bs - implements simple binary search for target in list
bs()
{
  # return the index number of the entry in the list, or -1 if not found
  let "result=-1"
  search_list=$1
  target=$2
  start=$3
  end=$4
  let "depth+=1"
  if [[ $depth -gt ${#range[@]} ]]
  then
    d_message "Something is wrong here -- depth [$depth] exceeds range [${limit}]"
    return 1  # can't go deeper than the length of the list
  fi

  d_message " depth=[$depth]" 3
  d_message " start=[$start]" 3
  d_message "   end=[$end]" 3

  diff=$(( $end - $start ))
  middle=$(( $start + $(( $diff / 2 )) ))
  ## guarantee to look at both start and end before giving up
  if [[ ${diff} -eq 1 ]]; then let "middle+=$(( ${depth} % 2 ))"; else DIFF1UPPER=$FALSE; DIFF1LOWER=$FALSE; fi
  d_message "middle=[$middle]" 3
  d_message ">> [${range[middle]}] <<" 4
  if [[ "${range[middle]}" == "${target}" ]]
  then
    result=$middle   # equal
  else
    [[ $start -eq $end ]] && return 1
    if [[ "${range[middle]}" > "${target}" ]]
    then
      [[ $diff -eq 1 ]] && DIFF1UPPER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then d_message "both diff=1 cases examined. not found" 2; return 1; else d_message "DIFF1 flags not yet both true" 2; fi
      d_message "candidate [${range[middle]}] is GREATER than target [${target}], DIFF1UPPER is now [$(TrueFalse $DIFF1UPPER)] -- search lower half next" 3
      bs $search_list $target $start $middle
    else
      [[ $diff -eq 1 ]] && DIFF1LOWER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then d_message "both diff=1 cases examined. not found" 2; return 1; else d_message "DIFF1 flags not yet both true" 2; fi
      d_message "candidate [${range[middle]}] is LESS than target [${target}], DIFF1LOWER is now [$(TrueFalse $DIFF1LOWER)] -- search upper half next" 3
      bs $search_list $target $middle $end
    fi
  fi
  d_message "about to exit at depth [$depth], result is [$result]" 4
  return 0
}

#----[ main script - alphabetize the list, then search it ]---------------
source /usr/local/sbin/script_header_brendlefly
unfriendlies="/var/lib/portage/distcc_unfriendly"
nodistmergelist=()
candistmergelist=()
nodistcount=0
candistcount=0

if [[ ! -z $1 ]]
then
  if [[ $1 =~ [0-9] ]]
  then
     VERBOSE=$TRUE
     verbosity=$1
  else
    VERBOSE=$TRUE
    verbosity=1
  fi
else
  VERBOSE=$FALSE
  verbosity=0
fi

for package in $(eix -u#)
do
  let "depth=1"
  let "result=-1"
  range=($(cat $unfriendlies | sort -udb))
  limit=${#range[@]}
  d_message "${BYon}Looking for ${BWon}$package ${BYon}in ${BWon}$unfriendlies ${BYon}--${Boff}" 1
  d_message "  ${BYon}searching among ${BWon}${#range[@]} ${BYon}candidate entries...${Boff}" 1
  d_echo 2
  DIFF1UPPER=$FALSE
  DIFF1LOWER=$FALSE
  bs $range $package 0 ${#range[@]}
  d_message "just got back from binary search, result is $result" 2
  if [[ ${result} -gt 0 ]]
  then
    d_message "${BGon}Found ${range[result]} at line ${BWon}${result}${BGon} of ${unfriendlies}${Boff}" 1
    nodistmergelist[${nodistcount}]="${package}"
    let "nodistcount+=1"
  else
    dE_message "${BRon}Not found${Boff}" 1
    candistmergelist[${candistcount}]="${package}"
    let "candistcount+=1"
  fi
  d_message "(had to go to depth $depth to figure that out)" 2
done
d_echo
message "${BWon}These are the $nodistcount updateable packages on the nodistmergelist:${BRon}"
for ((i=0; i<${#nodistmergelist[@]}; i++)); do echo -e "   ${nodistmergelist[i]}"; done
echo
message "${BWon}These are the $candistcount updateable packages on the candistmergelist:${BGon}"
for ((i=0; i<${#candistmergelist[@]}; i++)); do echo -e "   ${candistmergelist[i]}"; done
echo -e ${Boff}
