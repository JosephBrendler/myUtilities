#!/bin/bash
# Standardized Gentoo Update Sequence (gus), implemented as interactive
#   script with "resume" functionality
# Author: Joe Brendler 9 March 2017; based on author's update-sequence script of 23 Jan 2011

# Source the variable assignments made in gus.conf (/etc/ overrides pwd)
#   This will supercede/modify the default assignments made below
CONF_DIR="defaults"
[[ -e gus.conf ]] && source gus.conf && CONF_DIR=$PWD"/gus.conf"
[[ -e /etc/gus/gus.conf ]] && source /etc/gus/gus.conf && CONF_DIR="/etc/gus/gus.conf"

# User-defined variables - modify according to your system
# SCRIPT_DIR is the directory in which you have placed
#   this script and the show-elogs script
[ -z "$SCRIPT_DIR" ] && SCRIPT_DIR="/usr/local/sbin/"    # must end with '/'

# STATUS_FILE is the name of the status file
#   generated and used by this script.  Provide the complete pathname
[ -z "$STATUS_FILE" ] && \
    STATUS_FILE="/root/bin/gus-status" || \
    STATUS_FILE=$STATUS_FILE

# EIX indicates whether you use app-portage/eix, which will significantly speed up parts of gus
[ -z "$EIX" ] && EIX="yes"

# DISTCC indicates whether you use sys-devel/distcc, which can significantly speed up compiling for gus
[ -z "$DISTCC" ] && DISTCC="yes"

# PUMP indicates whether you use cpp capable distcc hosts, and you want to pump emerge
[ "$DISTCC" == "yes" ] && [ -z "$PUMP" ] && PUMP="yes"

# unfriendlies is a file listing packages known to not be friendly to distcc
[ -z $unfriendlies ] && unfriendlies="/etc/gus/distcc_unfriendly"

# SYNC_TS is the pathname of the file the timestamp of which will
#   be checked to determine how long it's been since the portage
#   tree was last sync'd
[ -z "$SYNC_TS" ] && SYNC_TS="/usr/portage/metadata/timestamp.chk"       # emerge --sync timestamp

# SYNC_CMD is the command used to sync the portage tree
#[ -z "$SYNC_CMD" ] && SYNC_CMD="WEBRSYNC"       # emerge-webrsync
[ -z "$SYNC_CMD" ] && SYNC_CMD="SYNC"       # emerge --sync

# MAX_AGE is the maximum time in hours since last sync before this script
#   will automatically choose to emerge --sync
[ -z "$MAX_AGE" ] && MAX_AGE=24

# ELOG_DIR is the location of elog files
[ -z "$ELOG_DIR" ] && ELOG_DIR="/var/log/portage/elog/"

# SELINUX_RELABEL
[ -z "$SELINUX_RELABEL" ] && SELINUX_RELABEL="no"

# PERL_CLEANER
[ -z "$PERL_CLEANER" ] && PERL_CLEANER="no"

# HASKELL_UPDATER
[ -z "$HASKELL_UPDATER" ] && HASKELL_UPDATER="no"

# REGEN_OVERLAY_METADATA
[ -z "$REGEN_OVERLAY_METADATA" ] && REGEN_OVERLAY_METADATA="no"

# EIX_UPDATE
[ -z "$EIX_UPDATE" ] && EIX_UPDATE="no"

# PYTHON_UPDATER
[ -z "$PYTHON_UPDATER" ] && PYTHON_UPDATER="no"

# MODULE_REBUILD
[ -z "$MODULE_REBUILD" ] && MODULE_REBUILD="no"

# X11_MODULE_REBUILD
[ -z "$X11_MODULE_REBUILD" ] && X11_MODULE_REBUILD="no"

# RKHUNTER propupd
[ -z "$RKHUNTER" ] && RKHUNTER="no"

# --- source common functions and variables --------------------
source /usr/local/sbin/script_header_brendlefly

# --- Define local variables -----------------------------------
worldfile="/var/lib/portage/world"
VERBOSE=$FALSE
#VERBOSE=$TRUE
verbosity=0

BUILD="5.1.0 (20170309)"

phase=1
lastphase=5
continue="y"
RESUME="no"
SYNC="no"
EXCLUDE=""
# TODO: move these to .conf and set like those above
GO_AHEAD="no"
USEPKG="no"
USEPKGONLY="no"
GETBINPKG="no"
GETBINPKGONLY="no"
KEEPGOING="no"
WITH_BDEPS_Y="yes"

updateables=""
nodistmergelist=()
nodistworldlist=()
candistmergelist=()
candistworldlist=()
nodistcount=0
nodistworldcount=0
candistcount=0
candistworldcount=0

# Array of messages used to announce each phase
phase_message[1]="phase 1 - Sync and Emerge Updates"
phase_message[2]="phase 2 - Review news and Maintain Config Files"
phase_message[3]="phase 3 - Review elogs"
phase_message[4]="phase 4 - Handle Dependencies"
phase_message[5]="phase 5 - Final steps"
phase_message[6]="phase 6 - Update Sequence Complete.  Enter \"y\" to exit"


# --- function blocks ------------------------------------------


sanity_check()
{
# veryfy the sanity of the combination of arguments on the command line
[ "$SYNC" == "yes" ] && [ "$RESUME" == "yes" ] && \
   E_message "Nonsensical option combination: sync and resume" && \
   useage && exit 1

[ "$SYNC" == "yes" ] && [ "$GO_AHEAD" == "yes" ] && \
   E_message "Dangerous option combination: sync and go_ahead" && \
   E_message "(you should never merge packages blindly, please check first)" && \
   useage && exit 1

# if both remote/local and local-only are set local-only should over-ride
[ "$GETBINPKG" == "yes" ] && [ "$GETBINPKGONLY" == "yes" ] && GETBINPKG="no"
[ "$USEPKG" == "yes" ] && [ "$USEPKGONLY" == "yes" ] && USEPKG="no"
}

process_command_line()
{
# process command line arguments (for now only -x/--exclude option can have argument(s))
last=""
d_message "processing command line with argument(s): [ ${*} ]" 2
# shift each argument into position $1 and examine it
#   process the argument or processit with its own arguments
while [ ! -z "$1" ]
do
  d_message "arg1 = [ $1 ]" 3
  # if arg begins with a single dash, process it alone
  if [ "${1:0:1}" == "-" ] && [ "${1:1:1}" != "-" ]
  then
    d_message "processing [ $1 ] alone as single-dash argument" 3
    process_argument $1
    shift
  # if arg begins with a double dash, process it alone if it is not --exclude
  elif [ "${1:0:2}" == "--" ] && [ "$1" != "--exclude" ]
  then
    d_message "processing [ $1 ] alone as double-dash non-exclude argument" 3
    process_argument $1
    shift
  # if arg begins with a double dash, and it is --exclude,
  #   then process it with its own agruments (identified by no leading - or --)
  elif [ "${1:0:2}" == "--" ] && [ "$1" == "--exclude" ]
  then
    d_message "processing [ $1 ] as --exclude, with own args:" 3
    tmp_cmd=$1
    tmp_args=""
    shift
    while [ ! -z "$1" ]
    do
      if [ "${1:0:1}" != "-" ]
      then
        d_message "adding [ $1 ] to tmp_args:" 3
        # formulate this so as to preserve internal white space between multiple exclude atoms, but to not add extra whitespace
        [ -z "${tmp_args}" ] && tmp_args=${1} || tmp_args="${tmp_args} ${1}"
      else
        d_message "non-argument [ $1 ], exiting" 2
        exit
      fi
      shift
    done
    d_message "processing [ $tmp_cmd \"$tmp_args\" ]" 1
    process_argument $tmp_cmd "$tmp_args"
  else
    # bogus argument
    d_message "bogus argument [ $1 ]" 1
    E_message "${E_BAD_ARGS}" && useage && exit 1
  fi
done
sanity_check
}

process_argument()
{
EXCLUDE=""
d_message "about to process argument(s): [ $* ]" 1
d_message "1: [ $1 ], 2: [ $2 ]" 2
# process command line argument (must be one of the following)
[ ! -z "$1" ] && case "$1" in
    "-c" | "--check"         ) UPDATE_CHECK="yes" ;;
    "-e" | "--eix"           ) EIX_UPDATE="yes" ;;
    "-g" | "--getbinpkg"     ) GETBINPKG="yes" ;;
    "-G" | "--getbinpkgonly" ) GETBINPKGONLY="yes" ;;
    "-k" | "--usepkg"        ) USEPKG="yes" ;;
    "-K" | "--usepkgonly"    ) USEPKGONLY="yes" ;;
    "-m" | "--modules"       ) MODULE_REBUILD="yes" ;;
    "-p" | "--perl_cleaner"  ) PERL_CLEANER="yes" ;;
    "-P" | "--python"        ) PYTHON_UPDATER="yes" ;;
    "-r" | "--resume"        ) RESUME="yes" ;;
    "-R" | "--regen"         ) REGEN_OVERLAY_METADATA="yes" ;;
    "-s" | "--status"        ) status ; exit 0 ;;
    "-S" | "--selinux"       ) SELINUX_RELABEL="yes" ;;
    "-t" | "--rkhunter"      ) RKHUNTER="yes" ;;
    "-v" | "--verbose"       ) VERBOSE=$TRUE; let "verbosity+=1" ;;
    "-w" | "--with-bdeps=y"  ) WITH_BDEPS_Y="yes" ;;
    "-x" | "--exclude"       ) EXCLUDE="${2}" ;;
    "-X" | "--X11"           ) X11_MODULE_REBUILD="yes" ;;
    "-y" | "--sync"          ) SYNC="yes" ;;
    "-Y" | "--go-ahead"      ) GO_AHEAD="yes" ;;
    "-Z" | "--keep-going"    ) KEEPGOING="yes" ;;
    "-H" | "--haskell"       ) HASKELL_UPDATER="yes" ;;
    "-h" | "--help"          ) useage ; exit 0 ;;
    "-u" | "--update-all"    ) EIX_UPDATE="yes"; MODULE_REBUILD="yes"; PERL_CLEANER="yes"; \
                               PYTHON_UPDATER="yes"; REGEN_OVERLAY_METADATA="yes"; \
                               SELINUX_RELABEL="yes"; RKHUNTER="yes"; WITH_BDEPS_Y="yes"; \
                               X11_MODULE_REBUILD="yes"; SYNC="yes"; HASKELL_UPDATER="yes" ;;
    *                        ) process_compound_arg $1 ;;
esac
}

process_compound_arg()
{
# must begin with a single dash
[ ! "${1:0:1}" == "-" ] && E_message "${E_BAD_ARGS}" && useage && exit 1
# must not begin with two dashes (would have been picked in process_argument)
[ "${1:0:2}" == "--" ] && E_message "${E_BAD_ARGS}" && useage && exit 1
# strip leading dash(es)
myargs=${1##-}
# handle remaining characters in sequence
while [ -n "${myargs}" ]
do
    #handle first char
    case ${myargs:0:1} in
        "c") UPDATE_CHECK="yes" ;;
        "e") EIX_UPDATE="yes" ;;
        "g") GETBINPKG="yes" ;;
        "G") GETBINPKGONLY="yes" ;;
        "k") USEPKG="yes" ;;
        "K") USEPKGONLY="yes" ;;
        "m") MODULE_REBUILD="yes" ;;
        "p") PERL_CLEANER="yes" ;;
        "P") PYTHON_UPDATER="yes" ;;
        "r") RESUME="yes" ;;
        "R") REGEN_OVERLAY_METADATA="yes" ;;
        "S") SELINUX_RELABEL="yes" ;;
        "t") RKHUNTER="yes" ;;
        "v") VERBOSE=$TRUE; let "verbosity+=1" ;;
        "w") WITH_BDEPS_Y="yes" ;;
        "X") X11_MODULE_REBUILD="yes" ;;
        "Y") GO_AHEAD="yes" ;;
        "y") SYNC="yes" ;;
        "Z") KEEPGOING="yes" ;;
        "H") HASKELL_UPDATER="yes" ;;
        "u") EIX_UPDATE="yes"; MODULE_REBUILD="yes"; PERL_CLEANER="yes"; \
             PYTHON_UPDATER="yes"; REGEN_OVERLAY_METADATA="yes"; \
             SELINUX_RELABEL="yes"; RKHUNTER="yes"; WITH_BDEPS_Y="yes" \
             X11_MODULE_REBUILD="yes"; SYNC="yes"; HASKELL_UPDATER="yes" ;;
        *  ) E_message "${E_BAD_ARGS}" && useage && exit 1
esac
    #strip first char from myargs (i.e. "shift")
    myargs=${myargs:1}
done
}

useage()
{
   echo -e $BGon"Useage: gus [option]"$Boff
   echo -e " Command line options:"
   echo -e "   Options for ${phase_message[1]}"   ## phase 1 - Sync and Emerge Updates
   echo -e "    "$BBon"[-g | --getbinpkg]"$Boff"........use local and remote binary packages and ebuilds"
   echo -e "    "$BBon"[-G | --getbinpkgonly]"$Boff"....use local and remote binary packages only"
   echo -e "    "$BBon"[-k | --usepkg]"$Boff"...........use local binary packages and ebuilds"
   echo -e "    "$BBon"[-K | --usepkgonly]"$Boff".......use local binary packages only"
   echo -e "    "$BBon"[-w | --WITH_BDEPS_Y]"$Boff".....emerge with build-time dependencies"
   echo -e "    "$BBon"[-x | --exclude <atom>]"$Boff"...exclude <atom> from emerge"
   echo -e "    "$BBon"[-y | --sync]"$Boff".............force sync portage tree"
   echo -e "    "$BBon"[-Y | --go-ahead]"$Boff".........automatically continue to next phases"
   echo -e "    "$BBon"[-Z | --keep-going]"$Boff".......on emerge failure, try to keep emerging other packages"
#   echo -e "   Options for ${phase_message[2]}"   ## phase 2 - Review news and Maintain Config Files
#   echo -e "   Options for ${phase_message[3]}"   ## phase 3 - Review elogs
#   echo -e "   Options for ${phase_message[4]}"   ## phase 4 - Handle Dependencies
   echo -e "   Options for ${phase_message[5]}"   ## phase 5 - Final steps
   echo -e "    "$BBon"[-e | --eix]"$Boff"..............run eix-update"
   echo -e "    "$BBon"[-m | --modules]"$Boff"..........run emerge @module-rebuild"
   echo -e "    "$BBon"[-p | --perl_cleaner]"$Boff".....run perl-cleaner --all"
   echo -e "    "$BBon"[-P | --python]"$Boff"...........run python-updater"
   echo -e "    "$BBon"[-R | --regen]"$Boff"............regenerate portage tree metadata (including overlays) "
   echo -e "    "$BBon"[-S | --selinux]"$Boff"..........redo selinux lablels"
   echo -e "    "$BBon"[-t | --rkhunter]"$Boff".........run rkhunter --propupd"
   echo -e "    "$BBon"[-X | --X11]"$Boff"..............run emerge @x11-module-rebuild"
   echo -e "    "$BBon"[-H | --haskell]"$Boff"..........run haskell-updater"
   echo
   echo -e "    "$BBon"[-c | --check]"$Boff"............check for and list updateable installed packages"
   echo -e "    "$BBon"[-s | --status]"$Boff"...........print next phase in update sequence"
   echo -e "    "$BBon"[-r | --resume]"$Boff"...........resume update sequence at next phase"
   echo -e "    "$BBon"[-v | --verbose]"$Boff"..........increase verbosity"
   echo -e "    "$BBon"[-h | --help]"$Boff".............print this text"
   echo
   echo -e "  "$BYon"Notes: "$Boff
   echo -e "  "$BYon" 1)"$Boff" --status and --resume both identify the next phase"
   echo -e "    (which is the last successfully completed phase + 1)"
   echo -e "  "$BYon" 2)"$Boff" --sync is set automatically if portage tree is older"
   echo -e "    than MAX_AGE (set in gus.conf)"
   echo -e "  "$BYon" 3)"$Boff" option(s) -[k|K|g|G] function as explained in gentoo binary package guide:"
   echo -e "    https://wiki.gentoo.org/wiki/Binary_package_guide"
   echo
}

status()
{
    read phase < ${STATUS_FILE}
    echo "next phase: ${phase_message[${phase}]}"
    echo
}

display_config()
{
message "${BWon}Using configuration data below: ${Boff}"
echo -e ${LBon}"Configuration..........: "${Boff}${CONF_DIR}
echo -e ${LBon}"Unfriendlies...........: "${Boff}${unfriendlies}
echo -e ${LBon}"SCRIPT_DIR.............: "${Boff}${SCRIPT_DIR}
echo -e ${LBon}"STATUS_FILE............: "${Boff}${STATUS_FILE}
echo -e ${LBon}"SYNC_TS................: "${Boff}${SYNC_TS}
echo -e ${LBon}"MAX_AGE................: "${Boff}${MAX_AGE}
echo -e ${LBon}"DISTCC.................: "$(status_color ${DISTCC})${DISTCC}${Boff}
echo -e ${LBon}"PUMP...................: "$(status_color ${PUMP})${PUMP}${Boff}
echo -e ${LBon}"EIX....................: "$(status_color ${EIX})${EIX}${Boff}
echo -e ${LBon}"VERBOSE................: "$(status_color ${VERBOSE})$(TrueFalse ${VERBOSE})${Boff}
echo -e ${LBon}"verbosity..............: "${Boff}${verbosity}
echo -e ${BWon}"Options for ${phase_message[1]}${Boff}"   ## phase 1 - Sync and Emerge Updates
echo -e ${LBon}"USEPKG.................: "$(status_color ${USEPKG})${USEPKG}${Boff}
echo -e ${LBon}"USEPKGONLY.............: "$(status_color ${USEPKGONLY})${USEPKGONLY}${Boff}
echo -e ${LBon}"GETBINPKG..............: "$(status_color ${GETBINPKG})${GETBINPKG}${Boff}
echo -e ${LBon}"GETBINPKGONLY..........: "$(status_color ${GETBINPKGONLY})${GETBINPKGONLY}${Boff}
echo -e ${LBon}"WITH_BDEPS_Y...........: "$(status_color ${WITH_BDEPS_Y})${WITH_BDEPS_Y}${Boff}
echo -e ${LBon}"SYNC...................: "$(status_color ${SYNC})${SYNC}${Boff}
echo -e ${LBon}"SYNC_CMD...............: "${Boff}${SYNC_CMD}
echo -e ${LBon}"GO_AHEAD...............: "$(status_color ${GO_AHEAD})${GO_AHEAD}${Boff}
echo -e ${LBon}"KEEPGOING..............: "$(status_color ${KEEPGOING})${KEEPGOING}${Boff}
echo -e ${LBon}"EXCLUDE................: "${Boff}${EXCLUDE}
echo -e ${BWon}"Options for ${phase_message[5]}${Boff}"   ## phase 5 - Final steps
echo -e ${LBon}"EIX_UPDATE.............: "$(status_color ${EIX_UPDATE})${EIX_UPDATE}${Boff}
echo -e ${LBon}"HASKELL_UPDATER........: "$(status_color ${HASKELL_UPDATER})${HASKELL_UPDATER}${Boff}
echo -e ${LBon}"MODULE_REBUILD.........: "$(status_color ${MODULE_REBUILD})${MODULE_REBUILD}${Boff}
echo -e ${LBon}"PERL_CLEANER...........: "$(status_color ${PERL_CLEANER})${PERL_CLEANER}${Boff}
echo -e ${LBon}"PYTHON_UPDATER.........: "$(status_color ${PYTHON_UPDATER})${PYTHON_UPDATER}${Boff}
echo -e ${LBon}"RESUME.................: "$(status_color ${RESUME})${RESUME}${Boff}
echo -e ${LBon}"REGEN_OVERLAY_METADATA.: "$(status_color ${REGEN_OVERLAY_METADATA})${REGEN_OVERLAY_METADATA}${Boff}
echo -e ${LBon}"SELINUX_RELABEL........: "$(status_color ${SELINUX_RELABEL})${SELINUX_RELABEL}${Boff}
echo -e ${LBon}"RKHUNTER...............: "$(status_color ${RKHUNTER})${RKHUNTER}${Boff}
echo -e ${LBon}"X11_MODULE_REBUILD.....: "$(status_color ${X11_MODULE_REBUILD})${X11_MODULE_REBUILD}${Boff}
[[ ${VERBOSE} ]] && sh_countdown 7
}

check_timestamp()
{
    # compute age in hours of timestamp on file passed as argument
    # set $SYNC flag to "yes" if timestamp is older than $MAX_AGE allows
    SPM=60   # seconds per minute
    MPH=60   # minutes per hour
    agehours=$(( $(( $(date -u +%s) - $(date -u -r $1 +%s))) / $SPM / $MPH ))
    #if it's old, set SYNC flag
    message "Portage tree last sync'd $agehours hours ago"
    [ "$SYNC" == "yes" ] && \
        message "option: sync set by command line" || \
        message "option: sync not set by command line"
    if [ $agehours -gt $MAX_AGE ]
    then
        if [ "$GO_AHEAD" == "yes" ]
        then
            # sanity-check: unwise to go-ahead immediately after sync
            #  without checking what will be merged
            E_message "You selected option: go-ahead " && \
            E_message "but you also set MAX_AGE: $MAX_AGE hours in gus.conf" && \
            E_message "The latter would cause this program to sync and then auto-emerge non-interactively" && \
            E_message "(you should never merge packages blindly, please check first)" && \
            useage && exit 1
        else
            SYNC="yes" && \
            message "portage tree sync required by MAX_AGE ($MAX_AGE hours) set in gus.conf"
        fi
    else
        message "portage tree sync not required by MAX_AGE ($MAX_AGE hours) set in gus.conf"
    fi
}

emerge_sync()
{
    # check to see if portage tree is up to date
    # if timestamp of last emerge --sync is old, do a new one
    check_timestamp "$SYNC_TS"
    if [ "$SYNC" == "yes" ]
    then
        case ${SYNC_CMD} in
            "WEBRSYNC" ) message "Running emerge-webrsync... " && emerge-webrsync ;;
            "SYNC"     ) message "Running emerge --sync... " && emerge --sync ;;
            "EIX_SYNC" ) message "Running eix-sync..." && eix-sync ;;
            *          ) E_message "Error: invalid sync option [ $SYNC_CMD ]" ; return 1 ;;
        esac
    else
        message "Not running a sync for portage tree."
    fi
    return 0
}

intersect()
{
  # Generate an array containing as elements the records in filename $1
  #   that are also in input array ($@ after shift)
  #   Store the result in array ${output_yes_list[@]}
  # Also generate an array containing as elements the records in filename $1
  #   that are NOT also in input array ($@ after shift)
  #   Store the result in array ${output_no_list[@]}
  inputfilename="$1"; shift; remainder="$@"
  input_list=($(alpha_words ${remainder}))
  output_yes_list=();  output_yes_list_count=0
  output_no_list=();  output_no_list_count=0
  range=($(sort -udb $inputfilename))
  limit=${#range[@]}
  for item in ${input_list[@]}
  do
    let "depth=0";  let "result=-1";  DIFF1UPPER=$FALSE;  DIFF1LOWER=$FALSE
    d_message "${BYon}Looking for ${BWon}$item ${BYon}in ${BWon}$inputfilename ${BYon}--${Boff}" 1
    d_message "  ${BYon}searching among ${BWon}${#range[@]} ${BYon}candidate entries...${Boff}" 1
    d_echo 2
    bs $item 0 ${#range[@]} ${range[@]}
    d_message "just got back from binary search, result is $result" 2
    if [[ ${result} -gt 0 ]]
    then
      d_message "${BGon}Found ${range[result]} at line ${BWon}${result}${BGon} of ${inputfilename}${Boff}" 1
      output_yes_list[${output_yes_list_count}]="${item}"
      let "output_yes_list_count+=1"
    else
      d_message "${BRon}Did not find ${range[result]} in ${inputfilename}${Boff}" 1
      output_no_list[${output_no_list_count}]="${item}"
      let "output_no_list_count+=1"
      dE_message "${BRon}Not found${Boff}" 1
    fi
    d_message "(had to go to depth $depth to figure that out)" 2
  done

}

iff()
{
  ## identification of friends and foes (packages that like [or do not like] distcc, etc
  # the "foes" nodistmergelist that are in the worldfile will be used to first emerge these without distcc, etc
  # the other lists are presented for information only
  intersect $unfriendlies ${updateables[@]}
  nodistmergelist=(${output_yes_list[@]})    # "yes" because they were found in unfriendlies
  nodistcount=${#nodistmergelist[@]}
  candistmergelist=(${output_no_list[@]})    # "no" because they were not found in unfriendlies
  candistcount=${#candistmergelist[@]}

  intersect $worldfile ${candistmergelist[@]}
  candistworldlist=(${output_yes_list[@]})
  candistworldcount=${#candistworldlist[@]}

  intersect $worldfile ${nodistmergelist[@]}
  nodistworldlist=(${output_yes_list[@]})
  nodistworldcount=${#nodistworldlist[@]}

  d_echo
  message "${BWon}There are $nodistcount updateable packages on the ${BRon}nodistmergelist${BWon}:${BRon}"
  for ((i=0; i<${nodistcount}; i++)); do echo -e "   ${nodistmergelist[i]}"; done
  [ ${nodistcount} -gt 0 ] && message "${BWon}(This is just presented for your information)"
  echo
  message "${BWon}There are $nodistworldcount updateable packages on the ${BRon}nodistmergelist${BWon} and in ${BMon}$worldfile${BWon}:${BMon}"
  for ((i=0; i<${nodistworldcount}; i++)); do echo -e "   ${nodistworldlist[i]}"; done
  [ ${nodistworldcount} -gt 0 ] && message "${BWon}(These will be emerge without distcc)"
  echo
  message "${BWon}There are $candistcount updateable packages on the ${BGon}candistmergelist${BWon}:${BGon}"
  for ((i=0; i<${candistcount}; i++)); do echo -e "   ${candistmergelist[i]}"; done
  [ ${candistcount} -gt 0 ] && message "${BWon}(This is just presented for your information)"
  echo
  message "${BWon}There are $candistworldcount updateable packages on the ${BGon}candistmergelist${BWon} and in ${LBon}$worldfile${BWon}:${LBon}"
  for ((i=0; i<${candistworldcount}; i++)); do echo -e "   ${candistworldlist[i]}"; done
  [ ${candistworldcount} -gt 0 ] && message "${BWon}(Expect these to be then emerged with '[pump] emerge -uavDN world' unless masked)"
  echo -e ${Boff}
}

update_check()
{
  # if $DISTCC is FALSE
  #    then list installed packages that are updateable and the subset that are in the world file
  # if $DISTCC is TRUE
  #    then of the updateables, list separately the subset that are in the distcc_unfriendlies file
  #    and the subset that are not, then for each subset list separately those that are in the world file

  # first populate the updateables list (note, calling script has already run emerge_sync()
  if [ "$EIX" == "yes" ]
  then
    if [[ "$SYNC_CMD" != "EIX_SYNC" ]]
    then
      ### make sure the index is current
      d_message "${BMon}running eix-update to ensure index is up to date${Boff}" 1 ;
      eix-update ;
    else
      d_message "${BMon}eix-update not needed -- eix-sync should have already done it -- continuing...${Boff}" 1 ;
    fi
    d_message "EIX=[$EIX]; assiging updateables with \"eix -u\"" 1 ;
    updateables=($(eix -u#)) ;
  else
    d_message "EIX=[$EIX]; assigning updateables with \"emerge -puDN world | grep ...\" please wait..." 1 ;
    updateables=($(for x in $(emerge -puDN world | grep '\[ebuild' | cut -c18- | cut -d' ' -f1); do qatom -F %{CATEGORY}/%{PN} $x; done)) ;
  fi
  # now generate lists
  if [ "$DISTCC" == "yes" ]
  then
    iff
  else
    updateablecount=${#updateables[@]}
    intersect $worldfile ${updateables[@]}
    updateableworldlist=(${output_yes_list[@]})
    updateableworldcount=${#updateableworldlist[@]}

    message "${BWon}There are $updateablecount ${LBon}updateable installed${BWon} packages:${LBon}"
    for ((i=0; i<${updateablecount}; i++)); do echo -e "   ${updateables[i]}"; done
    [ ${updateablecount} -gt 0 ] && message "${BWon}(This is presented just for your information)"
    echo
    message "${BWon}There are $updateableworldcount ${LBon}updateable installed${BWon} packages in ${BGon}$worldfile${BWon}:${BGon}"
    for ((i=0; i<${updateableworldcount}; i++)); do echo -e "   ${updateableworldlist[i]}"; done
    [ ${updateableworldcount} -gt 0 ] && message "${BWon}(Expect these to be emerged with 'emerge -uavDN world' unless masked)"
    echo -e ${Boff}
  fi

}

emerge_updates()
{
    # assemble the emerge option string and message with baseline options (note --oneshot prevents gus
    #   from just adding all updateable packages to the world favorites file)
    OPTS1="uvDN"
    OPTS2=""
    MSG="emerging updates"
    if [ ! "${GO_AHEAD}" == "yes" ]
    then
        OPTS1="a"${OPTS1}
        MSG+=" interactively"
    else
        MSG+=" non-interactively"
    fi
    [ "${USEPKG}" == "yes" ] && OPTS1+="k"
    [ "${USEPKGONLY}" == "yes" ] && OPTS1+="K"
    [ "${GETBINPKG}" == "yes" ] && OPTS1+="g"
    [ "${GETBINPKGONLY}" == "yes" ] && OPTS1+="G"
    [ "${KEEPGOING}" == "yes" ] && OPTS2+=" --keep-going"
    [ "${WITH_BDEPS_Y}" == "yes" ] && OPTS2+=" --with-bdeps=y"

    # add --binpkg-respect-use=y universally (for now anyway)
    OPTS2+=" --binpkg-respect-use=y"

    # if we have an exclude, put it on the end of the command line
    [ ! -z "${EXCLUDE}" ] && OPTS2+=" --exclude ${EXCLUDE}"

    message "${MSG}"
    # first, emerge the packages that do not like distcc (if any need it)
    # then, emerge the packages that do like distcc (if any need it)
    if [[ "$DISTCC" == "yes" ]]
    then
      if [[ ! -z ${nodistworldlist[@]} ]]
      then
        MyCMD1='MAKEOPTS="-j2 -l2" ' && \
        MyCMD1+='FEATURES=" -userpriv -distcc -distcc-pump" ' && \
        MyCMD1+="emerge ${OPTS1} ${nodistworldlist[@]}${OPTS2}" && \
        message "${BWon}About to run - [ ${BRon}${MyCMD1}${BWon} ]${Boff}" && \
        eval ${MyCMD1} || return 1
      else
        message "no distcc-unfriendly updates to merge; continuing..."
      fi
      if [[ ! -z ${candistworldlist[@]} ]]
      then
        [[ "$PUMP" == "yes" ]] && MyCMD2='FEATURES="${FEATURES} distcc distcc-pump" ' || MyCMD2=""
        MyCMD2+="emerge -${OPTS1} @world${OPTS2}" && \
        message "${BWon}About to run - [ ${BRon}${MyCMD2}${BWon} ]${Boff}" && \
        eval ${MyCMD2} || return 1
      else
        message "no distcc-friendly updates to merge; continuing..."
      fi
    else   # DISTCC is "no"
      if [[ ! -z $updateables ]]
      then
        MyCMD2='FEATURES=" -userpriv -distcc -distcc-pump" ' && \
        MyCMD2="emerge -${OPTS1} @world${OPTS2}" && \
        message "${BWon}About to run - [ ${BRon}${MyCMD2}${BWon} ]${Boff}" && \
        eval ${MyCMD2} || return 1
      else
        message "no updates to merge; continuing..."
      fi
    fi
    return 0
}

show_news()
{
    # display any news...
    message "The following news has been generated:"
    eselect news read new
    echo
}

maintain_config_files()
{
    # run dispatch-conf to maintain configs, if this is necessary
    # if the optional go-ahead flag is set, skip this (remind user later)
    if $( [[ -z "$(find /etc/ -iname '*._cfg***')" ]] && \
       [[ -z "$(find /usr/share/config/ -iname '*._mrg***')" ]] )
    then
        message "No config files need maintenance."
    else
        if [ ! "$GO_AHEAD" == "yes" ]     # note: use of the GO_AHEAD option will cause this phase to be skipped
        then
            message "Launching dispatch-conf to maintain the following config files:"
            echo $(find /etc/ -iname '*._cfg***')
            dispatch-conf
        fi  # not go_ahead
    fi  # find/not-find
    echo
    return 0
}

showelogs()
{
    # run show-elogs script to apply important phases from emerge notes
    # if the optional go-ahead flag is set, skip this (remind user later)
    message "Running show-elogs -l | less ..." && [ "$GO_AHEAD" == "no" ] && ${SCRIPT_DIR}show-elogs -l | less && return 0 || return 1
}

handle_dependencies()
{
    echo && message "Running emerge -av --depclean ..." && emerge -av --depclean
    echo && message "Running emerge @preserved-rebuild ..." && emerge @preserved-rebuild
    echo && message "Running revdep-rebuild.sh -p ..." && revdep-rebuild.sh -p
    # recommend you run revdep-rebuild again if it had to
    #   emerge something to fix dependencies
    # TO DO: check if that is the case and ask this only if so
    [ "$GO_AHEAD" == "no" ] && \
    echo -en $BYon"would you like to run revdep-rebuild.sh again, for action? (y/n) "$Boff && \
    read rerun && echo || \
    rerun="y"
    case $rerun in
        "y") revdep-rebuild.sh ;;
        *) ;; # do nothing
    esac
    echo && message "Double-checking configuration files now ..." && maintain_config_files
    return 0
}

final_phases()
{
    # as indicated by option flags, perform additional phases
    [ "${REGEN_OVERLAY_METADATA}" == "yes" ] && message "Running emerge --regen ..." && emerge --regen
    [ "${EIX_UPDATE}" == "yes" ] && [ "${SYNC_CMD}" != "EIX_SYNC" ] &&message "Running eix-update ..." && eix-update
    [ "${PERL_CLEANER}" == "yes" ] && message "Running perl-cleaner --all ..." && perl-cleaner --all
    [ "${HASKELL_UPDATER}" == "yes" ] && message "Running haskell-updater ..." && haskell-updater
    [ "${PYTHON_UPDATER}" == "yes" ] && message "Running python-updater ..." && python-updater
    [ "${MODULE_REBUILD}" == "yes" ] && message "Running emerge @module-rebuild ..." && emerge @module-rebuild
    [ "${X11_MODULE_REBUILD}" == "yes" ] && message "Running emerge @x11-module-rebuild ..." && emerge @x11-module-rebuild
    [ "${SELINUX_RELABEL}" == "yes" ] && message "Running rlpkg -a -r ..." && rlpkg -a -r
    [ "${RKHUNTER}" == "yes" ] && message "Running rkhunter --propupd" && rkhunter --propupd

    # clean un-needed package and distribution files, run localepurge
    [ -d "/usr/portage/packages" ] && message "Running eclean-pkg ..." && eclean-pkg
    message "Running eclean-dist -d ..." && eclean-dist -d && \
    message "Running localepurge ..." && localepurge && \
    return 0
}

ask_continue()
{
    # prompt to determine if or how to continue
    # y = continue to next phase, n = stop now, g = go ahead through all remaining phases non-interactively
    continue="x"
    while [[ ! `echo ${continue:0:1} | sed 's/^[yngYNG]*//' | wc -c` -eq 1 ]]
    do
        echo -en $BGon"*"$Boff" continue to ${phase_message[${phase}]} (y), stop (n), or go ahead through (g)? [Y/n/g] :" && \
        read continue && echo
        # if the response is "g" then set the GO_AHEAD flag and continue; if null apply default (y)
        case ${continue:0:1} in
            "g" | "G" ) GO_AHEAD="yes" && continue="y" ;;
            ""        ) continue="y" ;;
            "y" | "Y" ) continue="y" ;;
        esac
    done
}

# --- start main script ---------------------------------------------------------

# display script kick-off separator
separator "Gentoo Update Sequence -- gus-${BUILD}"

# process command line to set and check sanity of option flags
process_command_line $*

# must be root
message "Checking root UID... "&& checkroot

# display config variables from gus.conf and option flags from command line
display_config

# if calling for an update check, then sync if necessary and list updateables
[ "$UPDATE_CHECK" == "yes" ] && emerge_sync && update_check && exit 0

# if resuming, retrieve number of next phase to be performed from status file
[ "$RESUME" == "yes" ] && read phase < $STATUS_FILE

# proceed thru each phase, as allowed to continue, until complete
while [ "$continue" == "y" ] && [ "$phase" -le "$lastphase" ]
do
    separator "${phase_message[$phase]}"
    case $phase in
        "1") emerge_sync ; update_check ;
             [[ $verbosity -gt 2 ]] && sh_countdown 7 ;
             emerge_updates && echo -e $BGon"OK"$Boff  ;;
        "2") show_news ;
             maintain_config_files && echo -e $BGon"OK"$Boff ;;
        "3") showelogs && echo -e $BGon"OK"$Boff ;;
        "4") handle_dependencies && echo -e $BGon"OK"$Boff ;;
        "5") final_phases && echo -e $BGon"OK"$Boff ;;
    esac
    message "Successfully completed: ${phase_message[${phase}]}"
    let "phase += 1"
    echo $phase > $STATUS_FILE
    # determine whether or how to proceed to next phase
    case $GO_AHEAD in
        "yes") continue="y" ;;
        "no")  ask_continue ;;
    esac
done

# if go-ahead flag was set, remind user
if [ "$GO_AHEAD" == "yes" ]
then
    message "You ran update sequence with option: go-ahead."
fi

# if go-ahead flag was set and new configs are pending, tell user
if [ "$GO_AHEAD" == "yes" ]
then
    if [[ ! -z "$(find /etc/ -iname '*._cfg***')" ]] || \
       [[ ! -z "$(find /usr/share/config/ -iname '*._mrg***')" ]]
    then
        E_message 'You have updated config files pending. You should run "dispatch-conf"'
        E_message "found the following pending config file updates:"
        echo $(find /etc/ -iname '*._cfg***')
    fi # found configs
fi  # go_ahead

# if go-ahead flag was set and new elogs resulted from updates, tell user
if [ "$GO_AHEAD" == "yes" ]
then
    for x in $(ls $ELOG_DIR | cut -d":" -f 3 | cut -d"-" -f 1 | sort -nu); do : ; done && \
    [ "$x" == "$(date -u +%Y%m%d)" ] && \
    E_message 'gus produced new elogs.  You should run "show-elogs"'
fi

echo && message "Don't forget rebuild modules if needed\n\temerge @[x11-]module-rebuild\n"

/usr/bin/logger -p cron.notice "gus complete at $(my_short_date)."
msg="Logged and done at: "$(date +"%T %Z, %d %B %Y.")
message "$msg"
exit 0
