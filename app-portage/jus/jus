#!/bin/bash
# Standardized Joetoo Update Sequence (jus), implemented as interactive
#   script with "resume" functionality
# Author: Joe Brendler 14 October 2020
#   20260212 - migrated to joetoo cli framework
# see version_history in ebuild's filesdir

# to do list:
# (1) sort out getbinpkg override of per-package env (don't want gentoo-kernel binpkg for example)
# (2) doesn't use run_sequence - has phase_seq arrays instead...

script_header_installed_dir="/usr/sbin"
header="${script_header_installed_dir%/}/script_header_joetoo"
echo "header: $header"
if [ -f "$header" ]; then . "$header"; else printf '%s' "failed to source header; cannot continue"; exit 1; fi
header2="${script_header_installed_dir%/}/script_header_joetoo_extended"
echo "header2: $header2"
if [ -f "$header2" ]; then . "$header2"; else printf '%s' "failed to source header2; cannot continue"; exit 1; fi
printf '%s' "Checking for header commands (toc, run_sequence) to confirm sourcing"
if command -v toc >/dev/null 2>&1 && command -v run_sequence >/dev/null 2>&1 ; then
handle_result $? ; else printf '%s\n' "Failed; header not sourced; cannot continue"; exit 1; fi
printf '%s' "Checking for headers commands (bs, isfloat_regex) to confirm sourcing"
if command -v bs >/dev/null 2>&1 && command -v isfloat_regex >/dev/null 2>&1 ; then
handle_result $? ; else printf '%s\n' "Failed; header2 not sourced; cannot continue"; exit 1; fi

# if /usr/share/config/ doesn't exist, fix that
notice_msg_n "looking for /usr/share/config"
[ -d /usr/share/config ]; result=$?
handle_result $result "found" "not found"
if [ ! "$result" -eq 0 ]; then
  notice_msg_n "making directory /usr/share/config/"
  mkdir -p /usr/share/config/
  handle_result $? "created" "" || die "failed to mkdir -p /usr/share/config/"
fi

#-----[ variables ]----------------------------------------------------

# NOTE: varlist variables are initialized by app_configure() and displayed by show_config();
# the basic set of varlist variables is defined in script_header_joetoo and can be extended
# either in the using script or in its .conf files.
# An example is provided in the joetoo_cli_example script and in the template joetoo_cli_example.conf
#
# BREAK tells display_vars to add a newline spacer in its output
# $LOCALIZED exemplifies use of the joetoo pseudo-boolean data type for POSIX scripts
# $EXAMPLE and $DEFAULTS are pseudo-booleans defined in joetoo_cli_example_local.cmdline_arg_handler
# $INITIALIZED_ME and $SOURCED_ME exemplify use of the joetoo yn data type
# Note how each is named and how these types are prefixed in the varlist, to inform initialize_vars
# and display_vars how to handle them.
# $longone is a long string defined in script_header_joetoo to test and illustrate smart wrapping
# by the smart_wrap_n() function. its name is prefixed "lv." in this localized extension of varlist
# to indicate (long variable), so display_vars will use smart_wrap_n() to display the content of
# $longone (which is long-one btw, not long-gone)
#
# CAVEAT: varlist is instantiated when script_header_joetoo is sourced (above), so it IS safe to add
# variable names to it in a "variables" section at the top of your main script, but note that
# the standard joetoo cli script layout calls app_configure() after that --
# so anything you add to varlist before app_configure will be over-written when app_configure
# calls initialize_var. which sets all bool. to $FALSE, all yn. to "no" and all others to ""
#
# Bottom line: you can append variable names to varlist at the top of your script, but if you do, you
# ALSO need to reassign them AFTER app_configure runs. Thus it is "easier" to just append
# variable names to varlist in the .conf file, which app_configure() loads AFTER it calls
# initialize_vars, but be sure to also assign them, b/c they will not be initialized otherwise
#LOCALIZED="$FALSE"; INITIALIZED_ME="no"
#varlist="${varlist} BREAK bool.LOCALIZED yn.INITIALIZED_ME"
# all jus varlist extension is in jus.conf

#-----[ functions ]----------------------------------------------------

initialize_command_sequence() # (POSIX) initialize command sequence for joetoo cli framework
{ ics_ret=0
  _ics_FLAGGED="$FALSE"
  info_msg_n "creating tempfile for command sequnce"
  cmd_seq_file=$(mktemp /tmp/${PN}.XXXXXX)
  info_handle_result $? "$cmd_seq_file" '' || _ics_FLAGGED="$TRUE"

  info_msg_n "setting trap to remove tempfile on EXIT"
  trap 'rm -f "$cmd_seq_file"' EXIT
  info_handle_result $? "trap set" ''  || _ics_FLAGGED="$TRUE"

  notice_msg_n "initializing command sequence"
  num_cmds=0   # global variable holding the length of the sequence
# heredoc needs to be on the left edge; no leading whitespace
# initialize/clear the command sequence file
# format for each line of heredoc content is:
#   command_string${US}description_string
#   where: command_string is POSIX executable
#   and:   ${US} is teletype era unit separator char \037 pre-cooked with printf
#   and:   description_string is a human-readable description of the command
while IFS= read -r _ics_entry; do
      [ -z "$_ics_entry" ] && continue
      # write directly to the file instead of using  ' set -- "$@" '
      printf '%s\n' "$_ics_entry" >> "$cmd_seq_file"
      num_cmds=$(( num_cmds + 1 ))
done <<EOF
emerge_sync${US}Sync
update_check${US}Update-Check
emerge_updates${US}Emerge Updates
show_news; maintain_config_files${US}Review news and Maintain Config Files
showelogs${US}Review elogs
handle_dependencies${US}Handle Dependencies
final_phases${US}Final steps
EOF
  handle_result $? "num_cmds: $num_cmds" '' || _ics_FLAGGED="$TRUE"

  info_msg_n "initailizing starting_step"
  starting_step=1
  info_handle_result $? "$starting_step" '' || _ics_FLAGGED="$TRUE"

  info_msg_n "initializing stopping step"
  stopping_step="$num_cmds"
  info_handle_result $? "$stopping_step" '' || _ics_FLAGGED="$TRUE"

  [ "$_ics_FLAGGED" ] && ics_ret=1
  export num_cmds
  export cmd_seq_file
  unset -v _ics_entry _ics_FLAGGED _ics_result
  return $ics_ret
}
# @usage initialize_command_sequence || die "failed to initialize_command_sequence"
# @vars sets global num_cmds, cmd_seq_file
# @vars initializes global starting_step=1, stopping_step=$num_cmds
# @rule creates a temporary file for command execution and sets an EXIT trap for cleanup
# @rule command sequency entry format 'command_string${US}description_string'
# @cont where: command_string is POSIX executable
# @cont and:   ${US} is teletype era unit separator char \037 pre-cooked with printf
# @cont and:   description_string is a human-readable description of the command
# @ret 0 on success; 1 on failure

initialize_jus_variables()
{ ijv_ret=0; _ijv_FLAGGED="$FALSE"
  # source make.conf b/c we can't grep for just parts for systems that set
  #    e.g. PORTDIR="${ROOT}var/db/repos/gentoo"
  for x in PORTDIR PKGDIR DISTDIR PORTAGE_LOGDIR; do
    notice_msg_n "sourcing make.conf in a subshell to set $x"
    eval "$x=$(source /etc/portage/make.conf; eval "printf '%s' \$$x")"
    # use bash indirect expansion ${!x} to get the value of the variable named by $x
    handle_result $? "${!x}" "" || _ijv_FLAGGED="$TRUE"
  done

  notice_msg_n "assigning ELOG_DIR"
  ELOG_DIR="${PORTAGE_LOGDIR:-/var/log/portage}/elog/"
  handle_result $? "$ELOG_DIR" "" || _ijv_FLAGGED="$TRUE"

  # Set these to defaults, override later with config file
  notice_msg_n "setting starting_step"
  starting_step=1; right_status $? || _ijv_FLAGGED="$TRUE"

  notice_msg_n "setting stopping_step"
  stopping_step="$num_cmds"; right_status $? || _ijv_FLAGGED="$TRUE"

  notice_msg_n "setting default NOBINFEATURES ..."
  # turn off getbinpkg userpriv and distcc --> override make.conf or package.env
  NOBINFEATURES='MAKEOPTS="-j1 -l1" FEATURES=" -getbinpkg -userpriv -distcc"'
  right_status $? || _ijv_FLAGGED="$TRUE"

  notice_msg_n "setting default yes/no variables ..."
  EIX="yes" && DISTCC="yes" && SELINUX_RELABEL="no" && PERL_CLEANER="no" && \
  HASKELL_UPDATER="no" && REGEN_OVERLAY_METADATA="yes" && EIX_UPDATE="no" && \
  NEWUSE="yes" && CHANGEDUSE="no" && \
  PYTHON_UPDATER="yes" && MODULE_REBUILD="no" && \
  X11_MODULE_REBUILD="no" && RKHUNTER="no" && GLSA_CHECK="yes" && EMAINT_CHECK="yes" && \
  continue="y" && RESUME="no" && SYNC="no" && EXCLUDE="" && UPDATE_CHECK="no" && GO_AHEAD="no" && \
  KEEPGOING="yes" && USEPKG="no" && USEPKGONLY="no" && GETBINPKG="no" && GETBINPKGONLY="no" && \
  WITH_BDEPS_Y="yes"
  right_status $? || _ijv_FLAGGED="$TRUE"

  notice_msg_n "setting default sync data ..."
  SYNC_TS="${PORTDIR:-var/db/repos/gentoo}/metadata/timestamp.chk" && \
  SYNC_CMD="EIX_SYNC" && MAX_AGE=24
  right_status $? || _ijv_FLAGGED="$TRUE"

  notice_msg_n "assigning world file"
  worldfile="/var/lib/portage/world"
  handle_result $? "$worldfile" "" || _ijv_FLAGGED="$TRUE"

  notice_msg_n "Setting defaults for non-displayed variables ..."
  KP_FOUND="$FALSE" && updateables=""
  right_status $? || _ijv_FLAGGED="$TRUE"

  [ "$_ijv_FLAGGED" ] && ijv_ret=1
  unset -v _ijv_FLAGGED
  return $ijv_ret
}

sanity_check()
{
# veryfy the sanity of the combination of arguments on the command line
if [ "$SYNC" == "yes" ] && [ "$RESUME" ]; then
   error_msg "Nonsensical option combination: sync and resume"
   useage
   die "correct options and try again"
fi

if [ "$SYNC" == "yes" ] && [ ! "$INTERACTIVE" ]; then
   error_msg "Dangerous option combination: SYNC and not INTERACTIVE"
   error_msg "(you should never merge packages blindly, please check first)"
   useage
   die "correct options and try again"
fi

# if both remote/local and local-only are set local-only should over-ride
[ "$GETBINPKG" == "yes" ] && [ "$GETBINPKGONLY" == "yes" ] && GETBINPKG="no"
[ "$USEPKG" == "yes" ] && [ "$USEPKGONLY" == "yes" ] && USEPKG="no"
}

display_config()
{
  notice_msg "${BWon}Using configuration data below: ${Boff}"
  # display standard joetoo varlist
  show_config
  # now package jus config data, by phase
  longest=$(get_longest ${conf_varlist} ${p0_varlist} ${p1_varlist} ${p2_varlist} ${p6_varlist})
  echo_e_msg "${BYon}Global Congiguration${Boff}"
  display_vars ${longest} ${conf_varlist}
  echo_e_msg "${BYon}Options for Phase 1 - ${phase_message[0]}${Boff}"   ## phase 1 - Sync
  display_vars ${longest} ${p0_varlist}
  echo_e_msg "${BYon}Options for Phase 2 - ${phase_message[1]}${Boff}"   ## phase 2 - Update Check
  display_vars ${longest} ${p1_varlist}
  echo_e_msg "${BYon}Options for Phase 3 - ${phase_message[2]}${Boff}"   ## phase 3 - Emerge Updates
  display_vars ${longest} ${p2_varlist}
  echo_e_msg "${BYon}Options for Phase 4 - ${phase_message[3]}${Boff}"   ## phase 4 - Review news and Maintain Configs
  echo_e_msg "${BYon}Options for Phase 5 - ${phase_message[4]}${Boff}"   ## phase 5 - Review elogs
  echo_e_msg "${BYon}Options for Phase 6 - ${phase_message[5]}${Boff}"   ## phase 6 - Handle Dependencies
  echo_e_msg "${BYon}Options for Phase 7 - ${phase_message[6]}${Boff}"   ## phase 7 - Final Steps
  display_vars ${longest} ${p6_varlist}
}


check_timestamp()
{
    # compute age in hours of timestamp on file passed as argument
    # set $SYNC flag to "yes" if timestamp is older than $MAX_AGE allows
    SPM=60   # seconds per minute
    MPH=60   # minutes per hour
    agehours=$(( $(( $(date -u +%s) - $(date -u -r $1 +%s))) / $SPM / $MPH ))
    #if it's old, set SYNC flag
    notice_msg "Portage tree last sync'd $agehours hours ago"
    [ "$SYNC" == "yes" ] && \
        notice_msg "option: sync set by command line" || \
        notice_msg "option: sync not set by command line"
    if [ "$agehours" -gt "$MAX_AGE" ]
    then
        if [ "$GO_AHEAD" == "yes" ]
        then
            # sanity-check: unwise to go-ahead immediately after sync
            #  without checking what will be merged
            error_msg "You selected option: go-ahead " && \
            error_msg "but you also set MAX_AGE: $MAX_AGE hours in jus.conf" && \
            error_msg "The latter would cause this program to sync and then auto-emerge non-interactively" && \
            error_msg "(you should never merge packages blindly, please check first)" && \
            useage && exit 1
        else
            SYNC="yes" && \
            notice_msg "portage tree sync required by MAX_AGE ($MAX_AGE hours) set in jus.conf"
        fi
    else
        notice_msg "portage tree sync not required by MAX_AGE ($MAX_AGE hours) set in jus.conf"
    fi
}


emerge_sync()
{
    # check to see if portage tree is up to date
    # if timestamp of last emerge --sync is old, do a new one
    check_timestamp "$SYNC_TS"
    if [ "$SYNC" == "yes" ]
    then
        fixpackages   # Perform package move updates for all packages
        case "${SYNC_CMD}" in
            "WEBRSYNC" ) notice_msg "Running emerge-webrsync... " && emerge-webrsync ;;
            "SYNC"     ) notice_msg "Running emerge --sync... " && emerge --sync ;;
            "EIX_SYNC" ) notice_msg "Running eix-sync..." && eix-sync ;;
            *          ) error_msg "Error: invalid sync option [ $SYNC_CMD ]" ; return 1 ;;
        esac
        [ "${REGEN_OVERLAY_METADATA}" == "yes" ] && notice_msg "Running emerge --regen ..." && emerge --regen
    else
        notice_msg "Not running a sync for portage tree."
    fi
    return 0
}

update_check()
{
  # Beginning with ver 6, just check for major upgrades in key packages
  # (linux-headers, glibc, binutils, libtool, gcc) and branch to full rebuild
#    'sys-devel/libtool'

  key_packages=(
    'sys-kernel/linux-headers'
    'sys-libs/glibc'
    'sys-devel/binutils'
    'sys-devel/gcc-config'
    'dev-build/libtool'
    'sys-devel/gcc'
    )
  KP_FOUND="${FALSE}"

  # first populate the updateables list (note, calling script has already run emerge_sync()
  if [ "$EIX" == "yes" ]
  then
    if [[ "$SYNC_CMD" != "EIX_SYNC" ]]
    then
      ### make sure the index is current
      notice_msg "${BMon}running eix-update to ensure index is up to date${Boff}"
      eix-update
    else
      notice_msg "${BMon}eix-update not needed -- eix-sync should have already done it -- continuing...${Boff}"
    fi
    info_msg "EIX=[$EIX]; assiging updateables with \"eix -u\""
    updateables=($(eix -u#))
  else
    info_msg "EIX=[$EIX]; assigning updateables with \"emerge -puDN world | grep ...\" please wait..."
    updateables=($(for x in $(emerge -puDN world | grep '\[ebuild' | cut -c18- | cut -d' ' -f1); do qatom -F %{CATEGORY}/%{PN} $x; done))
  fi

  # now determine if any key packages are in the updatables list
  updateablecount=${#updateables[@]}
  notice_msg "${BWon}There are $updateablecount ${LBon}updateable installed${BWon} packages:${Boff}"
  for ((i=0; i<${updateablecount}; i++))
  do
    pkg_color="${BGon}"
    # determine if this is a key package using bs() tool in script_header_joetoo_extended
    # note: bs() is "noisy" so quiet it down here
    if [ "$verbosity" -lt "$debug" ] && [ ! "$DEBUG" ]; then
      # do it in a subshell to isolate verbosity setting VERBOSE is for bs legacy code
      ( depth=0; VERBOSE="$FALSE" verbosity=0 bs "${updateables[i]}" 0 "${#key_packages[@]}" "${key_packages[@]}" )
    else
echo "looking for bs"
command -v bs
ls -al /usr/sbin/script_header_joetoo_extended
      ( depth=0; VERBOSE="$TRUE" verbosity=7 bs "${updateables[i]}" 0 "${#key_packages[@]}" "${key_packages[@]}" )
    fi
    if [[ "${result}" -gt 0 ]] ; then KP_FOUND="${TRUE}" ; pkg_color="${BRon}"; fi
    echo_e_msg_n "   "; notice_msg "${i}: ${pkg_color}${updateables[i]}${Boff} result: [${Mon}$result${Boff}]"
    if [[ "${result}" -gt 0 ]] ; then echo_msg_n "       " ; eix -uc "${updateables[i]}" ; fi
  done
  if [[ "${KP_FOUND}" ]]
  then
    echo_msg ""

    update_message="${BRon}  **  ${BYon}There is a key package to update\n" \
    update_message+="  --> ${BRon}if this is a major version upgrade, ${BWon}exit ${BRon}and run a ${BWon}rebuild ${BRon}sequence ${BYon}(rus)${Boff}\n" \
    update_message+="  --> ${BMon}if binary package server is updated, ${BWon}rebuild toolchain${BMon} and then run ${BGon}emerge -avbgke world --keep-going${Boff}"
  else
    update_message="${BGon}  **  ${BYon}There are no key pakages to update\n" \
    update_message+="  --> ${BGon}ok to continue update sequence${Boff}"
  fi
  notice_msg "${update_message}"
  notice_msg "done with update_check. returning with answer = [ $answer ]"
  return 0
}

emerge_updates()
{
    # assemble the emerge option string and message with baseline options (note --oneshot prevents jus
    #   from just adding all updateable packages to the world favorites file)
    OPTS1="uvD"
    OPTS2=""
    MSG="emerging updates"
    if [ ! "${GO_AHEAD}" == "yes" ]
    then
        OPTS1="a${OPTS1}"
        MSG+=" interactively"
    else
        MSG+=" non-interactively"
    fi
    [ "${NEWUSE}" == "yes" ] && OPTS1+="N"
    [ "${CHANGEDUSE}" == "yes" ] && OPTS1+="U"
    [ "${USEPKG}" == "yes" ] && OPTS1+="k"
    [ "${USEPKGONLY}" == "yes" ] && OPTS1+="K"
    [ "${GETBINPKG}" == "yes" ] && OPTS1+="g"
    [ "${GETBINPKGONLY}" == "yes" ] && OPTS1+="G"
    [ "${KEEPGOING}" == "yes" ] && OPTS2+=" --keep-going"
    [ "${WITH_BDEPS_Y}" == "yes" ] && OPTS2+=" --with-bdeps=y"

    # add --binpkg-respect-use=y and --binpkg-changed-deps=y universally (for now anyway)
    OPTS2+=" --binpkg-respect-use=y --binpkg-changed-deps=y"

    # if verbose, use --verbose-conflicts
    [ "$verbosity" -ge "$notice" ] && OPTS2+=" --verbose-conflicts"

    # if we have an exclude, put it on the end of the command line
    [ ! -z "${EXCLUDE}" ] && OPTS2+=" --exclude ${EXCLUDE}"

    notice_msg "${MSG}"
    # turn on distcc feature, but don't override setting in make.conf or package.env
    if [[ "$DISTCC" == "yes" ]]; then
        MyCMD='FEATURES="distcc ${FEATURES}" '
    else
        MyCMD=""
    fi
    MyCMD+="emerge -${OPTS1} @world${OPTS2}" && \
    notice_msg "${BWon}About to run - [ ${BRon}${MyCMD}${BWon} ]${Boff}" && \
    eval "${MyCMD}" || return 1
    return 0
}

show_news()
{
    # display any news...
    notice_msg "The following news has been generated:"
    eselect news read new
    echo_msg ""
}

maintain_config_files()
{
    # run dispatch-conf to maintain configs, if this is necessary
    # if the optional go-ahead flag is set, skip this (remind user later)
    if $( [[ -z "$(find /etc/ -iname '*._cfg***')" ]] && \
       [[ -z "$(find /usr/share/config/ -iname '*._mrg***')" ]] )
    then
        notice_msg "No config files need maintenance."
    else
        if [ "$INTERACTIVE" ]     # note: use of the --noninteractive option will cause this phase to be skipped
        then
            notice_msg "Launching dispatch-conf to maintain the following config files:"
            echo_msg $(find /etc/ -iname '*._cfg***')
            dispatch-conf
        fi  # not go_ahead
    fi  # find/not-find
    echo_msg ""
    return 0
}

showelogs()
{
    # run show-elogs script to apply important phases from emerge notes
    # if the optional go-ahead flag is set, skip this (remind user later)
    notice_msg "Running show-elogs -l | less ..." && [ "$GO_AHEAD" == "no" ] && show-elogs -l | less && return 0 || return 1
}

handle_dependencies()
{
    notice_msg "\nRunning emerge -av --depclean ..." && emerge -av --depclean
    notice_msg "\nRunning emerge @preserved-rebuild ..." && eval "${NOBINFEATURES} emerge @preserved-rebuild"
    notice_msg "\nRunning revdep-rebuild -p ..." && eval "${NOBINFEATURES} revdep-rebuild -p"
    # recommend you run revdep-rebuild again if it had to
    #   emerge something to fix dependencies
    # TO DO: check if that is the case and ask this only if so
    if [ "$INTERACTIVE" ] ; then
        echo_e_msg_n "${BYon}would you like to run revdep-rebuild again, for action? (y/n) ${Boff}"
        read rerun && echo_msg ""
    else
        rerun="y"
    fi
    case "$rerun" in
        "y") eval "${NOBINFEATURES} revdep-rebuild" ;;
        *) ;; # do nothing
    esac
    notice_msg "\nDouble-checking configuration files now ..."
    maintain_config_files
    return 0
}

final_phases()
{
    # as indicated by option flags, perform additional phases
    if [ "${EIX_UPDATE}" == "yes" ] && [ "${SYNC_CMD}" != "EIX_SYNC" ] ; then
        notice_msg "Running eix-update ..."
        eix-update
    fi

    if [ "${PERL_CLEANER}" == "yes" ]; then
        notice_msg "Running ${BGon}perl-cleaner --all${Boff} ..."
        eval "${NOBINFEATURES} perl-cleaner --all"
    fi

    if [ "${HASKELL_UPDATER}" == "yes" ]; then
        notice_msg "Running ${BGon}haskell-updater${Boff} ..."
        eval "${NOBINFEATURES} haskell-updater"
    fi

    if [ "${PYTHON_UPDATER}" == "yes" ]; then
        notice_msg "Running ${BGon}eselect python update${Boff} ..."
        eselect python update
        eselect python cleanup
    fi

    if [ "${MODULE_REBUILD}" == "yes" ]; then
        notice_msg "Running ${BGon}emerge @module-rebuild${Boff} ..."
        eval "${NOBINFEATURES} emerge @module-rebuild"
    fi

    if [ "${X11_MODULE_REBUILD}" == "yes" ]; then
        notice_msg "Running ${BGon}emerge @x11-module-rebuild${Boff} ..."
        eval "${NOBINFEATURES} emerge @x11-module-rebuild"
    fi

    if [ "${SELINUX_RELABEL}" == "yes" ]; then
        notice_msg "Running ${BGon}rlpkg -a -r${Boff} ..."
        rlpkg -a -r
    fi

    if [ "${RKHUNTER}" == "yes" ]; then
        notice_msg "Running ${BGon}rkhunter --propupd${Boff} ..."
        rkhunter --propupd
    fi

    if [ "${GLSA_CHECK}" == "yes" ]; then
        notice_msg "Running ${BGon}glsa-check -vp affected${Boff} ..."
        glsa-check -vp affected
    fi

    if [ "${EMAINT_CHECK}" == "yes" ]; then
        notice_msg "Running ${BGon}emaint --check all${Boff} ..."
        emaint --check all
    fi

    # clean un-needed package and distribution files, run localepurge
    if [ -d "${PKGDIR}" ]; then
        notice_msg "Running ${BGon}eclean-pkg${Boff} ..."
        eclean-pkg
    fi
    notice_msg "Running ${BGon}eclean-dist -d${Boff} ..."
    eclean-dist -d
    notice_msg "Running ${BGon}hash -r${Boff} for current shell ..."
    hash -r
    notice_msg "Running ${BGon}source /etc/profile${Boff} for current shell..."
    . /etc/profile
    return 0
}

wrapup_reminders()
{ # if not INTERACTIVE, remind user and check for new configs and elogs
  if [ ! "$INTERACTIVE" ]; then
    # remind user
    notice_msg "You ran update sequence with option flag: --noninteractive"
    # check for new config files
    if [[ ! -z "$(find /etc/ -iname '*._cfg***')" ]] || \
       [[ ! -z "$(find /usr/share/config/ -iname '*._mrg***')" ]]
    then
        notice_msg 'You have updated config files pending. You should run "dispatch-conf"'
        notice_msg "Found the following pending config file updates:"
        find /etc/ -iname '*._cfg***' | sed 's|^|    |'
    fi # found new configs
    # check for elogs generated today - start by identifying the most recent
    find_cmd='find "$ELOG_DIR" -maxdepth 1 -type f '       # files in $ELOG_DIR, no subdirectories
    find_cmd+='-printf "%T@ %p\n" | '                      # prepend timestamp
    find_cmd+='sort -n | tail -n 1 | '                     # sort numeric, keep only the last (latest)
    find_cmd+='cut -d" " -f2-'                             # drop the timestamp
    x=$(eval "$find_cmd")                                       # x is the full path name of the most recent file
    x_date=$(stat "$x" | grep "Modify" | awk '{print $2}') # used stat to get the modification date
    y_date=$(date -u +%Y-%m-%d)                            # e.g. 2026-02-12
    z_date=$(date -u +%Y%m%d)                              # e.g. 20260212

    # if the lates file has a modification date of today, consider it new and recommend reviewing elogs
    if [ "$x_date" == "$y_date" ] ; then
        notice_msg "there are new elogs for today ($z_date).  Recommend you run \"echo $z_date | show-elogs | less\""
    fi  # new elogs?
  fi  # go_ahead
  echo && notice_msg "Don't forget rebuild modules if needed\n\temerge @[x11-]module-rebuild\n"
}
#-----[ main script ]----------------------------------------------------

app_configure || die "failed to app_configure"

# re-assign varlist variables appended at the top of the script and thus
# over-written by app_configure
#info_msg_n "(re)assigning LOCALIZED"
#LOCALIZED="$TRUE"
#info_handle_result $? "$(TrueFalse $LOCALIZED)" "failed to reassign LOCALIZED"
#info_msg_n "(re)assigning INITIALIZED_ME"
#INITIALIZED_ME="yes"
#info_handle_result $? "$INITIALIZED_ME" "failed to reassign INITIALIZED_ME" "$notice"

info_msg_n "main script checking to verify handle_local_arg was loaded"
command -v handle_local_arg >/dev/null 2>&1
info_handle_result $?

initialize_jus_variables || die "failed to initialize_jus_variables"

#d_do show_config "$info"  # show config prior to processing cmdline only at info/debug verbosity
d_do display_config "$info"  # show config prior to processing cmdline only at info/debug verbosity
info_msg "(BEFORE process_cmdline)"

process_cmdline "$@" || die "failed to process_cmdline"

#show_config
display_config
info_msg "(AFTER process_cmdline)"

debug_msg "status_file: $status_file"
debug_msg "starting_step: $starting_step"
debug_msg "stopping_step: $stopping_step"

run_sequence "$status_file" "$starting_step" "$stopping_step"; result=$?
notice_msg_n "$PN run_sequence complete. Results:"
handle_result $result "" ""
separator "$PN-$BUILD" "(wrap-up)"
wrapup_reminders
separator "$PN-$BUILD" "(Done)"

exit $result
