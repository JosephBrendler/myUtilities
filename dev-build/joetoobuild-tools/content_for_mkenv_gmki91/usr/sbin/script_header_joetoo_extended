#!/bin/bash
#   script header with basic functions
# Author: joe brendler 26 Jan 2017
#         24 June 2025 - v1.0.0 moved to /usr/sbin/ and renamed/consolidated script_header_joetoo_extended
#
# NOTE: to use this header, you must first source the basic script_header_joetoo
#

# note: this header expects this to be assigned already
#script_header_installed_dir=/usr/sbin

validate_status_file()  # validate or create command sequence status file $1 
{
    [ $# -ne 1 ] && E_message "Error: must specify status_file" && return 1
    cmdseq_statusfile=$1
    d_message "cmdseq_statusfile: [ ${cmdseq_statusfile} ]" 3
    status_dir=$(dirname ${cmdseq_statusfile})
    d_message "status_dir: [ ${status_dir} ]" 3
    message_n "validating status_dir [${status_dir}] ..."
    if [ ! -d ${status_dir} ] ; then
        echo -en " (creating) ..."
        mkdir -p ${status_dir} && right_status $? || ( right_status $? && return 1 )
    else
        echo -en " (valid)" ; right_status $TRUE
    fi
    message_n "validating cmdseq_statusfile [${cmdseq_statusfile}] ..."
    if [ ! -f ${cmdseq_statusfile} ] ; then
        echo -en " (creating) ..."
#        touch ${cmdseq_statusfile} && right_status $? || ( right_status $? && return 1 )
        echo "0" > ${cmdseq_statusfile} && right_status $? || ( right_status $? && return 1 )
    else
        echo -en " (valid)" ; right_status $TRUE
    fi
    # final validation
    message_n "re-verifying cmdseq_statusfile [${cmdseq_statusfile}] ..."
    [ -f ${cmdseq_statusfile} ] && result=$TRUE || result=1
    right_status $result
    return $result
}

linear_search()        # find $2 in array $1, return index
{
    # pass arguments like this usage: # linear_search 'cb-setup ${BOARD}' "${command_sequence[@]}"
    needle="$1" ; shift ; haystack=("$@") ;
#    echo "needle: ${needle}" ; echo "haystack length: ${#haystack[@]}"
    for ((i=0; i<${#haystack[@]}; i++ )) ; do
        [[ "${haystack[$i]}" == "${needle}" ]] && echo $i && return $i
    done
}

usage()                # explain default usage; mod with local "usage module"
{
  N=$(( ${#command_sequence[@]} -1 ))
  separator "${PN}-${BUILD}" "(usage)"
  E_message "${BRon}Usage: ${BGon}${PN} [-[options]] ${Boff}"
  message "${BYon}valid commandline options --${Boff}"
  message "  -i | --interactive......: run supervised; confirm execution of each step"
  message "  -n | --noninteractive...: run un-supervised; automatically do each step"
  message "  -s | --status....: return status (next step, step_number)"
  message "  -r | --resume....: resume at next step in statusfile"
  message "  -v | --verbose...: increase verbosity"
  message "  -q | --quiet.....: decrease verbosity"
  message "  -[0-${N}]..........: save N to status file and resume at step N"
  message "  ${BYon}*${Boff} Single-character options may be combined."
  message "    e.g. ${BGon}${PN} --verbose -nqr8${Boff} would resume non-interactively"
  message "    (automatic, unsupervised) at step 8 with normal verbosity"
  message "${BMon}Caveat:${Boff}"
  message "   -i (interactive/supervised) is on by default"
  message "   -r (resume) sets starting_step to # in [ $cmdseq_statusfile ]"
  message "   -[0-${N}] sets starting_step (default 0 otherwise)"
  # source user-script specific usage-module which should be built in the same format
  message "${BMon}additional ${BPN} - commandline options:${Boff}"
  [ -f /etc/${BPN}/local.usage ] && source /etc/${BPN}/local.usage
  echo
  message "${BYon}${PN} workflow sequence (steps):${Boff}"
  for ((s=0; s<${#msg1_sequence[@]}; s++))
  do
    echo -e "    ${LBon}${s}: ${msg1_sequence[$s]}${Boff}"
  done
  E_message "exiting process [$$]" && exit 1
}

display_configuration() # use get_longest and display_vars to display ${varlist}
{
    # will pick up PN, BUILD, varlist from the environment of whatever script
    # sources script_header_joetoo_extended
    separator "${PN}-${BUILD}" "(configuration)"
    longest=$(get_longest ${varlist})
    display_vars ${longest} ${varlist}
    return 0
}

run_sequence()         # run start to stop steps in ${command_sequeyce[@]} and output status to $1
{
    # run the sequence of commands stored in the command_sequence array
    # for each step, store updated status in a status file provided as arg $1
    [ $# -ne 1 ] && E_message "run_sequence requires exactly one argument (cmdseq_statusfile) " && E_message "exiting process [$$]" && exit 1
    cmdseq_statusfile=$1 ; echo ; separator "${PN}-${BUILD}" "(running command sequence)" ; echo
    d_message "starting_step: [ ${starting_step} ]" 3
    d_message "stopping_step: [ ${stopping_step} ]" 3
    for ((step=${starting_step}; step<=${stopping_step}; step++))
    do
        separator "${PN}-${BUILD}" "(${step}: ${command_sequence[${step}]})"
        d_message "Writing step [ $step ] to cmdseq_statusfile ( $cmdseq_statusfile )" 2
        echo $step > ${cmdseq_statusfile}
        if [[ ${INTERACTIVE} ]] ; then
            msg="INTERACTIVE: $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff}"
            msg+=" ; will prompt to ${step}: (${msg1_sequence[${step}]})"
            d_message "${msg}" 2
            response=""
            # confirm user is ready/wants to run the next command
            new_prompt "${BMon}Are you ready to ${BGon}${msg1_sequence[${step}]}${BMon}?${Boff}"
        else  # automatically execute other steps for non-interactive
            msg="INTERACTIVE: $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff}"
            msg+=" ; will automatically ${step}: (${msg1_sequence[${step}]})"
            d_message "${msg}" 2
            message "${BMon}Beginning ${BGon}${command_sequence[${step}]}${BMon} as instructed ...${Boff}"
            response="y"
       fi  ## interactive
       case $response in
           [Yy] )  # execute this command and continue
               d_message "${LBon}About to run ${BYon}${command_sequence[${step}]}${LBon} ...${Boff}" 1 ; \
               eval ${command_sequence[${step}]} ; result=$?
               if [ $result -eq 0 ] ; then
                   d_message "${BYon}Note:${Boff} ${command_sequence[${step}]} ${BGon}completed successfully${Boff}" 1
               else
                   die "Failed to ${msg1_sequence[${step}]} [${command_sequence[${step}]}]"
               fi
               ;;
           [Ss] )
               d_message "${BYon}As requested, skipping ${Boff} ${msg1_sequence[${step}]} ${BGon}${command_sequence[${step}]}${Boff}" 1
               ;;
           *    )  # abort due to negative response
               d_message "${BRon}As instructed, not running ${BGon}${command_sequence[${step}]}${BRon}. Quitting...${Boff}" 1 ; \
               E_message "exiting process [$$]" && exit ;;
        esac
    done
    echo
}

process_cmdline()      # process command line arguments
{
  arglist="$@"

  last=""
  d_message "processing command line with [ ${arglist} ]" 2
  d_message "my PID: $$" 5
  # shift each argument into position $1 and examine it
  #   process the argument or processit with its own arguments
  while [ ! -z "$1" ]
  do
    d_message "arg1 = [ $1 ]" 3
    # if arg begins with a single dash, process it alone
    if [ "${1:0:1}" == "-" ] && [ "${1:1:1}" != "-" ] ; then
      d_message "processing [ $1 ] alone as single-dash argument" 3
      process_argument $1 $2   # incl $2 in case $1 uses an operand
      result=$?
####      [[ "${1}" =~ ^(-t|-b|-o)$ ]] && shift  # extra shift to clear target, board, or outputdevice
      [[ "${result}" -eq 6 ]] && shift  # extra shift to clear operand
      shift  # normal shift to next argument
    # if arg begins with a double dash, process it alone
    elif [ "${1:0:2}" == "--" ] ; then
      d_message "processing [ $1 ] alone as double-dash argument" 3
      process_argument $1 $2   # incl $2 in case $1 uses an operand
      result=$?
####      [[ "$1" == "--target" ]] && shift  # extra shift to clear target
      [[ "${result}" -eq 6 ]] && shift  # extra shift to clear operand
      shift  # normal shift to next argument
    else
      d_message "does not start with - or --" 3
      usage; E_message "exiting process [$$]" && exit
    fi
  done
  d_message "done with process_command_line" 2
  return 0
}

process_argument()     # process one argument (considering the next a potential operand)
{
  # return 0 if success and processed no operand
  # return 6 if success and processed an operand $2
  # return 1 if error
  d_message "about to process [ $* ]" 2
  d_message "1: [ $1 ], 2: [ $2 ]" 2
  d_message "my PID: $$" 5
  # process command line argument (must be one of the following)
  [ ! -z "$1" ] && case "$1" in
    "-"[sS] | "--status"         )
      # display status
      d_message "${BYon}reading status file: [ ${BWon}${cmdseq_statusfile}${BYon}  ]${Boff}" 2
      read starting_step < ${cmdseq_statusfile};
      result=$?
      if [ $starting_step -eq 0 ] ; then
          msg="${BWon}Status: $starting_step ;"
      else
          msg="${BWon}Status: Step $(($starting_step - 1)) complete ;"
      fi
      msg+=" next step would be [ ${BMon}$starting_step${BWon} ]"
      msg+=" --[ ${BGon}${command_sequence[${starting_step}]}${BWon} ]${Boff}"
      message "${msg}"
      E_message "exiting process [$$]" && exit;
      ;;
    "-"[rR] | "--resume"         )
      # resume at stored step unless that is overridden by a new start # (below)
      d_message "${BYon}reading status file: [ ${BWon}${cmdseq_statusfile}${BYon}  ]${Boff}" 2
      export RESUME=${TRUE}
      read starting_step < ${cmdseq_statusfile};
      result=$?
      msg="${BWon}Resuming at step [ ${BMon}$starting_step${BWon} ]"
      msg+=" --[ ${BGon}${msg1_sequence[${starting_step}]}${BWon} ]--${Boff}"
      d_message "${msg}" 2
      ;;
    -*[0-9]*  )
        # currently there are double-digit steps; if the next char is also numeric, append it
        myarg=${1:1} # drop the leading "-"
        export RESUME=${TRUE}
        if $(isnumber ${myarg}) && [ ${myarg} -ge 0 ] && \
          [ ${myarg} -lt ${#command_sequence[@]} ] ; then
            export starting_step=${myarg};
            result=$?
            msg="${BYon}Saving next step ${BWon}${starting_step}${BYon}"
            msg+=" to status file [${Boff}${cmdseq_statusfile}${BYon}]${Boff}"
            d_message "${msg}" 2
            echo ${starting_step} > ${cmdseq_statusfile};
            msg="${BWon}Resuming at step [ ${BMon}${starting_step}${BWon} ]"
            msg+=" --[ ${BGon}${msg1_sequence[${starting_step}]}${BWon} ]--${Boff}"
            d_message "${msg}" 2
        else
            # it may be a combination of numbers and letters - hand off to process_compound_arg
            process_compound_arg $1
            result=$?
        fi
        ;;
    "-"[iI] | "--interactive"    )
      # interactive
      export INTERACTIVE=${TRUE};
      result=$?
      d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
      ;;
    "-"[nN] | "--noninteractive" )
      # non-interactive
      export INTERACTIVE=${FALSE}
      result=$?
      d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
      ;;
    "-"[qQ] | "--quiet"          )
      # decrease verbosity
      if [[ ${verbosity} -gt 0 ]] ; then
          let verbosity--
          result=$?
      elif [[ ${verbosity} -eq 0 ]] ; then
          export VERBOSE=${FALSE}
          result=$?
          d_message "${BYon}decreased verbosity: ${verbosity}${Boff}" 2
      else
          # error
          result=1
          dE_message "${BWon}error: negative verbosity: ${verbosity}${Boff}" 2
      fi
      ;;
    "-"[vV] | "--verbose"        )
      # increase verbosity
      export VERBOSE=${TRUE}
      if [[ ${verbosity} -lt 6 ]] ; then
          let verbosity++
          result=$?
          d_message "${BYon}increased verbosity: ${verbosity}${Boff}" 2
      fi
      ;;       # note: "numeric" args like -4 should fall through to this default
    *                            )
      # run local arg module if it exists (must end with "* ) process_compound_arg $1 ;;")
      if [ -f /etc/${BPN}/local.cmdline_arguments ] ; then
          source /etc/${BPN}/local.cmdline_arguments
          # each should set result as shown above, and if needed USED_OPERAND
      else
          process_compound_arg $1
          result=$?
      fi
      ;;
  esac
  d_message "done with process_argument" 3
  return $result
}

process_compound_arg()    # process a compount argument
{
    d_message "about to process compound [ $* ]" 2
    d_message "my PID: $$" 5
    # must begin with a single dash
    [ ! "${1:0:1}" == "-" ] && E_message "${E_BAD_ARGS}" && usage && E_message "exiting process [$$]" && exit 1
    # must not begin with two dashes (would have been picked in process_argument)
    [ "${1:0:2}" == "--" ] && E_message "${E_BAD_ARGS}" && usage && E_message "exiting process [$$]" && exit 1
    # strip leading dash(es)
    myargs=${1##-}
    # handle remaining characters in sequence
    while [ -n "${myargs}" ]
    do
        #handle one character at at time, from the left
        case ${myargs:0:1} in
            [sS] )
                # display status
                d_message "${BYon}reading status file: [ ${BWon}${cmdseq_statusfile}${BYon}  ]${Boff}" 2
                read starting_step < ${cmdseq_statusfile};
                if [ $starting_step -eq 0 ] ; then
                    msg="${BWon}Status: $starting_step ;"
                else
                    msg="${BWon}Status: Step $(($starting_step - 1)) complete ;"
                fi
                msg+=" next step would be [ ${BMon}$starting_step${BWon} ]"
                msg+=" [ ${BGon}${command_sequence[${starting_step}]} ${BWon}]${Boff}"
                d_message "${msg}" 2
                E_message "exiting process [$$]" && exit;
                ;;
            [rR] )
                # resume at stored step unless that is overridden by a new start # (below)
                d_message "${BYon}reading status file: [ ${BWon}${cmdseq_statusfile}${BYon}  ]${Boff}" 2
                export RESUME=${TRUE}
                read starting_step < ${cmdseq_statusfile};
                msg="${BWon}Resuming at step [ ${BMon}$starting_step${BWon} ]"
                msg+=" --[ ${BGon}${msg1_sequence[${starting_step}]}${BWon} ]--${Boff}"
                d_message "${msg}" 2
                ;;
            [0-9] )
                # since there may be double-digit steps, then if the next char is also numeric, append it and "shift"
                export RESUME=${TRUE}
                starting_step="${myargs:0:1}";
                if [[ "${myargs:1:1}" == [0-9] ]] ; then
                    export starting_step="${myargs:0:2}";
                    myargs=${myargs:1}
                fi
                if [ $starting_step -gt ${#command_sequence[@]} ] ; then
                    E_message "invalid starting_step [${starting_step}]"
                    usage
                else
                    msg="${BYon}Saving next step ${BWon}${starting_step}${BYon}"
                    msg+=" to status file [${Boff}${cmdseq_statusfile}${BYon}]${Boff}"
                    d_message "${msg}" 2
                    echo ${starting_step} > ${cmdseq_statusfile};
                    msg="${BWon}Resuming at step [ ${BMon}${starting_step}${BWon} ]"
                    msg+=" --[ ${BGon}${msg1_sequence[${starting_step}]}${BWon} ]--${Boff}"
                    d_message "${msg}" 2
                fi
                ;;
            [iI] )
                # interactive
                export INTERACTIVE=${TRUE};
                d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
                ;;
            [nN] )
                # non-interactive
                export INTERACTIVE=${FALSE}
                d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
                ;;
            [qQ] )
                # decrease verbosity
                [[ ${verbosity} -gt 0 ]] && let verbosity--
                [[ ${verbosity} -eq 0 ]] && export VERBOSE=${FALSE}
                d_message "${BYon}decreased verbosity: ${verbosity}${Boff}" 2
                ;;
            [vV] )
                # increase verbosity
                [[ ${verbosity} -lt 6 ]] && let verbosity++
                export VERBOSE=${TRUE}
                d_message "${BYon}increased verbosity: ${verbosity}${Boff}" 2
                ;;       # note: "numeric" args like -4 should fall through to this default
            *   )
                # run local arg module if it exists (must end with "* ) E_message "${E_BAD_ARGS}" && usage ;;")
                if [ -f /etc/${BPN}/local.cmdline_compound_arguments ] ;then
                    source /etc/${BPN}/local.cmdline_compound_arguments
                else
                    E_message "${E_BAD_ARGS}"
                    usage
                fi
                ;;
        esac
        #strip first char from myargs (i.e. "shift" one character)
        myargs=${myargs:1}
    done
    d_message "done with process_compount_arg" 3
    return 0
}

#-----[ non-cli stuff ------------------------------------------------------------------------------------------------------

isnumeric() # wrapper for broadest determination
{ # @rule will over-ride the POSIX version of isnumeric if sourced afterwards
  isint "$1" || ishexint "$1" || isfloat_posix "$1" || isfloat_regex "$1"; }

isfloat() # deprecated (now a wrapper for isfloat_regex
{ isfloat_regex "$@"; }

isfloat_regex() # regex (non-POSIX) test if $1 is a floating point number; return true/false
{ inputstring="$1"
  if  [[ "$inputstring" =~ ^[+-]?([0-9]*\.)?[0-9]+([eE][+-]?[0-9]+)?$ ]] ; then
    return 0; else return 1; fi; }
# @usage isfloat_regex "input"
# @args $1: the string to be validated
# @ret 0 if valid float; 1 if not
# @rule supports scientific notation (e.g., 1.2e+10); requires Bash/Ksh/Zsh
# @note broader than isfloat_posix; will return true for integers (e.g., 123)
# @rule isfloat moved here due to ash-incompatibility (uses regex compare =~)

map()           # linearly map input number from input range to output range
{ # trap non-numeric input
! isfloat $1 && E_message "invalid map_val for ${FUNCNAME[0]} [$1]" && return 1
! isfloat $2 && E_message "invalid from_lower bound for ${FUNCNAME[0]} [$2]" && return 1
! isfloat $3 && E_message "invalid from_upper bound for ${FUNCNAME[0]} [$3]" && return 1
! isfloat $4 && E_message "invalid to_lower bound for ${FUNCNAME[0]} [$4]" && return 1
! isfloat $5 && E_message "invalid to_upper bound for ${FUNCNAME[0]} [$5]" && return 1
[ ! -z "$6" ] && ! isfloat $6 && echo "invalid scale for ${FUNCNAME[0]} [$6]" && return 1
 map_val=$1 ; from_lower=$2 ; from_upper=$3 ; to_lower=$4 ; to_upper=$5
 scale=${6:-1} # Set default scale to 1 if not provided (number of digits after .)
# trap invalid map_val (not within input range) (( $(... | bc) )) for float #s
(( $(echo "$map_val < $from_lower" | bc -l) )) || \
    (( $(echo "$map_val > $from_upper" | bc -l) )) && \
    E_message "invalid map_val [${map_val}], not w/in input range [${from_lower} - ${from_upper}]" && return 1
# trap invalid input or output ranges - leave this unless prohibiting "reverse mapping"
#[ $to_upper -lt $to_lower ] && E_message "invalid input range [ $to_upper - $to_lower ]" && return 1
#[ $from_upper -lt $from_lower ] && E_message "invalid input range [ $from_upper - $from_lower ]" && return 1
# initialize result variable
result=999999
# calculate scaling factor
 from_delta=$(echo "scale=$scale; $from_upper - $from_lower" | bc -l)
 to_delta=$(echo "scale=$scale; $to_upper - $to_lower" | bc -l) 
 from_offset=$(echo "scale=$scale; $map_val - $from_lower" | bc -l)   # how far (above from_lower) offest into from-range
 map_factor=$(echo "scale=$scale; $to_delta / $from_delta" | bc -l)
# ratio > 1 means scaling up to a "wider" range (even if lower numbers)
# ratio < 1 means scaling down to a "narrower" range (even if higher numbers)
# scale the input offset against the output range
 to_offset=$(echo "scale=$scale; $from_offset * $map_factor" | bc -l)
# now offset (above the to_lower bound) the scaled number into the output range
result=$(echo "scale=$scale; $to_lower + $to_offset" | bc -l)
return 0
}

countdown() # output text message (arg $2, optional), and count-down seconds (arg $1)
{
  # special note: use base#number notation with prefix 10# to ensure interpretation as base 10
  # store current minutes and seconds
  min=10#$(date +%M) ; sec=10#$(date +%S)
  wait_time=10#60  #default = 1 minute
  [[ ! -z $1 ]] && wait_time="10#${1}"
  # if wait time is greater than 60 seconds, convert to minutes and seconds, else calculate it
  if [[ "${wait_time}" -ge "60" ]] ; then
    wait_min=$(( ${wait_time} / 60 ))  ;  wait_sec=$(( ${wait_time} % 60 ))
  else
    wait_min=10#0  ;  wait_sec=${wait_time}
  fi
  tgt_min="$(( ${min} + ${wait_min} ))"  ;  tgt_sec="$(( ${sec} + ${wait_sec} ))"
  if [[ "${tgt_sec}" -ge "60" ]] ; then
    tgt_min="$(( ${tgt_min} + 1 ))"  ; tgt_sec="$(( ${tgt_sec} % 60 ))"
  fi
  min="$(date +%M)"  ;  sec="$(date +%S)"
  rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
  # default message is "Pausing, ", else get from arg $2
  [[ ! -z $2 ]] && wait_msg="$2" || wait_msg="Pausing,"
  while [[ "${rem}" -gt "0" ]] ; do
    echo -en "\r${wait_msg} Time: "$(date +%H:%M:%S)
    sleep 0.1
    min="10#$(date +%M)"  ;  sec="10#$(date +%S)"
    rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
    echo -n "    $rem seconds left..."
  done ; echo return 0
}

box_msg_bash() # (LINUX BASH) $1=msg, $2=width, $3=center, $4=color
{
    local _bm_msg="$1"
    local _bm_tw=$(termwidth)
    local _bm_target_w _bm_center
    # defaults: width=tw/2, center=tw/2
    [ "$2" -gt 0 ] 2>/dev/null && _bm_target_w=$2 || _bm_target_w=$(( _bm_tw / 2 ))
    [ "$3" -gt 0 ] 2>/dev/null && _bm_center=$3   || _bm_center=$(( _bm_tw / 2 ))
    local _bm_color_seq="${4:-$OFF}"
    local _bm_lines=()   # array holding smart-wrapped lines of the message
    local _bm_buffer=4   # safety margin to help prevent words from exploding out of the box
                         # _bm_buffer must be an even number -ge 4 (integer divisible to split on each side)

    # calculate the "right_margin" that smart_wrap_n should use to wrap at "_bm_wrap_at"
    # if it uses 0 for left margin
    local _bm_r_margin=$(( _bm_tw - _bm_target_w + _bm_buffer ))
    # capture wrapped lines using smart_wrap_n as the engine
#    readarray -t _bm_lines < <(smart_wrap_n 0 0 $(( _bm_tw - _bm_wrap_at)) "$_bm_msg")
    readarray -t _bm_lines < <(smart_wrap_n 0 0 "$_bm_r_margin" "$_bm_msg")

    _bm_l_margin=$(( _bm_center - (_bm_target_w / 2) ))
    [ "$_bm_l_margin" -lt 0 ] && _bm_l_margin=0
    _bm_h_line=$(full_repeat "$H_wall" $(( _bm_target_w  )) ) # -2 = corners +2 = pad
    printf "%b" "$_bm_color_seq"

    # top border
    CUF "$_bm_l_margin"
    printf "%b%b%b%b%b\n" "$SO" "$UL_wall" "$_bm_h_line" "$UR_wall" "$SI"
    # body
    for _bm_line in "${_bm_lines[@]}"; do
        CUF "$_bm_l_margin"
        printf "%b%b%b " "$SO" "$V_wall" "$SI"   # left wall
        printf "%b" "$_bm_line"                  # pre-wrapped text
        # calculate trailing gap to keep right wall vertical
        _bm_cur_len=$(get_msg_len "$_bm_line")
        _bm_gap=$(( _bm_target_w - _bm_cur_len ))
#        [ "$_bm_gap" -gt 0 ] && repeat " " "$_bm_gap"
        # ignore the gap, use absolute ref from left
#        printf '\r'; CUF $((_bm_tw - _bm_l_margin ))
        printf '\r'; CUF $((_bm_l_margin + _bm_target_w ))
        printf " %b%b%b\n" "$SO" "$V_wall" "$SI" # Right wall
    done

    # bottom border
    CUF "$_bm_l_margin"
    printf "%b%b%b%b%b\n" "$SO" "$LL_wall" "$_bm_h_line" "$LR_wall" "$SI"
    printf "%b" "$OFF"

}

#---[ RGB ]--------------------------------------------------------
#ToDo: experiment with rgb methods for color-setting
# NOTE: this might work in a Konsole or Gnome terminal, but not lxterminal!!
# see "well known" triplet values at https://en.wikipedia.org/wiki/ANSI_escape_code
#  RED=(205, 0, 0)
#  ESC[ ... 38;2;<r>;<g>;<b> ... m Select RGB foreground color
#  ESC[ ... 48;2;<r>;<g>;<b> ... m Select RGB background color
RGB_FG()    # echo esc seq color as RGB. (OK in Konsole/Gnome term, but not lxterminal)
{ local FG="38;2"; R=$1; G=$2; B=$3; echo -e "${CSI}${FG};${R};${G};${B}m" ; }
RGB_BG()    # echo esc seq color as RGB. (OK in Konsole/Gnome term, but not lxterminal)
{ local BG="48;2"; R=$1; G=$2; B=$3; echo -e "${CSI}${BG};${R};${G};${B}m" ; }

list_unused_disks()    # list block devices with no active mountpoint
{  # set TERMWIDTH now, or it would be an inappropriate use of io control
   # for stdin during while loop's redirection for "read line"
   TERMWIDTH=$(termwidth)
    # read every line of lsblk (NAME, TYPE, MOUNTPOINT columns)
    while read line ; do
        # use eval to interpret the -P pairs as variable assignments
        eval ${line}
        if [[ "${TYPE}" == "disk" ]] ; then
            # look for disks with no children (TYPE crypt, part, lvm) mounted
            candidate_name=$NAME ; candidate_type=$TYPE
            INUSE=$FALSE
            message_n "checking ${candidate_type} ${candidate_name} ..."
            while read innerline; do
                eval ${innerline}
                if [[ ! -z ${MOUNTPOINTS} ]] || [[ ! -z "$(findmnt | grep ${NAME})" ]] ; then
                    INUSE=$TRUE
                fi
            done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS /dev/${candidate_name})
            if [[ ! $INUSE ]] ; then
                echo -en "${BGon}(not in use) ${BMon}/dev/${candidate_name}${Boff}"
                non-stty-right_status $TRUE
                lsblk /dev/${candidate_name} | sed 's|^|    |'
            else
                echo -en "${BRon}(in use)${Boff}"
                non-stty-right_status 1
            fi
        fi
    done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS)
    return 0
}

## parking this here until I figure out what I want to do with it
progress() # show progress arrow (visualize $1 of $2 steps complete)
{ # intended to be called in each iteration of some monitored process
  # e.g. # for x in $(seq 0 250); do progress $x 250; sleep .1; done
  [ $# -ne 2 ] && { E_message "${BRon}Error: step and total required${Boff}"; return 1; }
  _p_step="$1"; _p_total="${2:-100}"  # default to 100 steps
  _p_margin=10; _p_marker="-"         # this is the element used to draw the progress bar (a line of these)
  # use these common variables for width/height if they exist, else call function
  # (should exist already, if user called progress_init() first)
  _p_tw=${COLUMNS:-$(termwidth)}; _p_th=${LINES:-$(termheight)}
  # analytical math
  _p_range=$(( _p_tw - ( _p_margin * 2 ) - 3 ))    # num physical cols between screen margins - safety buffer (3)
  _p_percent=$(( (100 * _p_step) / _p_total ))     # process progress as a percent of total num steps
  _p_fill=$(( (_p_range * _p_step) / _p_total ))   # num physical cols to fill with marker to represent progress
  _p_start=$(( _p_margin + 1 ))                    # starting physical column number
  _p_end=$(( _p_tw - _p_margin ))                  # ending physical column number
  # determine which color to use for the text NN% marker in the center
  if [ "$_p_percent" -ge 90 ]; then _p_color="${BGon}"    # green if over 90%
  elif [ "$_p_percent" -lt 70 ]; then _p_color="${BRon}"  # red if less than 70%
  else _p_color="${BYon}"; fi                             # yellow otherwise (0-70%)
  # POSIX repeat (just build it here to save a function call to repeat()
  _p_bar=$(printf "%${_p_fill}s" | tr ' ' "$_p_marker")
  # save cursor position, move to Row
  SCP; CUP "$_p_th" "$_p_start"
  # draw the structure: |---( 50% )--->| # 4 buckets: (part-built-by-format-string), bucket#:content[type]
  # (wall '|') 1:color[ansi] , 2:_p_bar[string], 3:color-reset[ansi], (arrow head '>'), 4:spaces[string], (wall'\')
  printf "|%b%s%b>%s|" "$_p_color" "$_p_bar" "${Boff}" "$_p_spaces"
  EL  # ANSI erase from cursor to end of line (clear any leftovers from a previous wider bar)
  _p_mid=$(( _p_tw / 2 - 3 )); CUP "$_p_th" "$_p_mid"     # Jump to middle and overlay percentage; then resore cursor to saved position
  printf "( %b%3d%%%b )" "$_p_color" "$_p_percent" "$Boff"; RCP

  unset -v _p_step _p_total _p_margin _p_marker _p_tw _p_th _p_range \
           _p_percent _p_fill _p_start _p_end _p_color _p_bar _p_mid
  return 0 ; }

bs()                   # recursive binary search for $1 target(s) from $2 start(d) to $3 end(d) in search_list $@ (after 3 shifts)
{
  # return the index number of the entry in the list, or -1 if not found
  # expects VERBOSE, verbosity, and initial depth=0 to be set externally before first call to bs
  target="$1"; shift;  start="$1"; shift;  end="$1"; shift; remainder="$@"
  search_list=($(alpha_words ${remainder}))   # alphabetize the list so the binary search can work
  if [ $verbosity -ge 4 ] ; then
    message_n "search_list: ["
    echo -n "${search_list[@]}"
    echo "]"
    message "search_list length is [${#search_list[@]}]"
  fi
  let "result=-1"
  if [[ $depth -gt ${#search_list[@]} ]]
  then
    E_message "Something is wrong here -- depth [$depth] exceeds search_list [${#search_list[@]}]"
    return 1  # can't go deeper than the length of the list
  fi
  diff=$(( $end - $start ))
  middle=$(( $start + $(( $diff / 2 )) ))
  ## guarantee to look at both start and end before giving up
  if [[ ${diff} -eq 1 ]]; then let "middle+=$(( ${depth} % 2 ))"; else DIFF1UPPER=$FALSE; DIFF1LOWER=$FALSE; fi
  d_message " depth=[$depth]" 4;  d_message " start=[$start]" 4;  d_message "   end=[$end]" 4;  d_message "middle=[$middle]" 4
  d_message ">> [${search_list[${middle}]}] <<" 4
  if [[ "${search_list[${middle}]}" == "${target}" ]]
  then
    result=$middle   # equal
  else  # not yet equal, so search either the upper or lower half of the remaining range
    [[ $start -eq $end ]] && return 1
    let "depth+=1"   # increment recursive depth and then recurse
    if [[ "${search_list[${middle}]}" > "${target}" ]]
    then   # found element is greater than target (search lower half next)
      [[ $diff -eq 1 ]] && DIFF1UPPER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then d_message "both diff=1 cases examined. not found" 3; return 1; else d_message "DIFF1 flags not yet both true" 3; fi
      d_message "candidate [${search_list[${middle}]}] at position [${middle}] is GREATER than target [${target}], DIFF1UPPER is now [$(TrueFalse $DIFF1UPPER)] -- search lower half next" 4
      bs $target $start $middle ${search_list[@]}
    else   # found element is less than target (search upper half next)
      [[ $diff -eq 1 ]] && DIFF1LOWER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then d_message "both diff=1 cases examined. not found" 3; return 1; else d_message "DIFF1 flags not yet both true" 3; fi
      d_message "candidate [${search_list[${middle}]}] at position [${middle}] is LESS than target [${target}], DIFF1LOWER is now [$(TrueFalse $DIFF1LOWER)] -- search upper half next" 4
      bs $target $middle $end ${search_list[@]}
    fi
  fi
  d_message "about to return from depth [$depth]" 5
  [ $depth -eq 0 ] && d_message "result: [$result]" 5
  let "depth-=1";  return 0
}

