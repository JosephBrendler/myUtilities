#!/bin/bash
#
###############################################################################################################
#
# finalize-chroot-joetoo    joe brendler 12 June 2025
#
# NOTEs:
# can be run separately by user at any time when in proper context
# should be run automatically by /root/.bashrc if file ${firstrunmarker} exists
# this program is similar to but NOT the same as counterparts written for running inside a qemu-chroot
#
# if all goes well, remove the ${firstrunmarker} file
#   so .bashrc won't try to run it again
#

source /usr/sbin/script_header_joetoo

firstrunmarker=/root/firstlogin
[ ! -e ${firstrunmarker} ] && exit 0


#-----[ variables ]---------------------------------------------------------------------

d_message_n "assigning PN = $(basename 0) ..." 3
PN="$(basename $0)" || die "failed to assign PN"
d_right_status $TRUE 3

d_message_n "sourcing BUILD ..." 3
source /etc/joetoobuild-tools/BUILD || die "failed to source BUILD"
d_right_status $TRUE 3

d_message_n "sourcing BPN ..." 3
source /etc/joetoobuild-tools/BPN || die "failed to source BPN"
d_right_status $TRUE 3

d_message_n "sourcing script_header_joetoo_extended ..." 3
source /usr/sbin/script_header_joetoo_extended || die  "failed to source script header"
d_right_status $TRUE 3

VERBOSE=$TRUE
#verbosity=2
verbosity=3
PN=$(basename $0)

COMPLETE=$TRUE  # (tentatively; any step below can change this)
FLAGGED=$FALSE
result=0
mytimezone=America/New_York

varlist="PN BPN BUILD BOARD TARGET"
varlist+=" starting_step stopping_step cmdseq_statusfile"
varlist+=" bool.RESUME bool.INTERACTIVE"
varlist+=" bool.COMPLETE bool.FLAGGED"
varlist+=" BREAK bool.VERBOSE verbosity"
varlist+=" BREAK lv.chroot_emerge"

command_sequence=(
'validate-prerequisites'
'run-locale-gen'
'check-reload-config'
'set-password root'
'set-timezone'
'set-hostname'
'remove-kernelsources-mountpoint'
'prep-eix-db-dir'
'sync-repo gentoo'
'emerge-git-eselect-repo'
'sync-repo joetoo'
'add-user'
'fix-inittab'
'write-fstab'
'make-mountpoints'
'edit-91joetoo_platform'
'emerge-platform-meta'
'run-dispatch-conf'
'emerge-common-meta'
'run-dispatch-conf'
'edit-80joetoo_common'
'emerge-world'
'run-dispatch-conf'
'add-default-runlevel-services'
'setup-clock'
'install-grub'
'display-next-steps'
)

msg1_sequence=(
'validate prerequisites'
'run locale-gen'
'check and reload config'
'set root password'
'set timezone'
'set hostname'
'remove kernel sources mountpoint'
'prepare eix database directory'
'sync repo gentoo'
'emerge git eselect-repo'
'sync repo joetoo'
'add user'
'fix inittab'
'write fstab'
'make mountpoints'
'edit package.use/91joetoo_platform'
'emerge platform-meta'
'run dispatch-conf'
'emerge common-meta'
'run dispatch-conf'
'edit 80joetoo_common'
'chroot_emerge world'
'run dispatch-conf'
'add default runlevel services'
'set up clock'
'install grub'
'display next steps'
'complete'
)

msg2_sequence=(
'validating prerequisites'
'running locale-gen'
'checking and reloading config'
'setting root password'
'setting timezone'
'setting hostname'
'removing kernel sources mountpoint'
'prepare eix database directory'
'syncing repo gentoo'
'emerge dev-vcs/git and eselect-repo'
'syncing repo joetoo'
'adding user'
'fixing inittab'
'writing fstab'
'making mountpoints'
'editing package.use/91joetoo_platform'
'emerging platform-meta'
'running dispatch-conf'
'emerging common-meta'
'running dispatch-conf'
'editing 80joetoo_common'
'emerging(-chroot) world'
'running dispatch-conf'
'adding default runlevel services'
'setting up clock'
'installing grub'
'displaying next steps'
'complete'
)

#-----[ functions ]---------------------------------------------------------------------

initialize_variables() {
    [ $verbosity -lt 2 ] && message_n "initializing ..." || message "initializing ..."
    initialize_vars ${varlist}

    # set default values
    FLAGGED=$FALSE
    d_message_n "sourcing BUILD ..." 2
    source /etc/joetoobuild-tools/BUILD ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE
    d_message_n "sourcing BPN ..." 2
    source /etc/joetoobuild-tools/BPN ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default starting_step = 0" 2
    export starting_step=0 ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    export stopping_step=$(( ${#command_sequence[@]} - 1 )) ; result=$?; d_right_status $result 2
    [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default cmdseq_statusfile = /root/bin/finalizechrootjoetoo_status" 2
    export cmdseq_statusfile="/root/bin/finalizechrootjoetoo_status" ; result=$?; d_right_status $result 2
    [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting PN = $(basename $0)" 2
    PN=$(basename $0) ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default INTERACTIVE true" 2
    export INTERACTIVE=$TRUE ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default VERBOSE true" 2
    export VERBOSE=$TRUE ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    d_message_n "setting default verbosity = 3" 2
    export verbosity=3 ; result=$?; d_right_status $result 2 ; [ $result -ne 0 ] && FLAGGED=$TRUE

    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above"
        return 1
    else
        message "initialization complete"
        return 0
    fi
}

display_configuration()  {
    # will pick up PN, BUILD, varlist from the environment of whatever script sources cb-common-functions
    separator "${PN}-${BUILD}" "(configuration)"
    longest=$(get_longest ${varlist})
    display_vars ${longest} ${varlist}
    return 0
}

get-target() {
    # determine what qemu-chroot environment (target) I'm running inisde of (flag, fatal if failure)
    d_message_n "determining TARGET ..." 1
    apparent_TARGET=$(portageq envvar CHOST) || die "failed to assign apparent_TARGET"
    d_right_status $TRUE 1
    d_message "apparent_TARGET: $apparent_TARGET" 2
    return 0
}

get-check-config() {
    # source /root/.cb-config and validate TARGET (fatal if failure)
    # also assign BOARD, etc. I am ... (non-fatal if failure)
    d_message_n "checking /root/.cb-config" 1
    if [ -e /root/.cb-config ] ; then
        source /root/.cb-config  || die "failed to source /root/.cb-config"
        d_right_status $TRUE 1
    else
        d_right_status 1 1
        E_message "/root/.cb-config not found; exiting"
        return 1
    fi
    d_message_n "validating BOARD, TARGET and qemu-chroot config ..." 1
    if [[ "${apparent_TARGET}" == "${TARGET}" ]] ; then
        debug_do 'echo -en " ${BGon}(match)${Boff}"' 1
        d_right_status $TRUE 1
        d_message "  BOARD ........: $BOARD" 2
        d_message "  TARGET .......: $TARGET" 2
        d_message "  TARGET_ARCH ..: $TARGET_ARCH" 2
        d_message "  QEMU_ARCH ....: $QEMU_ARCH" 2
        return 0
    else
        debug_do 'echo -en " ${BRon}(mismatch)${Boff}"' 1
        d_right_status 1 1
        E_message "TARGET mismatch; exiting"
        FLAGGED=$TRUE
        return 1
    fi
    return 0
}

build-chroot_emerge-command() {
#    export chroot_emerge="ROOT=/ CBUILD=${TARGET} \
#        PORTAGE_TMPDIR=/tmp/ DISTDIR=/var/cache/distfiles \
#        PKGDIR=/var/cache/binpkgs PORT_LOGDIR=/var/log/portage \
#        HOSTCC=${TARGET}-gcc emerge"
    export chroot_emerge="emerge"
}

validate-prerequisites() {
    # Validate prerequisite expectations -
    ### we should be running inside a chroot
    message_n "Verifying we are inside a chroot ..."
    # Get device and inode numbers for the current root (/)
    current_root_dev_inode=$(stat -c "%d:%i" /)
    # Get device and inode numbers for the root of the init process (/proc/1/root)
    init_root_dev_inode=$(stat -c "%d:%i" /proc/1/root/.)
    # of these do not differ, assume we are NOT in a chroot
    [[ "${current_root_dev_inode}" == "${init_root_dev_inode}" ]] && die "looks like we are NOT in a chroot"
    right_status $TRUE

    ### make.conf should be built for chroot/liveOS rather than crossbuilding
    message_n "Verifying make.conf is built for chroot/liveOS ..."
    validate_make_conf || die "failed to validate_make_conf"
    right_status $TRUE
    return 0
}

validate_make_conf() {
    source /etc/portage/make.conf
    d_message "ROOT: ${ROOT}" 6
    [[ "${ROOT}" == "/" ]] && d_message "ROOT [${ROOT}] == \"/\"" 6
    case ${ROOT} in
        "/"      ) echo -e -n " (${BGon}Ok${Boff})" ; return 0 ;;
        "/usr/"* ) echo -e " (${BRon}for crossbuilding${Boff})" ; return 1 ;;
        *        ) echo -e " (${BRon}invalid ROOT [${ROOT}]${Boff})" ;  return 1 ;;
    esac
}

run-locale-gen() {
    # /etc/locale.gen and /etc/env.d/02locale were updated by populate-target script
    message "running locale-gen ..."
    locale-gen ; result=$?
    [ $result -ne 0 ] && COMPLETE=$FALSE
    right_status $result
}

check-reload-config() {
    # check/reload config
    message "checking/reloading config ..."
    gcc-config -l && \
    ldconfig -v && \
    ROOT=/ env-update && \
    source /etc/profile ; result=$?
    [ $result -ne 0 ] && COMPLETE=$FALSE
    right_status $result
    return $result
}

set-password() {
    # set passwd for user $1
    [ $# -ne 1 ] && E_message "invalid argument for set-password()" && return 1
    user="$1"
    message "please set the password for user [${user}] on this image"
    passwd "${user}" ; result=$?
    if [ $result -eq 0 ] ; then
        message "${BGon}(success)${Boff}"
        return 0
    else
        E_message "failed to set passwd for user [${user}]"
        FLAGGED=$TRUE
        return 1
    fi
}

set-timezone() {
    #  set timezone
    message_n "setting local timezone (America/New_York) for joetoo ..."
    ln -sf ../usr/share/zoneinfo/${mytimezone} /etc/localtime && \
    ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
    ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
}

set-hostname() {
#  set hostname
    response=""
    message "${BYon}Please identify the hostname for this system${Boff}"
    message "${BMon}Note:${Boff} If you are providing apache ssl or openvpn keys"
    message "via the /etc/joetoobuild-tools/mkimg-files/ structure of this build,"
    message "then they must correspond to this hostname"
    echo
    while [[ ! "${response}" == [yYsS] ]] ; do
        echo -en "${BGon}*${Boff} set hostname for this image: "
        read candidate
        message "you responded [ ${candidate} ]"
        new_prompt "is this correct?"
    done
    if [[ "${response}" == [yY] ]] ; then
        message_n "setting hostname: ${candidate}"
        echo "${candidate}" > /etc/hostname
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
    else
        E_message "candidate hostname provided, then rejected"
        message "please make a note to manually run the following command when you have time --"
        message "    ${BBon}echo ${BYon}<hostname> ${BGon}> ${Boff}/etc/hostname"
        return 2
    fi
}

remove-kernelsources-mountpoint() {
     [ -d /usr/src/linux ] && rm -r /usr/src/linux ; result=$?
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result && return 0) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
}

prep-eix-db-dir() {
    SOFARSOGOOD=$TRUE
    # prepare the directory that will hold the eix database
    message "preparing the eix database directory ..."
    message_n "looking for /var/cache/eix"
    if [ ! -d /var/cache/eix ] ; then
        echo -en " (creating)"
        mkdir -p /var/cache/eix/ ; result=$?
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && SOFARSOGOOD=$FALSE )
    else
        echo -en " (found)" ; right_status $TRUE
    fi
    message_n "setting permissions for /var/cache/eix"
    chown portage:portage /var/cache/eix ; result=$?
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && SOFARSOGOOD=$FALSE )
    [[ $SOFARSOGOOD ]] && return 0 || ( FLAGGED=$TRUE && return 1)
}

emerge-git-eselect-repo() {
    # before sync-repo joetoo, we need git (and eselect-repo for form)
    eval "${chroot_emerge} -av1 dev-vcs/git eselect-repository" ; result=$?
    message_n "exit status - " && right_status $result || ( right_status $result && return 1 )
    return 0
}

sync-repo() {
    REPO=$1
    # if the eix database directory does not exist, create it and give portage permission to use it
    if [ ! -d /var/cache/eix ] ; then
        message_n "eix database directory does not exist; creating ..."
        mkdir -p /var/cache/eix ; right_status $?
        message_n "setting permissions on eix database directory ..."
        chown -R portage:portage /var/cache/eix ; right_status $?
    else
        message "eix database /var/cache/eix already exists"
        message_n "setting permissions on eix database directory ..."
        chown -R portage:portage /var/cache/eix ; right_status $?
    fi
    # just notify which case we have - empty or existing repo
    [[ -z $(find var/db/repos/${REPO}/ -mindepth 1) ]] && E_message "Repository ${REPO} is empty" || \
        message "Repository ${REPO} exists"
    # run ${chroot_emerge} --sync (explicitly rather than with alias) for this repo
    message 'synchronizing portage tree with ${chroot_emerge} -av --sync'" ${REPO} ..."
    d_message "chroot_emerge = ${chroot_emerge}" 3

    eval "${chroot_emerge} -av --sync ${REPO}" ; result=$?
    message_n "exit status - " && right_status $result || ( right_status $result && return 1 )
    return 0
}

add-user() {
    # populate-user -- cb-populate-image should have loaded whatever structure
    #    was found in /etc/joetoobuild-tools/mkimg-files ...
    #    including .bashrc, .ssh/keys...
    #    as long as user populated that structure after emerging joetoobuild-tools
    response=""
    while [[ ! "${response}" == [yYsS] ]] ; do
        echo
        echo -en "${BGon}*${Boff} set username for routine daily user: "
        read candidate
        message "you responded [ ${candidate} ]"
        new_prompt "is this correct?"
    done
    if [[ "${response}" == [yY] ]] ; then
        message_n "setting up user ${candidate}"
        useradd -m -G wheel,console,audio,cdrom,video,cdrw,usb,users,portage -s /bin/bash ${candidate} && \
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
    else
        E_message "candidate username provided, then rejected"
        message "please make a note to manually run the following command when you have time --"
        message "    useradd ${BMon}-m -G${Boff} wheel,console,audio,cdrom,video,cdrw,usb,users,portage ${BMon}-s${Boff} /bin/bash ${BRon}\${username}${Boff}"
        return 2
    fi

    # set password for this user
    set-password ${candidate} && ( right_status $? && return 0 ) || \
        ( right_status $? && FLAGGED=$TRUE && return 1 )
}

fix-inittab() {
    message_n "fixing /etc/inittab s0..."
    sed -i 's|^s0:|#s0:|' /etc/inittab && result=$? && \
    ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
    ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
    message_n "fixing /etc/inittab f0..."
    sed -i 's|^f0:|#f0:|' /etc/inittab && result=$? && \
    ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
    ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE && return 1 )
}

write-fstab() {
    # get root_dev (-P produces assignable var/val pairs; grep mountpoint ensures output TARGET matches mountpoint)
    message_n "determining root_dev ..."
    root_mountpoint="/" ; SOURCE=""
    eval "$(findmnt -Po SOURCE,TARGET,FSTYPE --target ${root_mountpoint} | grep ${root_mountpoint})" && \
    root_dev=${SOURCE} || die "failed to assign root_dev"
    echo -e -n " (${root_dev})"
    right_status $TRUE
    # get boot_dev (-P produces assignable var/val pairs; grep mountpoint ensures output TARGET matches mountpoint)
    message_n "determining boot_dev ..."
    boot_mountpoint="/boot" ; SOURCE=""
    eval "$(findmnt -Po SOURCE,TARGET,FSTYPE --target ${boot_mountpoint} | grep ${boot_mountpoint})" && \
    boot_dev=${SOURCE} || die "failed to assign root_dev"
    echo -e -n " (${root_dev})"
    right_status $TRUE
    # get blkid data for root_dev
    message_n "getting blkid data for root_dev"
    TYPE=""; UUID=""; PARTUUID=""
    eval $(blkid | grep ${root_dev} | sed "s|${root_dev}: ||") ; result=$?
    if [ $result -eq 0 ] ; then
        root_fstype=${TYPE}
        root_uuid=${UUID}
        root_partuuid=${PARTUUID}
        echo -en " (fstype: [${root_fstype=}] partuuid: [${root_partuuid}])"
        # set fstab opts and dump-pass strings for root
        root_opts="noatime"
        root_dp="0 1"
    else
        echo -en " ${BRon}(fail)${Boff}"
        right_status $result
        FLAGGED=$TRUE
        return 1
    fi
    right_status $TRUE
    # get blkid data for boot_dev
    message_n "getting blkid data for boot_dev"
    if [ ! -z "${boot_dev}" ] ; then
        TYPE=""; UUID=""; PARTUUID=""
        eval $(blkid | grep ${boot_dev} | sed "s|${boot_dev}: ||") ; result=$?
        if [ $result -eq 0 ] ; then
            boot_fstype=${TYPE}
            boot_uuid=${UUID}
            boot_partuuid=${PARTUUID}
            echo -e -n " (fstype: [${boot_fstype=}] partuuid: [${boot_partuuid}])"
            # set fstab opts and dump-pass strings for boot
            boot_opts="noatime,noauto,nodev,nosuid,noexec"
            boot_dp="1 2"
        else
            echo -e -n " ${BRon}(fail)${Boff}"
            right_status $result
            FLAGGED=$TRUE
            return 1
        fi
    else
        echo -e -n " (none mounted; skipping)"
    fi
    right_status $TRUE
    # write (append) fstab line for /boot and / (PARTUUIDs will have to be changed after image is written to media (e.g. sd card)
    if [ ! -z "${boot_dev}" ] ; then
        message_n "writing (appending) fstab line for /boot ..."
        echo -e "PARTUUID=${boot_partuuid}\t${boot_mountpoint}\t\t${boot_fstype}\t\t${boot_opts}\t\t${boot_dp}" >> /etc/fstab && \
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE )
    fi
    message_n "writing (appending) fstab line for / ..."
    echo -e "PARTUUID=${root_partuuid}\t${root_mountpoint}\t\t${root_fstype}\t\t${root_opts}\t\t${root_dp}" >> /etc/fstab && \
    ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
    ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE )
    # write (append) a placeholder fstab line for swap
    message_n "writing (appending) fstab placeholder line for /var/cache/swap/swap1 ..."
    echo -e "/var/cache/swap/swap1\tnone\t\tswap\t\tsw\t\t0 0" >> /etc/fstab && \
    ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
    ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && FLAGGED=$TRUE )
    return 0
}

make-mountpoints() {
    #make standard joetoo mountpoints in /mnt/
    for x in card stick thumb image gentoo from to key temp ; do
        message_n "mountpoint ${x}"
        if [ ! -d /mnt/${x} ] ; then
            echo -en " (making)"
            mkdir -p /mnt/${x} ; right_status $?
        else
            echo -en " (exists)" ; right_status $TRUE
        fi
    done
}

edit-91joetoo_platform() {
    nano /etc/portage/package.use/91joetoo_amd64
    return $?
}

emerge-platform-meta() {
    eval "${chroot_emerge} -av joetoo-platform-meta" ; result=$?
    message_n "exit status - " && right_status $result || ( right_status $result && return 1 )
    return 0
}

emerge-common-meta() {
    eval "${chroot_emerge} -av joetoo-common-meta" ; result=$?
    message_n "exit status - " && right_status $result || ( right_status $result && return 1 )
    return 0
}

edit-80joetoo_common() {
    nano /etc/portage/package.use/80joetoo_common
    return $?
}

emerge-world() {
    # re-run chroot_emerge -uavDN @world --keep-going
    message "about to run chroot_emerge -uavDN @world --keep-going"
    [[ $INTERACTIVE ]] && emerge_opts="-uavDNg" || emerge_opts="-uvDNg"
    eval "${chroot_emerge} ${emerge_opts} @world --keep-going" ; result=$?
    [ $result -eq 0 ] && message "emerge-world ${BGon}succeeded${Boff}" || \
        E_message "emerge-world ${BRon}failed${Boff}"
    return $result
}

run-dispatch-conf() {
    message "about to run dispatch-conf"
    ROOT=/ dispatch-conf ; result=$?
    [ $result -eq 0 ] && message "run-dispatch-conf ${BGon}succeeded${Boff}" || \
        E_message "run-dispatch-conf ${BRon}failed${Boff}"
    return $result
}

add-default-runlevel-services() {
    # add all services to default runlevel (should have merged with world)
    SOFARSOGOOD=$TRUE
    # add prerequisite networking links in /etc/init.d
    message "Adding prerequisite network interface links in /etc/init.d ..."
    list="eth0 wlan0"
    for x in $list ; do
        message_n "interface ${x}"
        if [ ! -L /etc/init.d/net.${x} ] ; then
            echo -en " (linking)"
            ln -s /etc/init.d/net.lo /etc/init.d/net.${x} ; result=$?
            ( echo -en " ${BGon}(success)${Boff}" && right_status $result ) || \
            ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && SOFARSOGOOD=$FALSE )
        else
            echo -en " (already linked)" ; right_status $TRUE
        fi
    done
    # add links for services in default runlevel
    message "Adding services to the default runlevel ..."
    list="apache2 chronyd cronie dbus distccd gpm mysql net.eth0 net.wlan0 ntpd php-fpm rsyncd sshd sysklogd"
    for x in $list ; do
        message_n "examining ${x}"
        if [ ! -L /etc/runlevels/default/${x} ] ; then
            echo -en " (linking)"
            ln -s /etc/init.d/${x} /etc/runlevels/default/${x} ; result=$?
            ( echo -en " ${BGon}(success)${Boff}" && right_status $result ) || \
            ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && SOFARSOGOOD=$FALSE )
        else
            echo -en " (already linked)" ; right_status $TRUE
        fi
    done
    if [[ $SOFARSOGOOD ]] ; then
        message "add-default-runlevel-services ${BGon}succeeded${Boff}"
        return 0
    else
        E_message "add-default-runlevel-services ${BRon}completed with errors${Boff}"
        FLAGGED=$TRUE
        return 1
    fi
}

setup-clock() {
    # determine what is presently set up, query user to fix
    currentclock=$(find /etc/runlevels/boot/ -iname "*clock" -exec basename {} \;)
    case ${currentclock} in
        [sh]"wclock" )
            message "boot runlevel currentclock: ${currentclock}" ;
            case ${currentclock:0:1} in
                "h" ) otherclock="swclock" ;;
                "s" ) otherclock="hwclock" ;;
                * ) E_message "invalid currentclock" ; return 1 ;;
            esac
            response="" ;
            msg="would you like to change to ${otherclock} ?\n"
            msg+="  y = yes; change | [s|n] = no; keep"
            new_prompt "${msg}"
            case ${response:0:1} in
                [yY] )
                    message_n "removing current boot runlevel clock service ..." ;
                    rm /etc/runlevels/boot/${currentclock} ; right_status $?
                    message_n "adding new boot runlevel clock service [${otherclock}] ..."
                    ln -s /etc/init.d/${otherclock} /etc/runlevels/boot/${otherclock} ; right_status $?
                    ;;
                [nNsS] ) ;;
                * ) E_message "invalid response" ; return 1 ;;
            esac
            return 0 ;
            ;;
        * ) E_message "invalid clock for boot runlevel: [{currentclock}]" ; return 1 ;;
    esac
}

install-grub() {
    # this should have been installed in /usr/sbin/ (in PATH) by joetoolkit
    # ( maybe add step to edit make.conf and remind user to look at this)
    grub_install_both_ways
    chmod +x /etc/grub.d/10_linux
    chmod +x /etc/grub.d/20_linux_xen
    grub-mkconfig -o /boot/grub/grub.cfg
}

# keep this in case we go back to building for sbcs this way, too
install-boot-firmware() {
    # install boot-firmware with
    #    sys-boot/raspi-boot-firmware  -- for raspi boards, all of which are named bcm27xx-rpi-x-x...
    #    sys-boot/rockchip-boot-firmware  -- for rockchip boards, all of which are named rk3xxx-nnnn
    #    for generic boards use default (raspi)
    # installs kernel and u-boot reflash resources
    # determine which we need ...
    # re-load BOARD, in case we are resuming
    d_message "BOARD: $BOARD" 5
    case ${BOARD:0:2} in
        "bc" )  # raspi
            package="sys-boot/raspi-boot-firmware"
            prefix=" USE=\"${BOARD} dtbo kernel\""
            ;;
        "rk" )  # rockchip
            package="sys-boot/rockchip-boot-firmware"
            prefix=" USE=\"${BOARD} dtbo armbian_kernel\""
            ;;
        "me" )  # amlogic
            package="sys-boot/nxp-boot-firmware"
            prefix=" USE=\"${BOARD} dtbo armbian_kernel joetoo-fw \""
            ;;
        "fs"|"im" )  # nxp (freescale)
            package="sys-boot/nxp-boot-firmware"
            prefix=" USE=\"${BOARD} dtbo kernel\""
            ;;
        *    ) E_message "invalid board case in $0"; return 1 ;;
    esac
    [[ $INTERACTIVE ]] && emerge_opts="-uavDNUg" || emerge_opts="-uvDNg"
    message "about to run ${prefix} chroot_emerge ${emerge_opts} ${package}"
    eval "${prefix} ${chroot_emerge} ${emerge_opts} ${package}" ;  result=$?
    [ $result -eq 0 ] && message "chroot_emerge ${emerge_opts} ${package} ${BGon}succeeded${Boff}" || \
        E_message "chroot_emerge ${emerge_opts} ${package}  ${BRon}failed${Boff}"
    return $result
}

# keep this in case we go back to building for sbcs this way, too
install-sbc-boot-config() {
    # install sys-boot/sbc-boot-config (covers all makers); installs --
    #    raspi: cmdline.txt, config.txt
    #    rockchip|nxp|amlogic: joetooEnv.txt, boot.cmd, boot.scr
    package="sys-boot/sbc-boot-config"
    prefix="USE=\"${BOARD}\""
    [[ $INTERACTIVE ]] && emerge_opts="-uavDNUg" || emerge_opts="-uvDNg"
    message "about to run ${prefix} chroot_emerge ${emerge_opts} ${package}"
    eval "${prefix} ${chroot_emerge} ${emerge_opts} ${package}" ;  result=$?
    [ $result -eq 0 ] && message "chroot_emerge ${emerge_opts} ${package} ${BGon}succeeded${Boff}" || \
        E_message "chroot_emerge ${emerge_opts} ${package}  ${BRon}failed${Boff}"
    return $result
}

display-next-steps() {
    # source the list of things yet-to-do
    # re-read at any time by issuing the same command manually
    source /etc/joetoobuild-tools/README_next_steps
}

#-----[ main script ]-------------------------------------------------------------------
checkroot
separator "${PN}-${BUILD}" "(starting)"

initialize_variables     # set defaults

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5

msg="processing cmdline ..."
[ $verbosity -lt 2 ] && message_n "${msg}" || message "${msg}"
process_cmdline "${@}"   # override defaults, sets BOARD or TARGET
right_status $?

validate_status_file ${cmdseq_statusfile}

# get-target will need to run "portageq envvar CHOST" which needs a the
# chroot's own repo to be sync'd first, and that needs chroot_emerge variable defined
build-chroot_emerge-command || die "failed to build-chroot_emerge-command"
sync-repo gentoo || die "failed to sync-repo gentoo"

# check CTARGET - CBUILD - CHOST configuration
get-target || die "failed to get-target"

# reload /root/.cb-config to check BOARD against CTARGET
get-check-config || die "failed to get-check-config"


display_configuration || die "failed to display_configuration"

run_sequence ${cmdseq_statusfile} || die "failed to run_sequence"

# maybe, when run_sequence is done, set up another command_sequence for sbcs, with
# 'install-boot-firmware' and
# 'install-sbc-boot-config'
# I saved the functions above, for now

message_n "removing ${firstrunmarker} ..."
rm ${firstrunmarker} ; result=$?
[ $result -ne 0 ] && COMPLETE=$FALSE
right_status $result

[[ $FLAGGED ]] && COMPLETE=$FALSE

[[ $COMPLETE ]] && \
message "chroot firstlogin configuration completed successfully" || \
E_message "chroot firstlogin configuration completed with errors; check red flags in output above"
echo
separator "${PN}-${BUILD}" "(complete)"
