#!/bin/bash

create_links()
{
  old_pwd="$PWD"
  # create busybox symlinks
  d_message "Creating busybox links ..." 1
  cd $(dirname $(find ${SOURCES_DIR} -name 'busybox'))
  for i in $busybox_link_list
  do d_message_n "Linking:   ${LBon}$i${Boff} --> ${BGon}busybox${Boff} ..." 2;
  ln -s busybox "$i" ; d_right_status $? 2; done

  # create lvm2 symlinks
  d_message "Creating lvm2 links ..." 1
  cd $(dirname $(find ${SOURCES_DIR} -name 'lvm' | grep -v '/etc'))
  for i in $lvm_link_list
  do d_message_n "Linking:   ${LBon}$i${Boff} --> ${BGon}lvm${Boff} ..." 2;
  ln -s lvm "$i" ; d_right_status $? 2; done

  # create links to other executables in associated dirs, using array set
  d_message "Creating [${#other_link_name[@]}] additional links..." 1
  for ((i=0; i<${#other_link_name[@]}; i++))
  do
    d_message_n "Linking:   ${BBon}[${other_link_dir[i]}] ${LBon}${other_link_name[i]}${Boff} --> ${BGon}${other_link_target[i]}${Boff} ..." 2;
    cd ${SOURCES_DIR}${other_link_dir[i]};
    ln -s "${other_link_target[i]}"  "${other_link_name[i]}" ;
    d_right_status $? 2;
  done
  cd $old_pwd

  # create links for init in each bin directory that is actually a directory
  for x in $bins
  do
    fileline=$(file $x)
    element=$(echo $fileline | awk '{print $1}' | sed 's|:$||')
    type=$(echo $fileline | awk '{print $2}')
    # figure out where the element is relative to the taarget and formulate the link target name
    #   since init is located at / of ${SOURCES_DIR/, depth is the number of "/" chars in element
    depth=$(grep -o '/' <<< "$element" | grep -c .)
    tgtname=""
    for ((i=0; i<$depth; i++)); do tgtname="${tgtname}../"; done
    tgtname="${tgtname}init"
    case $type in
      "directory" )
        message_n "creating link to /init in directory $element ..."
        cd ${SOURCES_DIR%/}${element}
        ln -s  ${tgtname} init
        right_status $?
        ;;
      * )
        d_message "init link not needed for ${element}, which is itself a ${type} link" 4
        ;;
    esac
  done
  cd $old_pwd
}


copy_one_part()
{
  d_message_n "Copying [ $1 ] to [ $2 ]..." 2
  if [[ $verbosity -ge 3 ]]
  then cp -av $1 $2 ; d_right_status $? 2
  else cp -a $1 $2 ; d_right_status $? 2
  fi
}

copy_other_parts()
{
  d_message "Copying init ..." 1
  copy_one_part ${MAKE_DIR%/}/init ${SOURCES_DIR%/}/

  # copy config file
  d_message "Copying init.conf ..." 1
  copy_one_part ${config_file} ${SOURCES_DIR%/}/

  # copy admin files
  d_message "Copying necessary admin files..." 1
  for i in $admin_files
  do copy_one_part ${MAKE_DIR%/}/$i ${SOURCES_DIR%/}/; done

  # copy function_header content
  d_message "Copying function headers content ..." 1
  for ((i=0; i<${#function_headers_src[@]}; i++))
  do copy_one_part ${function_headers_src[i]} ${function_headers_dest[i]}; done

  # copy other required content
  d_message "Copying other required content ..." 1
  for ((i=0; i<${#other_content_src[@]}; i++))
  do copy_one_part ${other_content_src[i]} ${other_content_dest[i]}; done

}

copy_dependencies()
{
  # use the --copy-to-tree feature of lddtree to copy all dependent files to ${SOURCES_DIR%/}/
  # use the --copy-non-elfs feature of lddtree tp copy non-ELF files (e.g. fsadm, lvmdump scripts)
  #    instead of warn+ignore
  for x in $( list_executables )
  do
    lddtree -v ${x} --copy-to-tree ${SOURCES_DIR%/}/ --copy-non-elfs
  done

  # address rare issue with error "libgcc_s.so.1 must be installed for pthread_cancel to work"
  # occurs when cryptsetup tries to open LUKS volume - see references (similar but different) --
  #   https://bugs.gentoo.org/760249 (resolved by fix to dracut)
  #   https://forums.gentoo.org/viewtopic-t-1096804-start-0.html (zfs problem. fix: copy file to initramfs)
  #   https://forums.gentoo.org/viewtopic-t-1049468-start-0.html (also zfs problem. same fix)
  # at least for now, I'm using the same fix here --

  # ( if needed, find and copy the missing file to /lib64/libgcc_s.so.1
  #   - then copy it to ${SOURCES_DIR}. Note: in this initramfs, /lib64 is a symlink to /lib )
  if [[ ! -e /lib64/libgcc_s.so.1 ]]
  then
    selector=$(gcc -v 2>&1 | grep Target | cut -d' ' -f2)
    searched_file="$( find /usr/ -iname libgcc_s.so.1 2>/dev/null | grep -v 32 | grep ${selector})"
    cp -v "${searched_file}" /lib64/libgcc_s.so.1
  fi
  missing_file=/lib64/libgcc_s.so.1
  target_name=$(basename ${missing_file})
  dir_name=$(dirname ${missing_file})

  d_message "  about to copy missing file [ ${missing_file} ] to ${SOURCES_DIR}${dir_name}/$target_name " 2
  [[ ! -e ${SOURCES_DIR}${dir_name}/${target_name} ]] && \
     copy_one_part "${dir_name}/${target_name}" "${SOURCES_DIR%/}${dir_name}/"
  chmod 755 ${SOURCES_DIR%/}${dir_name}/${target_name}
}

copy_executables() {
# copy all executables listed in executables list
d_message "Copying executables ..." 1
for ((i=0; i< ${#executables[@]}; i++))
do
    x="${executables[$i]}"
    copy_one_part ${x} ${SOURCES_DIR%/}${x}
done
}

load_executables()
{
  # read the list of executables; and load into a bash array the full pathname on the host system
  executables=();  i=0
  for exe_name in ${init_executables}
  do
    candidate=$(echo $exe_name)
    if [[ ! "${candidate}" == "" && ! "${candidate:0:1}" == "#" ]]
    then
      target=$(which ${candidate})
      executables+=("${target}")
      d_message "$i: $candidate   which is ${target}   executables[$i] ${executables[$i]}" 3
      let i++
    fi
  done
}

list_executables()
{
  for ((i=0; i<${#executables[@]}; i++))
  do
    [ ! -z ${executables[$i]} ] && echo "${executables[$i]}"
  done
}

dump_executables()
{
  count=0
  for ((i=0; i<${#executables[@]}; i++))
  do
    [ ! -z ${executables[$i]} ] && message "$i: ${executables[$i]}" && let count++
  done
  message "dumped ${count} executables"
}

build_other_devices()
{
  # used to also build block device nodes, now just the console character dev
  old_dir=$(pwd)
  cd ${SOURCES_DIR}/dev/
  d_message "Changed from ${old_dir} to SOURCES_DIR: $(pwd)" 2

  # build console character device
  message_n "making console device node in ${SOURCES_DIR}/dev/ ..."
  mknod -m 600 console c 5 1; right_status $?

  cd ${old_dir}
  d_message "Changed from SOURCES_DIR: ${SOURCES_DIR} tp old_dir: $(pwd)" 2
}

build_structure() {
# with input from text file init_structure, replicate the structure of the host system
#   in ${SOURCES_DIR}, for use by the initramfs
# create the ${SOURCES_DIR} root of initramfs directory tree
if [[ ! -d ${SOURCES_DIR} ]]; then
  message_n "creating ${SOURCES_DIR} ..."
  mkdir -p ${SOURCES_DIR}
  right_status $?
else
  E_message "Error: ${SOURCES_DIR} exists but should have been rotated out by mkinitramfs"
fi
list=$@
for x in $list
do
  fileline=$(file $x)
  element=$(echo $fileline | awk '{print $1}' | sed 's|:$||')
  type=$(echo $fileline | awk '{print $2}')
  case $type in
    "directory"|"cannot" )
      message_n "creating directory $element ..."
      mkdir -p ${SOURCES_DIR%/}${element}
      right_status $?
      ;;
    "symbolic" )
      target=$(echo ${fileline##*\ })
      dir_name=$(dirname $element)
      message_n "creating link $element --> $target in ${SOURCES_DIR%/}${dir_name}..."
      ln -s ${target} ${SOURCES_DIR%/}${element}
      right_status $?
      ;;
    * )
      echo "error - bad case"
      ;;
  esac
done
}

display_config() {
    # display the current value of a space-delimitted list of variables provided as input $@
     # provide appropriately formatting for values of variables of special type, including
    # known boolean variables and values with string-length too long for a single line
    # also offer user an option to inssert blank lines in the output by providing an
    # input variable name "<BREAK>"
    my_varlist=$@
    echo; separator "${init_config_title}" "initramfs=${BUILD}"
    longest=0

    for line in ${my_varlist}
    do
        key="$(echo $(echo $line) | cut -d'=' -f1)"
        [[ ${#key} -gt ${longest} ]] && longest=${#key}
    done

    d_echo "longest: ${longest}" 4
    for key in ${my_varlist}
    do
        eval "val=\$${key}"
        # always pad variable name with at least two dots before colon
        dotpad="$(repeat '.' $(( ${longest} - ${#key} + 2 )))"
        case $key in
            "VERBOSE"|"init_lock_down"|"VALID"|"EXISTS"|"HAS_KEY" )  # boolean
                message "${LBon}${key}${dotpad}:${Boff} $(status_color ${val})$(TrueFalse ${val})${Boff}"
                ;;
            "init_executables"|"init_passdevice_list"|"CMDLINE"|"PATH" )  # probably long string values
                message_n "${LBon}${key}${dotpad}:${Boff}"; echo_long_string ${val}
                ;;
            "BREAK" )  # blank line to funciotn as separator in output
                echo
                ;;
            * )
                message "${LBon}${key}${dotpad}:${Boff} ${val}"
                ;;
        esac
    done
    echo
}

echo_long_string() {
  #  spread a long string over several lines, if needed.  Assume external variable $longest has been set to identify start for 1st line
  input="$@"
  tw=$(termwidth)
  newline=""
  start=$longest
  for x in $input
  do
    if [[  $(( ${start} + ${#newline} + ${#x} + 1)) -le ${tw} ]] ; then
      newline="${newline} ${x}"
    else
      echo "${newline}"
      start=0   # since next will be a new line
      newline="${x}"
    fi
  done
  echo "${newline}"
}
