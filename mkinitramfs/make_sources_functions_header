#!/bin/bash

create_links()
{
  old_pwd="$PWD"
  # create busybox symlinks
  d_message "Creating busybox links ..." 1
  cd $(dirname $(find ${SOURCES_DIR} -name 'busybox'))
  for i in $busybox_link_list
  do d_message_n "Linking:   ${LBon}$i${Boff} --> ${BGon}busybox${Boff} ..." 2;
  ln -s busybox "$i" ; d_right_status $? 2; done

  # create lvm2 symlinks
  d_message "Creating lvm2 links ..." 1
  cd $(dirname $(find ${SOURCES_DIR} -name 'lvm' | grep -v '/etc'))
  for i in $lvm_link_list
  do d_message_n "Linking:   ${LBon}$i${Boff} --> ${BGon}lvm${Boff} ..." 2;
  ln -s lvm "$i" ; d_right_status $? 2; done

  # create links to other executables in associated dirs, using array set
  d_message "Creating [${#other_link_name[@]}] additional links..." 1
  for ((i=0; i<${#other_link_name[@]}; i++))
  do
    d_message_n "Linking:   ${BBon}[${other_link_dir[i]}] ${LBon}${other_link_name[i]}${Boff} --> ${BGon}${other_link_target[i]}${Boff} ..." 2;
    cd ${SOURCES_DIR}${other_link_dir[i]};
    ln -s "${other_link_target[i]}"  "${other_link_name[i]}" ;
    d_right_status $? 2;
  done
  cd $old_pwd

  # create links for init in each bin directory that is actually a directory
  for x in $bins
  do
    fileline=$(file $x)
    element=$(echo $fileline | awk '{print $1}' | sed 's|:$||')
    type=$(echo $fileline | awk '{print $2}')
    # figure out where the element is relative to the taarget and formulate the link target name
    #   since init is located at / of ${SOURCES_DIR/, depth is the number of "/" chars in element
    depth=$(grep -o '/' <<< "$element" | grep -c .)
    tgtname=""
    for ((i=0; i<$depth; i++)); do tgtname="${tgtname}../"; done
    tgtname="${tgtname}init"
    case $type in
      "directory" )
        message_n "creating link to /init in directory $element ..."
        cd ${SOURCES_DIR%/}${element}
        ln -s  ${tgtname} init
        right_status $?
        ;;
      * )
        d_echo "ignoring case $type - acting only on actual directories" 3
        ;;
    esac
  done
  cd $old_pwd
}


copy_one_part()
{
  d_message_n "Copying [ $1 ] to [ $2 ]..." 2
  if [[ $verbosity -ge 3 ]]
  then cp -av $1 $2 ; d_right_status $? 2
  else cp -a $1 $2 ; d_right_status $? 2
  fi
}

copy_other_parts()
{
  d_message "Copying init ..." 1
  copy_one_part ${MAKE_DIR%/}/init ${SOURCES_DIR%/}/

  # copy config file
  d_message "Copying init.conf ..." 1
  copy_one_part ${config_file} ${SOURCES_DIR%/}/

  # copy admin files
  d_message "Copying necessary admin files..." 1
  for i in $admin_files
  do copy_one_part ${MAKE_DIR%/}/$i ${SOURCES_DIR%/}/; done

  # copy function_header content
  d_message "Copying functon headers content ..." 1
  for ((i=0; i<${#functon_headers_src[@]}; i++))
  do copy_one_part ${functon_headers_src[i]} ${functon_headers_dest[i]}; done

  # copy other required content
  d_message "Copying other required content ..." 1
  for ((i=0; i<${#other_content_src[@]}; i++))
  do copy_one_part ${other_content_src[i]} ${other_content_dest[i]}; done

}

new_handle_dependencies()
{
  for x in $( list_executables )
  do
    lddtree -v ${x} --copy-to-tree ${SOURCES_DIR%/}/
  done

}
identify_initial_depencies_with_lddtree()
{
  # use lddtree to identify dependent libraries needed by the executables, filtering for case (3a) [see below]
  for x in $( list_executables )
  do
    lddtree ${x} | grep -v $x | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//'
  done | sort -u
}

parse_initial_dependencies()
{
  # Read each line of initial dependency output from lddtree and add the item to array
  # If it has an "interpreter" add that too
  while read item
  do
    echo $item
  done  <<< $( identify_initial_depencies_with_lddtree )
#   | cut -d' ' -f3

}

identify_all_dependencies()
{
  dependencies=()
  while read library
  do
    type="$(file ${library} | cut -d' ' -f2)"
    case $type in
      "ELF"          ) casecolor="${BMon}" ;;
      "symbolic"     ) casecolor="${LBon}" ;;
      "Bourne-Again" ) casecolor="${BYon}" ;;
      *              ) casecolor="${BRon}" ;;
    esac
    d_message "${BYon}---->${Boff} identified dependent library: ${library}   case: ${casecolor}${type}${Boff}  " 3
    [[ $verbosity -gt 2 ]] && ls -al ${library}
    d_message "     file: $(file ${library})  " 4
    dependencies+=("$(echo ${library})")
  done <<< $( parse_initial_depencies )
}

list_dependencies()
{
  for ((i=0; i<${#dependencies[@]}; i++))
  do
    [ ! -z ${dependencies[$i]} ] && echo "${dependencies[$i]}"
  done
}

dump_dependencies()
{
  count=0
  for ((i=0; i<${#dependencies[@]}; i++))
  do
    [ ! -z ${dependencies[$i]} ] && message "$i: ${dependencies[$i]}" && let count++
  done
  message "dumped ${count} dependencies"
}

copy_dependent_libraries()
{
  # Beginning with version 5.3.1, make_sources.sh switched to lddtree (app-misc/pax-utils) instead of ldd.
  # Beginning with version 8.0.2, make_sources.sh updated the algorithm to accomodate varying host system layouts
  # General algorithm:  process the new list of ecutables in the init_executables variable to identify libraries they depend on --
  #   Step 1) use the lddtree command (from app-misc/pax-utils) to identify dependencies for each executable
  #   Step 2) use the file command (from sys-apps/file) to determine how to handle each
  #   There appear to be three cases identified by the second field in the output of the file command
  #     where dir_name is the location of this dependency - target_name or link_name (the executable/link) on the host system
  #     case 1 (shell script) format: "dir_name/target_name"
  #         Action 3:  if not already there, copy dir_name/target_name to ${SOURCES_DIR}/${dir_name}
  #     case 2 (symlink) format: "dir_name/link_name: symbolic link to dir_name/target_name"
  #         Action 2: if not already there, copy target to dest dir (/lib or /usr/bin) amd/or make linkt to it
  #     case 3 (ELF) format: "dir_name/target_name"
  #       case 3a ELF is a pie executable normally identified by "interpreter" (a library; normally ld-linux-x86-64.so.2)
  #         Action 3a: if not already there, copy dir_name/target_name to /usr/bin and/or interpreter to /lib
  #       case 3b ELF is a shared object library
  #         Action 3b: if not already there, copy dir_name/target_name to /lib
  #       case 3c (subset of 1b) ELF is a shared object library that is also identified by
  #         Action 3c: if not already there, copy dir_name/target_name to /lib and/or interpreter to /lib

  d_message "Identifying dependent libraries ..." 1

  identify_all_dependencies

  d_message "Copying dependent libraries ..." 1
  for ((x=0; x<${#dependencies[@]}; x++))
  do
    # run the "file" command on each /target/path/target_name in ${dependencies[@]}
    #   the second field of this output shows if it is case (1) symlink or (2) ELF
    #   also filter vor case (3b) [see above]
    line=$(file ${dependencies[$x]})
    thiscase=$( echo $line | cut -d' ' -f2)
    d_message "  $x: ${dependencies[$x]}" 4
    d_message "    case: ${thiscase}" 4
    d_message "    examining line: ( ${line} )" 4
    case $thiscase in
      "Bourne-Again" )
        thistarget=$( echo $line | cut -d' ' -f1)
        target_name=$(basename $thistarget | sed 's/:$//')   # drop the trailing colon
        dir_name=$(dirname $thistarget)
        d_message "  Case 3 (Bourne-Again). dir_name=[$dir_name], target_name=[$target_name]" 3
        d_message "  Copy shell script $target_name to ${SOURCES_DIR}${dir_name}/ ..." 2
        d_message "  about to execute: [[ ! -e ${SOURCES_DIR%/}${dir_name}/$target_name ]] && copy_one_part \"${dir_name}/${target_name}\" \"${SOURCES_DIR}${dir_name}/\"" 3
        [[ ! -e ${SOURCES_DIR}${dir_name}/${target_name} ]] && \
          copy_one_part "${thistarget}" "${SOURCES_DIR%/}${dir_name}/"
      ;;
      "symbolic" )
        # copy the target executable (last item in the line) and create the symlink (first item in the line) to it
        thistarget=$( echo $line | cut -d' ' -f1)
        link_name=$(basename $thistarget | sed 's/:$//')   # drop the trailing colon
        dir_name=$(dirname $thistarget)
        target=$( echo $line | awk '{print $(NF)}' )   # $(NF) is the number of fields in awk input
        target_name=$(basename $target)
        target_dir_name=$(dirname $target)
        [[ "${target_dir_name}" == "." ]] && target_dir_name=${dir_name}
        # ignore the special case of host system links in /lib to ../lib64 ../usr/lib or ../usr/lib64
        #   since all libs are linked to /lib in the current merged layout of this initramfs
        #   e.g.  /lib/ld-linux-aarch64.so.1: symbolic link to ../lib64/ld-linux-aarch64.so.1
        d_message "  Case 2 (symlink) dir_name=[$dir_name], link_name=[$link_name], target_name=[$target_name] target_dir_name=[$target_dir_name]" 3
        # first copy the target of the link if it doesn't already exist
        d_message "  Copy symlink target ${target_dir_name}/$target_name to ${SOURCES_DIR%/}${target_dir_name} ..." 2
        d_message "  about to execute: [[ ! -e ${SOURCES_DIR%/}${target_dir_name}/${target_name} ]] && copy_one_part \"${target_dir_name}/${target_name}\" \"${SOURCES_DIR%/}${target_dir_name}/\"" 3
        [[ ! -e ${SOURCES_DIR%/}${target_name} ]] && \
          copy_one_part "${target_dir_name}/${target_name}" "${SOURCES_DIR%/}${target_dir_name}/"
        # next, create the link - be careful to not overwrite an executable with a link to itself
        old_pwd=$(pwd)
        cd ${SOURCES_DIR}${dir_name}
        d_message "just changed from directory [ $old_pwd ] to directory: [ $(pwd) ]" 3
        d_message_n "Linking:   ${LBon}${link_name}${Boff} --> ${BGon}${target_dir_name}/${target_name}${Boff} ..." 2
        if [[ ! -e ${SOURCES_DIR}${dir_name}/${link_name} ]]
        then
          if [[ "${target_dir_name}" == "${dir_name}" ]] ; then
            ln -s $target_name $link_name; d_right_status $? 2
          else
            ln -s ${target_dir_name}/$target_name $link_name; d_right_status $? 2
          fi
        else
          d_message_n " {link already exists} " 2
          d_right_status $? 2
        fi    ## [ ! -L ${SOURCES_DIR}${dir_name}/${link_name} ]
        cd $old_pwd
        d_message "just changed back to directory: [ $(pwd) ]" 3
      ;;
      "ELF" )
        # simplify for cases 1a, 1b, 1c - if they are not already there - if source dir_name is a "bin" copy target to /usr/bin
        #   if source dir is a "lib" copy target to /lib; if there is an "interpreter" copy it to /lib or /usr/bin
        thistarget=$( echo $line | cut -d' ' -f1)
        target_name=$(basename $thistarget | sed 's/:$//')   # drop the trailing colon
        dir_name=$(dirname $thistarget)
        d_message "  Case 3 (ELF). dir_name=[$dir_name], target_name=[$target_name] dest_dir=[$dest_dir]" 3
        d_message "  about to execute: [[ ! -e ${SOURCES_DIR%/}${thistarget} ]] && copy_one_part \"${thistarget}\" \"${SOURCES_DIR%/}${dir_name}/\"" 3
        d_message "  Copy ELF ${thistarget} to ${SOURCES_DIR%/}${dir_name} ..." 2
        # copy the executable target if it diesn't already exist
        [[ ! -e ${SOURCES_DIR%/}${thistarget} ]] && \
          copy_one_part "${thistarget}" "${SOURCES_DIR%/}${dir_name}/"
        # if this executable also has an interpreter, ensure it is also loaded
        if [[ "$line" == *"interpreter"* ]]; then
          interpreter=$(basename $(echo ${line#*"interpreter"} | cut -d',' -f1))
          sourcefile=$(find / -type f -name ${interpreter} 2>/dev/null | grep -v ${SOURCES_DIR})
          dir_name=$(dirname ${sourcefile})
          d_message "  about to execute: [[ ! -e ${SOURCES_DIR%/}${sourcefile} ]] && copy_one_part \"${sourcefile}\" \"${SOURCES_DIR}${dir_name}/\"" 3

          d_message "  maybe Copy ELF interpreter $interpreter to ${SOURCES_DIR%/}${dir_name} ..." 2
          [[ ! -e ${SOURCES_DIR}${dest_dir}/${interpreter} ]] && \
            copy_one_part "${sourcefile}" "${SOURCES_DIR%/}${dir_name}/"
        fi
      ;;

      * )
        E_message "error in copying/linking dependencies"
        exit 1
      ;;
    esac
    d_message "--------------------------------------------" 3
  done

  # address rare issue with error "libgcc_s.so.1 must be installed for pthread_cancel to work"
  # occurs when cryptsetup tries to open LUKS volume - see references (similar but different) --
  #   https://bugs.gentoo.org/760249 (resolved by fix to dracut)
  #   https://forums.gentoo.org/viewtopic-t-1096804-start-0.html (zfs problem. fix: copy file to initramfs)
  #   https://forums.gentoo.org/viewtopic-t-1049468-start-0.html (also zfs problem. same fix)
  # at least for now, I'm using the same fix here --

  # ( if needed, find and copy the missing file to /lib64/libgcc_s.so.1
  #   - then copy it to ${SOURCES_DIR}. Note: in this initramfs, /lib64 is a symlink to /lib )
  if [[ ! -e /lib64/libgcc_s.so.1 ]]
  then
    selector=$(gcc -v 2>&1 | grep Target | cut -d' ' -f2)
    searched_file="$( find /usr/ -iname libgcc_s.so.1 2>/dev/null | grep -v 32 | grep ${selector})"
    cp -v "${searched_file}" /lib64/libgcc_s.so.1
  fi
  missing_file=/lib64/libgcc_s.so.1
  target_name=$(basename ${missing_file})
  dir_name=$(dirname ${missing_file})

  d_message "  about to copy missing file [ ${missing_file} ] to ${SOURCES_DIR}${dir_name}/$target_name " 2
  [[ ! -e ${SOURCES_DIR}${dir_name}/${target_name} ]] && \
     copy_one_part "${dir_name}/${target_name}" "${SOURCES_DIR}${dir_name}/"
}

copy_executables() {
# copy all executables listed in executables list
d_message "Copying executables ..." 1
for ((i=0; i< ${#executables[@]}; i++))
do
    x="${executables[$i]}"
    copy_one_part ${x} ${SOURCES_DIR%/}${x}
done
}

load_executables()
{
  # read the list of executables; and load into a bash array the full pathname on the host system
  executables=();  i=0
  for exe_name in ${init_executables}
  do
    candidate=$(echo $exe_name)
    if [[ ! "${candidate}" == "" && ! "${candidate:0:1}" == "#" ]]
    then
      target=$(which ${candidate})
      executables+=("${target}")
      d_message "$i: $candidate   which is ${target}   executables[$i] ${executables[$i]}" 3
      let i++
    fi
  done
}

list_executables()
{
  for ((i=0; i<${#executables[@]}; i++))
  do
    [ ! -z ${executables[$i]} ] && echo "${executables[$i]}"
  done
}

dump_executables()
{
  count=0
  for ((i=0; i<${#executables[@]}; i++))
  do
    [ ! -z ${executables[$i]} ] && message "$i: ${executables[$i]}" && let count++
  done
  message "dumped ${count} executables"
}

build_other_devices()
{
  # used to also build block device nodes, now just the console character dev
  old_dir=$(pwd)
  cd ${SOURCES_DIR}/dev/
  d_message "Changed from ${old_dir} to SOURCES_DIR: $(pwd)" 2

  # build console character device
  message_n "making console device node in ${SOURCES_DIR}/dev/ ..."
  mknod -m 600 console c 5 1; right_status $?

  cd ${old_dir}
  d_message "Changed from SOURCES_DIR: ${SOURCES_DIR} tp old_dir: $(pwd)" 2
}

build_structure() {
# with input from text file init_structure, replicate the structure of the host system
#   in ${SOURCES_DIR}, for use by the initramfs
list=$@
for x in $list
do
  fileline=$(file $x)
  element=$(echo $fileline | awk '{print $1}' | sed 's|:$||')
  type=$(echo $fileline | awk '{print $2}')
  case $type in
    "directory"|"cannot" )
      message_n "creating directory $element ..."
      mkdir -p ${SOURCES_DIR%/}${element}
      right_status $?
      ;;
    "symbolic" )
      target=$(echo ${fileline##*\ })
      message_n "creating link $element --> $target ..."
      ln -sr ${SOURCES_DIR%/}/$(dirname ${element})/${target} ${SOURCES_DIR%/}${element}
      right_status $?
      ;;
    * )
      echo "error - bad case"
      ;;
  esac
done
}

display_config() {
    # display the current value of a space-delimitted list of variables provided as input $@
     # provide appropriately formatting for values of variables of special type, including
    # known boolean variables and values with string-length too long for a single line
    # also offer user an option to inssert blank lines in the output by providing an
    # input variable name "<BREAK>"
    my_varlist=$@
    echo; separator "${init_config_title}" "initramfs=${BUILD}"
    longest=0

    for line in ${my_varlist}
    do
        key="$(echo $(echo $line) | cut -d'=' -f1)"
        [[ ${#key} -gt ${longest} ]] && longest=${#key}
    done

    d_echo "longest: ${longest}" 4
    for key in ${my_varlist}
    do
        eval "val=\$${key}"
        # always pad variable name with at least two dots before colon
        dotpad="$(repeat '.' $(( ${longest} - ${#key} + 2 )))"
        case $key in
            "VERBOSE"|"init_lock_down"|"VALID"|"EXISTS"|"HAS_KEY" )  # boolean
                message "${LBon}${key}${dotpad}:${Boff} $(status_color ${val})$(TrueFalse ${val})${Boff}"
                ;;
            "init_passdevice_list"|"CMDLINE"|"PATH" )  # probably long string values
                message_n "${LBon}${key}${dotpad}:${Boff}"; echo_long_string ${val}
                ;;
            "BREAK" )  # blank line to funciotn as separator in output
                echo
                ;;
            * )
                message "${LBon}${key}${dotpad}:${Boff} ${val}"
                ;;
        esac
    done
    echo
}

echo_long_string() {
  #  spread a long string over several lines, if needed.  Assume external variable $longest has been set to identify start for 1st line
  input="$@"
  tw=$(termwidth)
  newline=""
  start=$longest
  for x in $input
  do
    if [[  $(( ${start} + ${#newline} + ${#x} + 1)) -le ${tw} ]] ; then
      newline="${newline} ${x}"
    else
      echo "${newline}"
      start=0   # since next will be a new line
      newline="${x}"
    fi
  done
  echo "${newline}"
}
