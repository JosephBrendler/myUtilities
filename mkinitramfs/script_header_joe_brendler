#!/bin/bash
#   script header with basic functions
# Author: Joe Brendler 19 Jul 2014
#

#---[ Define common variables for use in various scripts ]---
BUILD="0.0.0 (19620207)"  #redefine in base script
ROOT_UID=0       # Only users with $UID 0 have root privileges
#  Error message used by various scripts
E_NOTROOT="Must be root to run this script."
E_BAD_ARGS="Improperly formatted command line argument."

#--[ Easy ANSI Escape sequences to put color in my scripts ]---
#  see http://en.wikipedia.org/wiki/ANSI_escape_code
#  see also http://ascii-table.com/ansi-escape-sequences.php

CSI="\033["             # control sequence initiator == hex "\x1b["
#---[ Select Graphics Rendition on/off ]---------------------------
BOLD="1"       # bold on
UL="4"         # underline on
BLINK="5"      # slow blink on
BLINKFAST="6"  # fast blink on
ULoff="24"     # underline off
BLINKoff="25"  # blink off
SGRoff="0"     # Bold off (reset all SGR (e.g. blink, underline)
#---[ Set Text Color, Foreground ]---------------------------------
BLACK="30"     # foreground black
RED="31"       # foreground red
GREEN="32"     # foreground green
YELLOW="33"    # foreground yellow
BLUE="34"      # foreground blue
MAG="35"       # foreground magenta (it's like fucia)
LBLUE="36"     # foreground light blue (cyan)
WHITE="37"     # foreground white (cyan)
#---[ Set Background Color ]---------------------------------------
BACKoff="40"   # background black
RBACK="41"     # background red
GBACK="42"     # background green
YBACK="43"     # background yellow
BBACK="41"     # background blue
MBACK="41"     # background magenta
LBACK="41"     # background light blue (cyan)
WBACK="41"     # background white
#---[ My Favorite Colors (terminate with ${Boff} ]-----------------
BRon="${CSI}${RED};${BOLD}m"
BGon="${CSI}${GREEN};${BOLD}m"
BYon="${CSI}${YELLOW};${BOLD}m"
BBon="${CSI}${BLUE};${BOLD}m"
BMon="${CSI}${MAG};${BOLD}m"
LBon="${CSI}${LBLUE};${BOLD}m"
BWon="${CSI}${WHITE};${BOLD}m"
Boff="${CSI}${SGRoff}m"          # Bold off (reset all SGR (e.g. blink, underline)
#---[ Cursor Movement Commands ]-----------------------------------
SCP()  # save the current cursor position
{ echo -en "${CSI}s" && return 0 || return 1; }
RCP()  # restore the cursor to the saved position
{ echo -en "${CSI}u" && return 0 || return 1; }
HCU()  # Hide the cursor (Note: the trailing character is lowercase L)
{ echo -en "${CSI}?25l" && return 0 || return 1; }
SCU()  # Show the cursor
{ echo -en "${CSI}?25h" && return 0 || return 1; }
HVP()  # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{
  local row col
  [ ! -z "$1" ] && row=$1 || row=1
  [ ! -z "$2" ] && col=$2 || col=1
  echo -en "${CSI}${row};${col}f" && return 0 || return 1
}
CUP()  # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{
  local row col
  [ ! -z "$1" ] && row=$1 || row=1
  [ ! -z "$2" ] && col=$2 || col=1
  echo -en "${CSI}${row};${col}H" && return 0 || return 1
}
CLR()  # Clear the screen
{ echo -en "${CSI}2J" && return 0 || return 1; }
CUU()  # Move the cursor up ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} + 1 ))"A" && return 0 || return 1; }
CUD()  # Move the cursor down ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} - 1 ))"B" && return 0 || return 1; }
CUF()  # Move the cursor forward ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} ))"C" && return 0 || return 1; }
CUB()  # Move the cursor back ($1 cells)
{ [ ! -z "$1" ] && reps=$1 || reps=1; echo -en "${CSI}"$(( ${reps} ))"D" && return 0 || return 1; }
CPR()  # Report the current position (row, col) of the cursor [tip: hit return again]
{ perl -e '$/ = "R";' -e 'print "\033[6n";my $x=<STDIN>;my($n, $m)=$x=~m/(\d+)\;(\d+)/;print "Col: $m, Row: $n\n";'; }

# ---[ common function blocks ]------------------------------------------

checkroot()     # Run as root, of course.
{
  if [ "$UID" -ne "$ROOT_UID" ]; then E_message "${E_NOTROOT}"; echo; exit 1; else return 0; fi
}

message()       # echo a simply formatted message (arg $1) to the screen
{ echo -e "${BGon}*${Boff} ${1}" && return 0 || return 1; }

E_message()     # echo a simply formatted error message (arg $1) to the screen
{ echo -e "${BRon}*${Boff} ${1}" && return 0 || return 1; }

repeat()        # output a repeated string of character (arg $1) of length (arg $2)
{
  local i thing limit
  thing="$1"; limit=$2; out_str=""; i=0
  while [ $i -lt $limit ]; do out_str="${out_str}${thing}"; let "i++"; done
  echo -en "$out_str" && return 0 || return 1
}

termwidth()     # calculate and output the width of the terminal
{ echo -n $(stty size | sed 's/[0-9]* *//') && return 0 || return 1; }

termheight()    # calculate and output the height of the terminal
{ echo -n $(stty size | cut -d' ' -f1) && return 0 || return 1; }

separator()     # draw a horizontal line with a simple title (arg $1) and preface (arg $2)
{
  # to facilitate separation of portions of the output of various scripts
  # include a title preface (arg $2 or $(hostname) if $2 is not provided
  local msg preface msg_len
  [ ! -z "$2" ] && preface="$2" || preface=$(hostname)
  msg="${BYon}---[${BRon} $preface ${LBon}$1 ${BYon}]"
  msg_len=$(( ${#msg} - $(( ${#BYon} + ${#BRon} + ${#BBon} + ${#BYon} + ${#Boff} )) ))
  echo -en "$msg" && \
  echo -n $(repeat "-" $(( $(termwidth) - $(( $msg_len + ${#Boff} )) )) ) && echo -e ${Boff} && \
  return 0 || return 1
}

right_status()  # output a boolean status ($1) at the right margin
{
  # test with:
  #    echo -n "j" 2>/dev/null ; right_status $?
  #    ecko -n "j" 2>/dev/null ; right_status $?
  local status msg lpad rpad
  status=$1
  if [ $status -eq 0 ]; then
    msg="${BGon}Ok${Boff}"; lpad=2; rpad=2
  else
    msg="${BRon}Fail${Boff}"; lpad=1; rpad=1
  fi
  msg="${BBon}[$(repeat ' ' $lpad)${msg}$(repeat ' ' $rpad)${BBon}]${Boff}"
  msg_len=$(( ${#msg} - $(( ${#BGon} + $(( ${#BBon} * 2 )) + $(( ${#Boff} * 2 )) )) ))
  # first find a reference point by returning to the beginning of the line, *then*
  #   use the cursor forward command defined above to move to the position calculated using
  #   the terminal width function defined above, and print the message at the right margin
  echo -en "\r" && \
  CUF $(( $(termwidth) - $msg_len -1 )) && \
  echo -e "$msg" && \
  return 0 || return 1
}

countdown()     # output text message (arg $2, optional), and count-down seconds (arg $1)
{
  # special note: use base#number notation with prefix 10# to ensure interpretation as base 10
  # store current minutes and seconds
  min=10#$(date +%M) ; sec=10#$(date +%S)
  wait_time=10#60  #default = 1 minute
  [[ ! -z $1 ]] && wait_time="10#${1}"
  # if wait time is greater than 60 seconds, convert to minutes and seconds, else calculate it
  if [[ "${wait_time}" -ge "60" ]]
  then
    wait_min=$(( ${wait_time} / 60 ))  ;  wait_sec=$(( ${wait_time} % 60 ))
  else
    wait_min=10#0  ;  wait_sec=${wait_time}
  fi
  tgt_min="$(( ${min} + ${wait_min} ))"  ;  tgt_sec="$(( ${sec} + ${wait_sec} ))"
  if [[ "${tgt_sec}" -ge "60" ]]
  then
    tgt_min="$(( ${tgt_min} + 1 ))"  ; tgt_sec="$(( ${tgt_sec} % 60 ))"
  fi
  min="$(date +%M)"  ;  sec="$(date +%S)"
  rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
  # default message is "Pausing, ", else get from arg $2
  [[ ! -z $2 ]] && wait_msg="$2" || wait_msg="Pausing,"
  while [[ "${rem}" -gt "0" ]]
  do
    echo -en "\r${wait_msg} Time: "$(date +%H:%M:%S)
    sleep 0.1
    min="10#$(date +%M)"  ;  sec="10#$(date +%S)"
    rem="$(( $(( $(( ${tgt_min} * 60 )) + ${tgt_sec} )) - $(( $(( ${min} * 60 )) + ${sec} )) ))"
    echo -n "    $rem seconds left..."
  done
  echo

  return 0
}

sh_countdown()  # count-down seconds (arg $1)
{
  # special note: bb sh cannot use base#number notation with prefix 10# to ensure interpretation as base 10
  if [[ ! -z $1 ]]
  then
    rem_time="${1}"
  else
    message "no argument given, defaulting to 30 seconds"
    rem_time=30
  fi

  # execute countdown
  while [[ "${rem_time}" -gt "0" ]]
  do
    [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
    echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
    sleep 1
    let "rem_time--"
  done
  [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
  echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
  echo

  return 0
}

progress()      # display an arrow depicting progress (visualize $1 of $2 steps complete)
{
  [ $# -ne 2 ] && E_message "${BRon}Error - two arguments required (${BYon}step ${BRon}and ${BYon}number_of_steps${BRon})${Boff}"
  step=$1; number_of_steps=$2
  #---[ user configurable variables ]---------------------------------------------------------------------------------------------
  margin=10; marker="-"
  #---[ analytically determined variables ]---------------------------------------------------------------------------------------
  range=$(( $(termwidth) - 3 - $(( $margin * 2 )) ))   # the -3 accounts for the two brackets (|) and the arrow head (>)
  myprogress=$(( $range * $step / $number_of_steps ))    # this is how many $marker to draw to represent a single step of progress
  start=$(($margin + 1)); end=$(( $(termwidth) - $margin -1 ))
  myrow=$(termheight)
  startofline=$(($start +1))
  [ $step -lt $number_of_steps ] && endofline=$(($startofline + $myprogress)) || endofline=$(($end - 2))
  lengthofline=$(($endofline - $startofline + 1))
  percent=$((100 * $step / $number_of_steps))
  middlestart=$(( $(( $(termwidth) / 2 )) - $(( ${#percent} / 2 )) - 4 ))
  if [ $percent -ge 90 ]; then pct_color=${BGon}; else
  if [ $percent -lt 70 ]; then pct_color=${BRon}; else pct_color=${BYon}; fi; fi
  #---/ action: move to start, draw "|", draw line and ">", move to end and draw "|",
  #     move middle, show percent, return to original position /------------------------------------------------------------------
  SCP; CUP $myrow $start; echo -en "|"
  repeat $marker $lengthofline; echo -en ">"
  CUP $myrow $end; echo -en "|"
  CUP $myrow $middlestart; echo -en "( ${pct_color}$percent%${Boff} )"; RCP
}

summarize_me()  # list contents of this script header (employ me with "source" or ".")
{
  echo
  separator "script_header_brendlefly-$BUILD | content summary" && \
  message "This script header defines some ${BYon}common variables${Boff} for" && \
  message "  use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}" && \
  message "  ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and" && \
  message "  ${BYon}cursor${Boff} movement in my scripts, and it provides a number of" && \
  message "  useful ${BGon}functions${Boff}, for some routine tasks, as described below\n" && \
  grep "()" /usr/local/sbin/script_header_brendlefly | grep -v "grep" && echo && \
  sh_countdown 6 && \
  echo -en "\nFinishing with status of summarization --->" ; right_status $?

  return 0
}
