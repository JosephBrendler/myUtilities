#!/bin/sh
#
# /usr/src/initramfs/init
# Joe Brendler   28 Feb 2008 (most reacently revised 02 January 2024)
#
#  for version history and "credits", see accompanying file "historical_notes"
#

#### ***** for testing, when ready, move still-testing functions to validated_functions_header ***** ---------
# and remove the sourcing of testing_functions_header (below)
###----******************************************************************************************************

# make my usual functions and formatting "shortcuts" available
echo -n "sourcing /script_header_brendlefly ..."
source /script_header_brendlefly
right_status $? || echo "sourcing failed"
sleep .5

#----[ initialize additional global variables ]--------------------------------------------------
separator "initializing" "initramfs-$BUILD"
my_variables="unlock_method CMDLINE \
  init_passdevice init_passdevice_fs root_volume root_fs usr_volume usr_fs \
  VERBOSE verbosity unlock_method\
"
for x in ${my_variables}
do
	echo -n "initializing $x ..."
	cmd="$x=''"
	eval $cmd
	right_status $? || echo "$x initialization failed"
done
echo
# set defai;t verbosity - b/c we must have these assigned,
#  just in case neither in init.conf nor cmdline does it
VERBOSE=$TRUE; verbosity=2

#----[ reassign local variables with values from config files ]----------------------------------
# source the BUILD number generated by the make_sources.sh script,
d_message_n "sourcing /BUILD ..." 1
source /BUILD
right_status $? || echo "sourcing failed"
sleep .5

# source variables assigned in init.conf. Note cmdline may override root=, usr=, verbosity=
d_message_n "sourcing /init.conf ..." 1
source /init.conf
right_status $? || echo "sourcing failed"
sleep .5
[ $verbosity -gt 0 ] && VERBOSE=$TRUE || VERBOSE=$FALSE
root_volume="${init_root_volume}"
usr_volume="${init_usr_volume}"
echo

#----[ display separator to mark start of script ]-----------------------------------------------
separator "Running /init" "initramfs-$BUILD"

#----[ Define functions local to initramfs ]-----------------------------------------------------

d_message_n "sourcing /validated_functions_header ..." 1
source /validated_functions_header
right_status $? || echo "sourcing failed"

#### ***** for testing, when ready, move still-testing functions to validated_functions_header ***** ---------
d_message_n "sourcing /testing_functions_header ..." 1
source /testing_functions_header
right_status $? || echo "sourcing failed"

rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    echo; separator "${BRon}${1} - Dropping to a shell...${Boff}" "initramfs-$BUILD";
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
    exec /bin/sh;
}

right_most() {
    mystring=$1;
    #echo ${mystring:$((${#mystring}-1)):1};
    echo ${mystring} | rev | cut -c 1
    #echo ${a} | sed "s|${a:0:-1}||"
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # external variables: none
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    # As required, mount proc, devpts, and sys
    mount -t proc proc /proc;
    mount -t devtmpfs none /dev;
    [[ ! -d /dev/pts ]] && mkdir /dev/pts;
    mount -t devpts devpts /dev/pts;
    mount -t sysfs sysfs /sys;
    message "mounted /proc, /dev, /dev/pts, and /sys";

    # pause so kernel can finish identifying devices
    message "\n${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}";
    sh_countdown $(( ${init_wait} * 3 ));

    # instruct kernel to execute mdev whenever a device is added or removed
    sysctl -w kernel.hotplug=/sbin/mdev;

    # seed /dev/ with all the device nodes that were created while the system was booting
    mdev -s || E_message ${BRon}"mdev failed to start"${Boff};
}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
message "Waiting for normal trailing kernel output ..."
sh_countdown $((${init_wait} * 5))

# start mini-udev (mdev) and wait long enough for devices to be recognized
message "Starting mini udev ..."
mini_udev && message "mdev started" && sh_countdown $(($init_mdev_wait))

CMDLINE="$(cat /proc/cmdline)"
process_cmdline
[ $verbosity -gt 0 ] && VERBOSE=$TRUE || VERBOSE=$FALSE

# validate root device
validate_volume root_volume
# validate usr device
validate_volume usr_volume

display_config
sh_countdown $(($init_wait * 3))
[ $verbosity -gt 3 ] && sh_countdown $(( $init_wait * 3 ))

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

select_keying_device_keying_method

# echo to console to confirm attempt to unlock HDs
separator "Unlocking encrypted Drive(s)" "initramfs-$BUILD"
# call function to unlock HD(s)
unlock_devices ${unlock_method}

[ $verbosity -gt 3 ] && sh_countdown $(($init_wait * 3))

# access the root and usr logical volumes (among others), and show what we unlocke
access_logical_volumes

separator "Switching to /newroot, mounted on encrypted volume [$root_volume] " "initramfs-$BUILD"
d_message "-  Will continue with /sbin/init" 1
[[ ! -z $CMDLINE ]] || d_message " -  using cmdline: ${CMDLINE}" 1

# boot the real thing or exit to rescue shell if not locked down
exec /bin/busybox switch_root /newroot /sbin/init ${CMDLINE} || \
    ( msg="failed to mount root volume" ; E_message "$msg" ; [[ "$init_lock_down" = "no" ]] && rescue_shell "Failed to pivot root" )

message "General failure, shutting down for security reasons"
sh_countdown $(($init_wait * 3))
shutdown -hP now
