#!/bin/sh
#
# /usr/src/initramfs/init
# Joe Brendler   28 Feb 2008 (most reacently revised 02 January 2024)
#
#  for version history and "credits", see accompanying file "historical_notes"
#

#### ***** for testing, when ready, move still-testing functions to validated_functions_header ***** ---------
# and remove the sourcing of testing_functions_header (below)
###----******************************************************************************************************

# make my usual functions and formatting "shortcuts" available
echo -n "sourcing /script_header_brendlefly ..."
source /script_header_brendlefly
right_status $? || echo "sourcing failed"
sleep .5

#----[ initialize additional global variables ]--------------------------------------------------
separator "initializing" "initramfs-$BUILD"

# initialize these variables to '' to establish them as globals
#   remember '' evaluates as $FALSE in logical test
var_list="BUILD \
init_mdev_wait \
init_wait \
init_keyfile \
unlock_method\
init_passdevice_list \
init_passdevice_mount_point \
init_passdevice_volume \
init_passdevice_fs \
init_lock_down \
unlock_method \
root_volume \
root_fs \
usr_volume \
usr_fs \
CMDLINE \
VERBOSE \
verbosity \
init_config_title \
"
# PATH -- display, don't initialize
for x in ${var_list}
do
	echo -n "initializing $x ..."
	cmd="$x=''"
	eval $cmd
	right_status $? || echo "$x initialization failed"
done
echo
# set defai;t verbosity - b/c we must have these assigned,
#  just in case neither in init.conf nor cmdline does it
VERBOSE=$TRUE; verbosity=2

#----[ reassign variables with values from config files ]----------------------------------
# source the BUILD number generated by the make_sources.sh script,
d_message_n "sourcing /BUILD ..." 1
source /BUILD
right_status $? || echo "sourcing failed"
sleep .5

# source variables assigned in init.conf. Note cmdline may override root=, usr=, verbosity=
d_message_n "sourcing /init.conf ..." 1
source /init.conf
right_status $? || echo "sourcing failed"
sleep .5
[[ $verbosity -gt 0 ]] && VERBOSE=$TRUE || VERBOSE=$FALSE
[[ ${#init_root_volume} -ne 0 ]] && root_volume="${init_root_volume}"
[[ ${#init_usr_volume} -ne 0 ]]  && usr_volume="${init_usr_volume}"
echo

#----[ display separator to mark start of script ]-----------------------------------------------
separator "Running /init" "initramfs-$BUILD"

#----[ source functions local to initramfs ]-----------------------------------------------------
### *** for testing, when ready, move still-testing functions to validated_functions_header **---
d_message_n "sourcing /testing_functions_header ..." 1
source /testing_functions_header
right_status $? || echo "sourcing failed"

# note: in the real init script, we MUST source validated_functions_header second, in order to
#   override testing-only-modified functions also present in testing_functions_header
#   (in the testing init script (ash.temp) it is the other way around)
d_message_n "sourcing /validated_functions_header ..." 1
source /validated_functions_header
right_status $? || echo "sourcing failed"

# display initial config of variables available
# (must source display_config function first)
var_list="BUILD \
init_mdev_wait \
init_wait \
init_keyfile \
init_passdevice_mount_point \
init_lock_down \
root_volume \
usr_volume \
VERBOSE \
verbosity \
init_passdevice_list \
CMDLINE \
PATH \
"
#unlock_method \
#init_passdevice_volume \
#init_passdevice_fs \
#root_fs \
#usr_fs \
# PATH -- display, don't initialize
init_config_title="preliminary configuration"
display_config ${var_list}

#----[ Define functions local to initramfs ]-----------------------------------------------------

rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    echo; separator "${BRon}${1} - Dropping to a shell...${Boff}" "initramfs-$BUILD";
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
    exec /bin/sh;
}

right_most() {
    mystring=$1;
    #echo ${mystring:$((${#mystring}-1)):1};
    echo ${mystring} | rev | cut -c 1
    #echo ${a} | sed "s|${a:0:-1}||"
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # external variables: none
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    # As required, mount proc, devpts, and sys
    mount -t proc proc /proc;
    mount -t devtmpfs none /dev;
    [[ ! -d /dev/pts ]] && mkdir /dev/pts;
    mount -t devpts devpts /dev/pts;
    mount -t sysfs sysfs /sys;
    message "mounted /proc, /dev, /dev/pts, and /sys";

    # pause so kernel can finish identifying devices
    message "\n${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}";
    sh_countdown $(( ${init_wait} * 3 ));

    # instruct kernel to execute mdev whenever a device is added or removed
    sysctl -w kernel.hotplug=/sbin/mdev;

    # seed /dev/ with all the device nodes that were created while the system was booting
    mdev -s || E_message ${BRon}"mdev failed to start"${Boff};
}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
message "Waiting for normal trailing kernel output ..."
sh_countdown $((${init_wait} * 5))

# start mini-udev (mdev) and wait long enough for devices to be recognized
message "Starting mini udev ..."
mini_udev && message "mdev started" && sh_countdown $(($init_mdev_wait))

CMDLINE="$(cat /proc/cmdline)"
process_cmdline
[[ $verbosity -gt 0 ]] && VERBOSE=$TRUE || VERBOSE=$FALSE

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

select_keying_device_and_unlock_method

# echo to console to confirm attempt to unlock HDs
separator "Unlocking encrypted Drive(s)" "initramfs-$BUILD"
# call function to unlock HD(s)
unlock_devices ${unlock_method}

# done with all luks devices; ok to un-mount keying device now
if [[ -b ${init_passdevice_mount_point} ]]; then
    message_n "Un-mounting keying device ..."
    umount ${init_passdevice_mount_point}; right_status $?
fi

# make lvm logical volumes available
/sbin/vgscan
/sbin/vgchange -a y
sh_countdown $(( $init_wait * 3 ))

# assign root and usr volume names (if not already done)
separator "assigning and validating root and usr volumes" "initramfs-$BUILD"
assign_volume "root_volume"
assign_volume "usr_volume"

# validate root and usr device and assign fs
#  cannot do this until after the volume is unlocked and the volume is assigned
#  need to pass string name arg so function can make fs assignment
validate_volume_and_assign_fs "root_volume"
validate_volume_and_assign_fs "usr_volume"

# display config - after volumes uinlocked and root/usr fs obtained
var_list="BUILD \
init_mdev_wait \
init_wait \
init_passdevice_volume \
init_passdevice_fs \
unlock_method \
init_keyfile \
init_passdevice_mount_point \
init_lock_down \
root_volume \
root_fs \
usr_volume \
usr_fs \
VERBOSE \
verbosity \
init_passdevice_list \
CMDLINE \
PATH \
"
# PATH -- display, don't initialize
init_config_title="mature configuration"
display_config ${var_list}

[[ $verbosity -gt 4 ]] && sh_countdown $(( $init_wait * 3 ))

# access the root and usr logical volumes (among others), and show what we unlocke
display_logical_volumes

# mount_new_root_and_prepare_to_switch_root
mount_new_root_and_prepare_to_switch_root

separator "Switching to /newroot, mounted on encrypted volume [${root_volume}]" "initramfs-$BUILD"
d_message "  -  Will continue with /sbin/init" 1
[[ ${#CMDLINE} -ne 0 ]] && d_message "  -  using cmdline: ${CMDLINE}" 1
echo

# boot the real thing or exit to rescue shell if not locked down
exec /bin/busybox switch_root /newroot /sbin/init ${CMDLINE} || \
    ( msg="failed to mount root volume" ; E_message "$msg" ; [[ ${init_lock_down} ]] && rescue_shell "Failed to pivot root" )

message "General failure, shutting down for security reasons"
sh_countdown $(($init_wait * 3))
shutdown -hP now
