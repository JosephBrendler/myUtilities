#!/bin/sh
#
# /usr/src/initramfs/init
# Joe Brendler   28 Feb 2008
#  for version history and "credits", see accompanying file "historical_notes"
#

# make my usual functions and formatting "shortcuts" available
echo -n "sourcing /script_header_brendlefly ..."
source /script_header_brendlefly
right_status $? || echo "sourcing failed"
sleep .5

#----[ initialize additional global variables ]--------------------------------------------------
for x in init_passdevice init_unlock_method CMDLINE root_volume usr_volume VERBOSE verbosity
do
	echo -n "initializing $x ..."
	cmd="$x=''"
	eval $cmd
	right_status $? || echo "$x initialization failed"
done
echo

#----[ Define local variables ]-------------------------------------------------------------------
# source the BUILD number generated by the make_sources.sh script,
echo -n "sourcing /BUILD ..."
source /BUILD
right_status $? || echo "sourcing failed"
sleep .5

echo -n "sourcing /init.conf ..."
source /init.conf
right_status $? || echo "sourcing failed"
sleep .5
echo

#----[ display separator to mark start of script ]-----------------------------------------------
separator "Running /init" "initramfs-$BUILD"

#----[ Define functions local to initramfs ]-----------------------------------------------------
rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    echo; separator "${BRon}${1} - Dropping to a shell...${Boff}" "initramfs-$BUILD";
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
    exec /bin/sh;
}

display_config() {
    # display variable assignments sourced from init.conf; do not show password
    echo; separator "Init Configuration:";
    longest=0
    for line in $(grep -e '^init' init.conf | grep -v '\\')
    do
        key="$(echo $(echo $line) | cut -d'=' -f1)"
        [ ${#key} -gt ${longest} ] && longest=${#key}
    done
    d_echo "longest: ${longest}" 3
    for line in $(grep -e '^init' init.conf | grep -v '\\')
    do
        key="$(echo $(echo $line) | cut -d'=' -f1)"
        eval "val=\$${key}"
        # always pad variable name with at least two dots before colon
        dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
        echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    done
    echo
    key="BUILD"; val="${BUILD}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    key="VERBOSE"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    echo -e "${LBon}${key}${dotpad}:${Boff} $(status_color ${VERBOSE})$(TrueFalse ${VERBOSE})${Boff}"
    key="verbosity"; val="${verbosity}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    key="root_volume"; val="${root_volume}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    key="usr_volume"; val="${usr_volume}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    echo
    key="CMDLINE"; val="${CMDLINE}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    [ $verbosity -ge 3 ] && echo -e "${LBon}${key}${dotpad}:${Boff} ${val}"
    key="PATH"; val="${PATH}"
    dotpad="$(repeat "." $(( ${longest} - ${#key} + 2 )))"
    [ $verbosity -ge 3 ] && echo && echo -e "${LBon}${key}${dotpad}:${Boff} ${val}" && echo
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # external variables: none
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    # As required, mount proc, devpts, and sys
    mount -t proc proc /proc;
    mount -t devtmpfs none /dev;
    [[ ! -d /dev/pts ]] && mkdir /dev/pts;
    mount -t devpts devpts /dev/pts;
    mount -t sysfs sysfs /sys;
    message "mounted /proc, /dev, /dev/pts, and /sys";

    # pause so kernel can finish identifying devices
    message "\n${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}";
    sh_countdown $(( ${init_wait} * 3 ));

    # instruct kernel to execute mdev whenever a device is added or removed
    sysctl -w kernel.hotplug=/sbin/mdev;

    # seed /dev/ with all the device nodes that were created while the system was booting
    mdev -s || E_message ${BRon}"mdev failed to start"${Boff};
}

process_cmdline() {
	echo "processing cmdline ..."
    for entry in ${CMDLINE}
    do
		case $(echo ${entry} | cut -d'=' -f1) in
			"verbosity" )
				export ${entry} && echo "initramfs assigned [${entry}]" || echo "export failed"
			;;
			"root" )
				value="$(echo ${entry} | cut -d'=' -f2)"
				export root_volume="${value}" && echo "initramfs assigned [root_volume=${value}" || echo "export failed"
			;;
			"usr" )
				value="$(echo ${entry} | cut -d'=' -f2)"
				export usr_volume="${value}" && echo "initramfs assigned [usr_volume=${value}" || echo "export failed"
			;;
			* )
				d_message "cmdline entry [${entry}] ignored by initrafms" 2
			;;
		esac
    done
}
#############################################################################

unlock_devices() {
    # for version 4.x and beyond, this is a complete re-write of the unlocking procedure.
    # The unlock method has already been determined, and the script will now "scan" for LUKS
    # devices and automatically use that method to unlock all of them
    # arguments: method
    local method=$1;
    local device="";
    local line="";

    [[ "$method" = "prompt" ]] && read -s -p "Enter your LUKS passphrase: " pass && echo;

    for device in $(blkid | grep -i luks | cut -d':' -f1)
    do
        # use cryptsetup luksOpen to open each device /dev/sdxn with corresponding name edxn
        # 27 Oct 23 - generalize to scsi or nvme devices (sdXX or nvmeXnXpX)
        bn=$(basename ${device})
        case ${bn:0:2} in
          "sd" ) # scsi device
            edev=$(echo ${bn} | sed 's/^s/e/')
            ;;
          "nv" ) # nvme device
            edev=$(echo ${bn} | sed 's/^nvme/ev/' | sed 's/[np]//g')
            ;;
          "mm" ) # mmc device
            edev=$(echo ${bn} | sed 's/^mmcblk/em/' | sed 's/p//g')
            ;;
          *    ) # tbd
            echo "Error: bad luks device name [$device]"
            ;;
        esac
        line="${device} ${edev}"
        case "$method" in
            "prompt")
                echo "echo $pass | /sbin/cryptsetup luksOpen $line" > mycmd;
                chmod 777 mycmd;
                d_message "about to execute from file ./mycmd:" 3 && \
                    message "[ $(cat mycmd) ]" && sh_countdown $(( $init_wait * 3 ));
                ./mycmd;
                if [ $? -eq 0 ]
                then
                    message "Unlocked $line with passphrase provided";
                else
                    E_message "${BRon}mycmd failed. Dropping to a shell. ${Boff}";
                    sh_countdown $(( $init_wait * 5 ));
                    [[ "$init_lock_down" = "no" ]] && rescue_shell;
                fi;
                [ $verbosity -gt 2 ] && sh_countdown $(( $init_wait * 3 ));
                shred mycmd;
                ;;
            "key")
                # passdevice already mounted,
                # Use cryptsetup option for key file -d <mount_point><keyfile> and -S <key slot #>
                # unmount the passdevice when we are done with it
                message "About to execute command [ cryptsetup -d ${init_passdevice_mount_point}${init_keyfile} -S 1 luksOpen $line ]";
                cryptsetup -d $(echo "${init_passdevice_mount_point}${init_keyfile}") -S 1 luksOpen $line;
                if [ $? -eq 0 ]
                then  # cryptsetup luksOpen with key worked
                    message "Unlocked $line with key found at $(echo ${init_passdevice_mount_point}${init_keyfile})";
                else  # cryptsetup luksOpen with key failed
                    E_message $BRon"Error: Could not unlock ${BYon}$line ${BRon}with key found at ${BMon}$(echo ${init_passdevice_mount_point}${init_keyfile})"$Boff;
                    E_message $BRon"Dropping to a shell"$Boff;
                    sh_countdown $(( $init_wait * 5 ));
                    [[ "$init_lock_down" = "no" ]] && rescue_shell;
                fi;
                [ $verbosity -gt 2 ] && sh_countdown $(( $init_wait * 3 ));
                ;;
        esac
    done
}

type_of_key() {
    # return on stdout (by echo) the likely type of candidate key device presented as str arg $1
    # i.e. devicename (1st char = '/'), uuid (matches pattern), label otherwise
    # check uuid for ext or vfat uuid pattern only (see also /usr/local/sbin/test_uuid)
    local candidate="$1";
    local type="unknown";
    local result
# problem: I discovered the =~ operator is not available in busybox
#    local ext_pattern='^\{?[A-F0-9a-f]{8}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{4}-[A-F0-9a-f]{12}\}?$'
#    local vfat_pattern='^\{?[A-F0-9a-f]{4}-[A-F0-9a-f]{4}\}?$'
#    local ntfs_pattern='^\{?[A-F0-9a-f]{16}\}?$'
#    local lvm2_pattern='^\{?[A-Z0-9a-z]{6}-[A-Z0-9a-z]{4}-[A-Z0-9a-z]{4}-[A-Z0-9a-z]{4}-[A-Z0-9a-z]{4}-[A-Z0-9a-z]{4}-[A-Z0-9a-z]{6}\}?$'
#    local partition_pattern='^\{?[A-Z0-9a-z]{8}-[A-Z0-9a-z]{2}\}?$'
    local h="[0-9a-f]"
    local H="[A-F0-9a-f]"
    local z="[A-Z0-9a-z]"
    local ext_pattern="$(repeat $h 8)-$(repeat $h 4)-$(repeat $h 4)-$(repeat $h 4)-$(repeat $h 12)"
    local vfat_pattern="$(repeat $H 4)-$(repeat $H 4)"
    local ntfs_pattern="$(repeat $H 4)"
    local lvm2_pattern="$(repeat $z 6)-$(repeat $z 4)-$(repeat $z 4)-$(repeat $z 4)-$(repeat $z 4)-$(repeat $z 4)-$(repeat $z 6)"
    local partition_pattern="$(repeat $h 8)-$(repeat $h 2)"

    if [ "${candidate:0:1}" == "/" ]
    then type="name";
    elif expr "$candidate" : "$ext_pattern" >/dev/null || expr "$candidate" : "$vfat_pattern" >/dev/null
    then type="uuid";
    else type="label";
    fi
    echo "${type}";
}

id_passdevice() {
    # assign an answer to the global configuration variable init_passdevice
    #   and return true or false according to validity type/name device specification
    my_candidate="$1"
    dev_t="$2"
    local int OK=1;   # def'n: 0 is logical true; any other int = false
    d_message "Debug: id_passdevice() \$1 = [ $1 ]; \$2 = [ $2 ]" 3
    d_message "${BWon}Debug: id_passdevice() ${BMon}arg1 = [ $my_candidate ]; ${LBon}arg2 = [ $dev_type ]${Boff}" 2
    case "${dev_t}" in
        "name")
            d_message "In case [name]; assigning" 3;
            init_passdevice="${my_candidate}"; OK=0;
            d_message "assigned: ${init_passdevice}" 2;
            [ $verbosity -gt 2 ] && sh_countdown 2;
            ;;
        "uuid")
            d_message "In case [uuid]; using findfs" 3;
            init_passdevice="$(findfs UUID=${my_candidate})"; OK=0;
            d_message "found: ${init_passdevice}" 2;
            [ $verbosity -gt 2 ] && sh_countdown 2;
            ;;
        "label")
            d_message "In case [label]; using findfs" 3;
            init_passdevice="$(findfs LABEL=${my_candidate})"; OK=0;
            d_message "found: ${init_passdevice}" 2;
            [ $verbosity -gt 2 ] && sh_countdown 2;
            ;;
        *)
            # invalid or error
            init_passdevice="InvalidDevice"; OK=1;
            ;;
    esac

    d_message "Debug: id_passdevice() just set init_passdevice = ${BMon}[ $init_passdevice ]${Boff}" 3
    d_message "Debug: id_passdevice() is about to return OK = [ $OK ]" 3
    [ $verbosity -gt 2 ] && sh_countdown 2

    #return the result int 0 for true, int 1 for false
    return $OK
}

right_most() {
    mystring=$1;
    #echo ${mystring:$((${#mystring}-1)):1};
	echo ${mystring} | rev | cut -c 1
	#echo ${a} | sed "s|${a:0:-1}||"
}


#############################################################################
select_device() {
    # go through the list of devices presented as argv -- select the first one that
    #   has a valid type, actually exists, mounts successfully, and contains a key, else fail
    #   upon exhaustion of the list
    local VALID=$FALSE;
    local EXISTS=$FALSE;
    local HAS_KEY=$FALSE;
    local dev_type="";
    local candidate_key_device="";
    local count=$#;

    while [ $count -gt 0 ] && [ ! ${HAS_KEY} ]
    do
        candidate_key_device=$1
        VALID=$FALSE; EXISTS=$FALSE
#        # determine the validity of the type and name of the candidate passdevice
        dev_type=$(type_of_key ${candidate_key_device})
        id_passdevice ${candidate_key_device} ${dev_type}; answer=$?;
        [ $answer -eq 0 ] && VALID=$TRUE || VALID=$FALSE;
#        # note that if VALID returns true, the id_passdevice procedure will have set the global config variable init_passdevice
        echo -en "Checking validity of specified device [ ${candidate_key_device} ] of type [ ${dev_type} ]" ; \
        right_status $VALID;
        d_message "Debug: dev_type = [ $dev_type ]" 3;
        d_message "Debug: candidate_key_device = [ $candidate_key_device ]" 3;
        d_message "Debug: id_passdevice() set init_passdevice = ${BMon}[ $init_passdevice ]${Boff}" 3;
        d_message "Debug: VALID = [ $(status_color ${VALID})$(TrueFalse ${VALID})${Boff} ]" 3;
        if [[ ${VALID} ]];
        then
            message "Found candidate key device ${LBon}${candidate_key_device}${Boff} of type ${LBon}${dev_type}${Boff} to be ${BGon}valid${Boff}";
            if [ "${dev_type}" == "uuid" ] || [ "${dev_type}" == "label" ]
            then
                message "${BGon}***${Boff} findfs returned the corresponding device name: ${LBon}${init_passdevice}${Boff}";
            fi
            # determine if this valid device acutally exists and is a block device
            echo -en "Checking for device with ${dev_type} [ ${BMon}${candidate_key_device}${Boff} ]";
            # Careful! in the busybox ash shell, [ -b "" ] will return true
            #   (indicating the existence of a block device named by a null string
            # and [ -n "" ] will also return true, indicating non-zero length for a null string
            [ ! -z ${init_passdevice} ] && [ -b ${init_passdevice} ] && EXISTS=$TRUE || EXISTS=$FALSE;
            right_status $EXISTS;
            d_message "Debug: Result -- EXISTS = [ $(status_color ${EXISTS})$(TrueFalse ${EXISTS})${Boff} ]" 3;
            ### these because I am still trying to figure out why coreutils blkid and findfs do not seem to work
            ###   for **vfat** usb_storage under busybox shell (despite they are coreutils, not busybox)
            d_message "\nDebug: about to run command: blkid | grep ${init_passdevice_fs}" 3;
            [ $verbosity -gt 3 ] && blkid | grep ${init_passdevice_fs};
            d_message "\nDebug: about to run command: lsblk -l --output 'NAME,KNAME,MAJ:MIN,FSTYPE,LABEL,UUID,MODEL,SIZE,TYPE,REV,VENDOR' | grep -v dm- ";
            [ $verbosity -gt 3 ] && lsblk -l --output 'NAME,KNAME,MAJ:MIN,FSTYPE,LABEL,UUID,MODEL,SIZE,TYPE,REV,VENDOR' | grep -v dm- ;
            [ $verbosity -gt 3 ] && sh_countdown $(( $init_wait * 3 ))

            if [ ${EXISTS} ]
            then
                # try to mount it. Note: we need the full keyfile path for the keyfile existence test
                # handle uncertain trailing / character...
                message "${BYon}Trying${Boff} mount -t ${BGon}${init_passdevice_fs} ${BMon}${init_passdevice} ${LBon}${init_passdevice_mount_point%/}/${Boff}";
                mount -t "${init_passdevice_fs}" "${init_passdevice}" "${init_passdevice_mount_point%/}/" && \
                    message "${BGon}Successfully mounted removable keying device: ${BMon}${init_passdevice} on ${LBon}${init_passdevice_mount_point%/}/${Boff}" || \
                    E_message "${BRon}Failed to mount removable keying device: ${BMon}${init_passdevice}${Boff} on ${LBon}${init_passdevice_mount_point%/}/${Boff}";
                # here's the actual keyfile existence check
                echo -en "Looking for keyfile";
                if [[ -e $(echo "${init_passdevice_mount_point%/}/${init_keyfile}") ]]
                then
                    HAS_KEY=$TRUE;
                else
                    HAS_KEY=$FALSE;
                fi
                right_status [ ${HAS_KEY} ];
            fi
        fi
 #       sh_countdown $(($init_wait * 3));
        d_message "Debug: Results for $candidate_key_device --" 3
        d_message "Debug: VALID =  [ $(status_color ${VALID})$(TrueFalse ${VALID})${Boff} ]" 3
        d_message "Debug: EXISTS = [ $(status_color ${EXISTS})$(TrueFalse ${EXISTS})${Boff} ]" 3
        d_message "Debug: HAS_KEY = [ $(status_color ${HAS_KEY})$(TrueFalse ${HAS_KEY})${Boff} ]" 3
        d_message "Debug: init_passdevice = ${BMon}[ $init_passdevice ]${Boff}" 3
        d_message "Debug: init_passdevice_mount_point = [ ${init_passdevice_mount_point%/}/ ]" 3
        [ $verbosity -gt 3 ] && sh_countdown $(( $init_wait * 3 ))

        # if not found, move on the the next one on the list; if found, then
        shift;
        count=$(($count - 1));
    done
    # to leave the loop above, I either --
    #    (a) found a valid extant device, mounted it and confirmed it contains a key (HAS_KEY is now "true"), or
    #    (b) exhausted the init_passdevice_list of devices authorized to be used and found none of them 
    #        on this system (HAS_KEY is still "false")
    if [ ${HAS_KEY} ]
    then
        init_unlock_method="key"
        message "$(echo ${init_passdevice_mount_point%/}/${init_keyfile}) exists - using automatic keying method...";
    else
        init_unlock_method="prompt"
        E_message $BRon"Keystore $(echo ${init_passdevice_mount_point%/}/${init_keyfile}) does not exist - reverting to prompt method..."$Boff;
    fi
    [ $verbosity -gt 3 ] && sh_countdown $(( $init_wait * 3 ))
}

select_device_and_keying_method() {
	d_message "checking for non-zero-length init_keyfile [ ${init_keyfile} ] and init_passdevice_list [ ${init_passdevice_list} ]" 2
	if [ ! -z "$init_keyfile" ] && [ ! -z "${init_passdevice_list}" ]
	then
    	# pause to give mdev a chance to recognize devices
	    echo -e "${BGon}*${Boff} Waiting ${init_mdev_wait} more seconds, per init.conf, to give mdev a chance to recognize hardware..."
	    sh_countdown $(($init_mdev_wait)); echo "Done"
	    select_device ${init_passdevice_list};
    	# note that if this succeded, it will have set init_unlock_method="key"
	    # and it will have set the global config variable "init_passdevice"
	else
	    init_unlock_method="prompt"
	fi
	d_message "Result: init_passdevice = ${BMon}[ $init_passdevice ]${Boff}" 2
	d_message "Result: init_unlock_method = [ $init_unlock_method ]" 2
	[ $verbosity -ge 3 ] && sh_countdown $(( $init_wait * 3 ))
}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
message "Waiting for normal trailing kernel output ..."
sh_countdown $((${init_wait} * 5))

# start mini-udev (mdev) and wait long enough for devices to be recognized
message "Starting mini udev ..."
mini_udev && message "mdev started" && sh_countdown $(($init_wait))

CMDLINE="$(cat /proc/cmdline)"
process_cmdline

display_config
sh_countdown $(($init_wait * 3))
[ $verbosity -gt 3 ] && sh_countdown $(( $init_wait * 3 ))

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

select_device_and_keying_method

# echo to console to confirm attempt to unlock HDs
separator "Unlocking encrypted Drive(s)" "initramfs-$BUILD"
# call function to unlock HD(s)
unlock_devices ${init_unlock_method}

[ $verbosity -gt 3 ] && sh_countdown $(($init_wait * 3))

separator "Accessing logical volumes" "initramfs-$BUILD"
# make lvm logical volumes available
/sbin/vgscan
/sbin/vgchange -a y
message_n "accessing root_volume: ${root_volume} ..."
if [ -b ${root_volume} ]
then
	right_status $TRUE
else
	right_status $FALSE
	message "looking in unlocked vg(s) ..."
	root_volume="/dev/mapper/$(lvs | awk '$1~/root/ {print $2"-"$1}')"
	message_n "accessing root_volume: ${root_volume} ..."
	[ -b ${root_volume} ] && right_status $?
fi
message_n "accessing usr_volume: ${usr_volume} ..."
if [ -b ${usr_volume} ]
then
	right_status $TRUE
else
	right_status $FALSE
	message "looking in unlocked vg(s) ..."
	usr_volume="/dev/mapper/$(lvs | awk '$1~/usr/ {print $2"-"$1}')"
	message_n "accessing usr_volume: ${usr_volume} ..."
	[ -b ${usr_volume} ] && right_status $?
fi

# show what we've found...
separator "The following volume groups are available" "initramfs-$BUILD"
/sbin/vgs
separator "The following volumes are available" "initramfs-$BUILD"
/sbin/lvs
sh_countdown $(($init_wait))

separator "Attempting to mount new root lvm..." "initramfs-$BUILD"
# if not yet available after above scan, keep scanning to make device nodes untill you succeed
d_message "Re-scanning, if needed ..." 1
while [[ ! -b $(echo "$root_volume") ]]
do
    d_message "re-verifying the existence of block device $root_volume" 2
    /sbin/vgscan --mknodes --ignorelockingfailure
done
d_message "$(color ${RED} ${BBACK} ${BOLD})running fsck.${init_root_fs} on $root_volume${Boff}" 1 && fsck.${init_root_fs} -p $root_volume
d_message "$(color ${RED} ${BBACK} ${BOLD})running fsck.${init_usr_fs} on $usr_volume${Boff}" 1 && fsck.${init_usr_fs} -p $usr_volume
sh_countdown $((2 * $init_wait))
# mount root - drop to shell if not locked down
# Note: assumes you have one and only one lvm volume which appropriately includes "root" in its name
mount -r -t ${init_root_fs} $root_volume /newroot || \
( msg="failed to mount root volume" ; E_message "$msg" ; [[ "$init_lock_down" = "no" ]] && rescue_shell "Failed to mount root volume" )
mount -t ${init_usr_fs} -o defaults,noatime $usr_volume /newroot/usr || \
( msg="failed to mount usr volume" ; E_message "$msg" ; [[ "$init_lock_down" = "no" ]] && rescue_shell "Failed to mount usr volume" )

separator "Mounts" "initramfs-$BUILD"
mount
sh_countdown $(($init_wait))

# clean up
umount /proc
umount /dev/pts
umount /dev
umount /sys

separator "Switching root to encrypted volume" "initramfs-$BUILD"
d_message "-  Will continue with /sbin/init" 1
[[ ! -z $CMDLINE ]] || d_message " -  using cmdline: ${CMDLINE}" 1
separator "Switching to /newroot mounted on $root_volume" "initramfs-$BUILD"

# boot the real thing or exit to rescue shell if not locked down
exec /bin/busybox switch_root /newroot /sbin/init ${CMDLINE} || \
    ( msg="failed to mount root volume" ; E_message "$msg" ; [[ "$init_lock_down" = "no" ]] && rescue_shell "Failed to pivot root" )

message "General failure, shutting down for security reasons"
sh_countdown $(($init_wait * 3))
shutdown -hP now
