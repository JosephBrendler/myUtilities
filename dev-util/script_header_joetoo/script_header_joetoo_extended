#!/bin/bash
#   script header with basic functions
# Author: joe brendler 26 Jan 2017
#         24 June 2025 - v1.0.0 moved to /usr/sbin/ and renamed/consolidated script_header_joetoo_extended
#
# NOTE: to use this header, you must first source the basic script_header_joetoo
#

# note: this header expects this to be assigned already
#script_header_installed_dir=/usr/sbin


#-----[ non-cli stuff ------------------------------------------------------------------------------------------------------

isnumeric() # wrapper for broadest determination
{ # @rule will over-ride the POSIX version of isnumeric if sourced afterwards
  isint "$1" || ishexint "$1" || isfloat_posix "$1" || isfloat_regex "$1"; }

isfloat() # deprecated (now a wrapper for isfloat_regex
{ isfloat_regex "$@"; }

isfloat_regex() # regex (non-POSIX) test if $1 is a floating point number; return true/false
{ inputstring="$1"
  if  [[ "$inputstring" =~ ^[+-]?([0-9]*\.)?[0-9]+([eE][+-]?[0-9]+)?$ ]] ; then
    return 0; else return 1; fi; }
# @usage_legacy isfloat_regex "input"
# @args $1: the string to be validated
# @ret 0 if valid float; 1 if not
# @rule supports scientific notation (e.g., 1.2e+10); requires Bash/Ksh/Zsh
# @note broader than isfloat_posix; will return true for integers (e.g., 123)
# @rule isfloat moved here due to ash-incompatibility (uses regex compare =~)

map()           # linearly map input number from input range to output range
{ # trap non-numeric input
! isfloat $1 && error_msg "invalid map_val for ${FUNCNAME[0]} [$1]" && return 1
! isfloat $2 && error_msg "invalid from_lower bound for ${FUNCNAME[0]} [$2]" && return 1
! isfloat $3 && error_msg "invalid from_upper bound for ${FUNCNAME[0]} [$3]" && return 1
! isfloat $4 && error_msg "invalid to_lower bound for ${FUNCNAME[0]} [$4]" && return 1
! isfloat $5 && error_msg "invalid to_upper bound for ${FUNCNAME[0]} [$5]" && return 1
[ ! -z "$6" ] && ! isfloat $6 && echo "invalid scale for ${FUNCNAME[0]} [$6]" && return 1
 map_val=$1 ; from_lower=$2 ; from_upper=$3 ; to_lower=$4 ; to_upper=$5
 scale=${6:-1} # Set default scale to 1 if not provided (number of digits after .)
# trap invalid map_val (not within input range) (( $(... | bc) )) for float #s
(( $(echo "$map_val < $from_lower" | bc -l) )) || \
    (( $(echo "$map_val > $from_upper" | bc -l) )) && \
    error_msg "invalid map_val [${map_val}], not w/in input range [${from_lower} - ${from_upper}]" && return 1
# trap invalid input or output ranges - leave this unless prohibiting "reverse mapping"
#[ $to_upper -lt $to_lower ] && error_msg "invalid input range [ $to_upper - $to_lower ]" && return 1
#[ $from_upper -lt $from_lower ] && error_msg "invalid input range [ $from_upper - $from_lower ]" && return 1
# initialize result variable
result=999999
# calculate scaling factor
 from_delta=$(echo "scale=$scale; $from_upper - $from_lower" | bc -l)
 to_delta=$(echo "scale=$scale; $to_upper - $to_lower" | bc -l) 
 from_offset=$(echo "scale=$scale; $map_val - $from_lower" | bc -l)   # how far (above from_lower) offest into from-range
 map_factor=$(echo "scale=$scale; $to_delta / $from_delta" | bc -l)
# ratio > 1 means scaling up to a "wider" range (even if lower numbers)
# ratio < 1 means scaling down to a "narrower" range (even if higher numbers)
# scale the input offset against the output range
 to_offset=$(echo "scale=$scale; $from_offset * $map_factor" | bc -l)
# now offset (above the to_lower bound) the scaled number into the output range
result=$(echo "scale=$scale; $to_lower + $to_offset" | bc -l)
return 0
}


#---[ RGB ]--------------------------------------------------------
#ToDo: experiment with rgb methods for color-setting
# NOTE: this might work in a Konsole or Gnome terminal, but not lxterminal!!
# see "well known" triplet values at https://en.wikipedia.org/wiki/ANSI_escape_code
#  RED=(205, 0, 0)
#  ESC[ ... 38;2;<r>;<g>;<b> ... m Select RGB foreground color
#  ESC[ ... 48;2;<r>;<g>;<b> ... m Select RGB background color
RGB_FG()    # echo esc seq color as RGB. (OK in Konsole/Gnome term, but not lxterminal)
{ local FG="38;2"; R=$1; G=$2; B=$3; echo -e "${CSI}${FG};${R};${G};${B}m" ; }
RGB_BG()    # echo esc seq color as RGB. (OK in Konsole/Gnome term, but not lxterminal)
{ local BG="48;2"; R=$1; G=$2; B=$3; echo -e "${CSI}${BG};${R};${G};${B}m" ; }

list_unused_disks()    # list block devices with no active mountpoint
{  # set TERMWIDTH now, or it would be an inappropriate use of io control
   # for stdin during while loop's redirection for "read line"
   TERMWIDTH=$(termwidth)
    # read every line of lsblk (NAME, TYPE, MOUNTPOINT columns)
    while read line ; do
        # use eval to interpret the -P pairs as variable assignments
        eval ${line}
        if [[ "${TYPE}" == "disk" ]] ; then
            # look for disks with no children (TYPE crypt, part, lvm) mounted
            candidate_name=$NAME ; candidate_type=$TYPE
            INUSE=$FALSE
            info_msg_n "checking ${candidate_type} ${candidate_name} ..."
            while read innerline; do
                eval ${innerline}
                if [[ ! -z ${MOUNTPOINTS} ]] || [[ ! -z "$(findmnt | grep ${NAME})" ]] ; then
                    INUSE=$TRUE
                fi
            done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS /dev/${candidate_name})
            if [[ ! $INUSE ]] ; then
                echo -en "${BGon}(not in use) ${BMon}/dev/${candidate_name}${Boff}"
                non-stty-right_status $TRUE
                lsblk /dev/${candidate_name} | sed 's|^|    |'
            else
                echo -en "${BRon}(in use)${Boff}"
                non-stty-right_status 1
            fi
        fi
    done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS)
    return 0
}

## parking this here until I figure out what I want to do with it
progress() # show progress arrow (visualize $1 of $2 steps complete)
{ # intended to be called in each iteration of some monitored process
  # e.g. # for x in $(seq 0 250); do progress $x 250; sleep .1; done
  [ $# -ne 2 ] && { error_msg "${BRon}Error: step and total required${Boff}"; return 1; }
  # use these common variables for width/height if they exist, else call function
  # (should exist already, if user called progress_init() first)
  _p_tw=${COLUMNS:-$(termwidth)}; _p_th=${LINES:-$(termheight)}
  _p_step="$1"; _p_total="${2:-100}"  # default to 100 steps
  _p_margin=$(( _p_tw / 4 ));         # margin at termidth / 4 to leave room for text
  _p_marker="-"         # this is the element used to draw the progress bar (a line of these)
  # analytical math
  _p_range=$(( _p_tw - ( _p_margin * 2 ) - 3 ))    # num physical cols between screen margins - safety buffer (3)
  _p_percent=$(( (100 * _p_step) / _p_total ))     # process progress as a percent of total num steps
  _p_fill=$(( (_p_range * _p_step) / _p_total ))   # num physical cols to fill with marker to represent progress
  _p_start=$(( _p_margin + 1 ))                    # starting physical column number
  _p_end=$(( _p_tw - _p_margin ))                  # ending physical column number
  # determine which color to use for the text NN% marker in the center
  if [ "$_p_percent" -ge 90 ]; then _p_color="${BGon}"    # green if over 90%
  elif [ "$_p_percent" -lt 70 ]; then _p_color="${BRon}"  # red if less than 70%
  else _p_color="${BYon}"; fi                             # yellow otherwise (0-70%)
  # POSIX repeat (just build it here to save a function call to repeat()
  _p_bar=$(printf "%${_p_fill}s" | tr ' ' "$_p_marker")
  _p_unbar=$(printf "%$(( _p_range - _p_fill ))s" )
  # save cursor position, move to Row
#  SCP; CUP "$_p_th" "$_p_start"
  SCP; printf '\r'; CUF "$_p_start"  # start on current line rather than bottom indent margin + 1
  # draw the structure: |---( 50% )--->| # 4 buckets: (part-built-by-format-string), bucket#:content[type]
  # (wall '|') 1:color[ansi] , 2:_p_bar[string], 3:color-reset[ansi], (arrow head '>'), 4:spaces[string], (wall'\')
  printf "|%b%s>%s%b%s|" "$_p_color" "$_p_bar" "$_p_unbar" "${Boff}" "$_p_spaces"
  EL  # ANSI erase from cursor to end of line (clear any leftovers from a previous wider bar)
#  _p_mid=$(( _p_tw / 2 - 3 )); CUP "$_p_th" "$_p_mid"     # Jump to middle and overlay percentage; then resore cursor to saved position
  _p_mid=$(( _p_tw / 2 - 3 )); printf '\r'; CUF "$_p_mid"     # Jump to middle and overlay percentage; then resore cursor to saved position
  printf "( %b%3d%%%b )" "$_p_color" "$_p_percent" "$Boff"; RCP
  if [ "$_p_step" -eq "$_p_total" ]; then printf '\n'; fi

  unset -v _p_step _p_total _p_margin _p_marker _p_tw _p_th _p_range _p_mid
  unset -v _p_percent _p_fill _p_start _p_end _p_color _p_bar _p_unbar
  return 0 ; }

bs()                   # recursive binary search for $1 target(s) from $2 start(d) to $3 end(d) in search_list $@ (after 3 shifts)
{
  # return the index number of the entry in the list, or -1 if not found
  # expects VERBOSE, verbosity, and initial depth=0 to be set externally before first call to bs
  target="$1"; shift;  start="$1"; shift;  end="$1"; shift; remainder="$@"
  search_list=($(alpha_words ${remainder}))   # alphabetize the list so the binary search can work
  if [ $verbosity -ge "$info" ] ; then
    info_msg_n "search_list: ["
    info_echo_msg_n "${search_list[@]}"
    info_echo_msg "]"
    message "search_list length is [${#search_list[@]}]"
  fi
  let "result=-1"
  if [[ $depth -gt ${#search_list[@]} ]]
  then
    error_msg "Something is wrong here -- depth [$depth] exceeds search_list [${#search_list[@]}]"
    return 1  # can't go deeper than the length of the list
  fi
  diff=$(( $end - $start ))
  middle=$(( $start + $(( $diff / 2 )) ))
  ## guarantee to look at both start and end before giving up
  if [[ ${diff} -eq 1 ]]; then let "middle+=$(( ${depth} % 2 ))"; else DIFF1UPPER=$FALSE; DIFF1LOWER=$FALSE; fi
  debug_msg " depth=[$depth]";  debug_msg " start=[$start]";  debug_msg "   end=[$end]";  debug_msg "middle=[$middle]"
  debug_msg ">> [${search_list[${middle}]}] <<"
  if [[ "${search_list[${middle}]}" == "${target}" ]]; then
    result=$middle   # equal
  else  # not yet equal, so search either the upper or lower half of the remaining range
    [[ $start -eq $end ]] && return 1
    let "depth+=1"   # increment recursive depth and then recurse
    if [[ "${search_list[${middle}]}" > "${target}" ]]; then   # found element is greater than target (search lower half next)
      [[ $diff -eq 1 ]] && DIFF1UPPER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then
         debug_msg "both diff=1 cases examined. not found"
         return 1
      else
         debug_msg "DIFF1 flags not yet both true"
      fi
      debug_msg "candidate [${search_list[${middle}]}] at position [${middle}] is GREATER than target [${target}], DIFF1UPPER is now [$(TrueFalse $DIFF1UPPER)] -- search lower half next"
      bs $target $start $middle ${search_list[@]}
    else   # found element is less than target (search upper half next)
      [[ $diff -eq 1 ]] && DIFF1LOWER=$TRUE
      # if we've examined both the even and odd cases of diff=1, and not found it, then return not found
      if [[ $DIFF1UPPER && $DIFF1LOWER ]]; then
        debug_msg "both diff=1 cases examined. not found"
        return 1
      else
        debug_msg "DIFF1 flags not yet both true"
      fi
      debug_msg "candidate [${search_list[${middle}]}] at position [${middle}] is LESS than target [${target}], DIFF1LOWER is now [$(TrueFalse $DIFF1LOWER)] -- search upper half next"
      bs $target $middle $end ${search_list[@]}
    fi
  fi
  debug_msg "about to return from depth [$depth]"
  [ $depth -eq 0 ] && debug_msg "result: [$result]"
  let "depth-=1";  return 0
}

