#!/bin/sh
####!/bin/bash   ### switched so it's also valid in busybox (ash) shell
#   script header with basic functions
# Author: joe brendler 19 Jul 2014
#         24 June 2025 - v1.0.0 moved to /usr/sbin/ and consolidated as script_header_joetoo
#

#-----[ Define common variables ]---------------------------------------------
BUILD="0.0.0 (19620207)"  #redefine in base script
ROOT_UID=0       # Only users with $UID 0 have root privileges
script_header_installed_dir="/usr/sbin"
#script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo

#  Error message used by various scripts
E_NOTROOT="Must be root to run this script"
E_ROOT="Please run this script as user, not root"
E_BAD_ARGS="Improperly formatted command line argument"
E_BAD_OPT="Invalid option"
E_BAD_COLOR="Invalid color argument"

# pseudo-boolean values for most shells which have none
TRUE=0    # will evaluate to be logically true in a boolean operation
FALSE=""  # will evaluate to be logically false in a boolean operation
  # play with test function:
  # test ( ) { [ $1 ] && echo "$1 is true" || echo "$1 is false"; }
# check set null vs unset and assign default VERBOSE and verbosity,
#  but only if not yet assigned by calling program
VERBOSE="${VERBOSE:-$FALSE}" # Set default ($FALSE) if VERBOSE is UNSET or NULL (already "$FALSE")
verbosity="${verbosity:-2}"  # Set default (2) if verbosity is UNSET or NULL

non_interactive_header="${script_header_installed_dir%/}/script_header_joetoo_noninteractive"

#--[ Easy ANSI Escape sequences to put color in my scripts ]---
#  see http://en.wikipedia.org/wiki/ANSI_escape_code
#  see also http://ascii-table.com/ansi-escape-sequences.php

# define the control sequence initiator: ascii "\e[", octal "\033[", or hex "\x1b["
# which is used for Parameterized Control (e.g., cursor positioning, setting colors, clearing screen)
# The sequence is always followed by numbers and a final letter (e.g., \e[31m for red text)
CSI="\033["
#-----[ Select Graphics Rendition on/off ]------------------------------------------
BOLD="1"         # bold on
UL="4"           # underline on
BLINK="5"        # slow blink on
BLINKFAST="6"    # fast blink on
REVERSE="7"      # image: inverse (reverse video)
ULoff="24"       # underline off
BLINKoff="25"    # blink off
SGRoff="0"       # Bold off (reset all SGR (e.g. blink, underline)
#-----[ Set Text Color, Foreground ]------------------------------------------------
BLACK="30"       # foreground black
RED="31"         # foreground red
GREEN="32"       # foreground green
YELLOW="33"      # foreground yellow
BLUE="34"        # foreground blue
MAG="35"         # foreground magenta (it's like fucia)
LBLUE="36"       # foreground light blue (cyan)
WHITE="37"       # foreground white (cyan)
FG_DEFAULT="39"  # foreground to terminad default
#FG_SPEC="38"    # foreground to specified (e.g., 2 for RGB or 5 for a 256-color palette)
# For example, ${CSI}38;2;255;165;${SGRoff}m sets the foreground to orange
# NOT USED HERE. used in RGB_FG() in script_header_joetoo_extended
#-----[ Set Background Color ]------------------------------------------------------
BACKoff="40"     # background black
RBACK="41"       # background red
GBACK="42"       # background green
YBACK="43"       # background yellow
BBACK="44"       # background blue
MBACK="45"       # background magenta
LBACK="46"       # background light blue (cyan)
WBACK="47"       # background white
BG_DEFAULT="49"  # foreground to terminad default
#BG_SPECB="38"   # background to specified (e.g., 2 for RGB or 5 for a 256-color palette)
# For example, ${CSI}48;2;0;0;${SGRoff}m sets the background to black
# NOT USED HERE. used in RGB_BG() in script_header_joetoo_extended
#-----[ My Favorite Colors (terminate with ${Boff} ]---------------------------------
Ron="${CSI}${RED}m"
Gon="${CSI}${GREEN}m"
Yon="${CSI}${YELLOW}m"
Bon="${CSI}${BLUE}m"
Mon="${CSI}${MAG}m"
Lon="${CSI}${LBLUE}m"
Won="${CSI}${WHITE}m"
BRon="${CSI}${RED};${BOLD}m"
BGon="${CSI}${GREEN};${BOLD}m"
BYon="${CSI}${YELLOW};${BOLD}m"
BBon="${CSI}${BLUE};${BOLD}m"
BMon="${CSI}${MAG};${BOLD}m"
LBon="${CSI}${LBLUE};${BOLD}m"
BWon="${CSI}${WHITE};${BOLD}m"
RVon="${CSI}${REVERSE}m"
Boff="${CSI}${SGRoff}m"          # Bold off (reset all SGR (e.g. blink, underline)
#-----[ Here setting background as well ]--------------------------------------------
BBonY="${CSI}${BLUE};${YBACK};${BOLD}m"

color() {          # (POSIX) set FG $1, optional [bold $2], optional [BG $3]
    _FG=""    # Foreground (3x)
    _BG=""    # Background (4x)
    _B=""     # Bold (0/1)
    _V_FG="${1:-39}"  # Default _FG is 39 (terminal default)
    _V_B="${2:-0}"    # Default Bold is 0 (Normal)
    _V_BG="${3:-49}"  # Default _BG is 49 (terminal default)
    # validate foreground (3x) or set default 39; set bold appropriately
    case "$_V_FG" in
        3[0-7])  # foreground is set
            _FG="$_V_FG" ;
            # validate bold (0/1)
            case "$_V_B" in
                1) _B=";1" ;;
                0) _B="" ;;
                *) echo "$E_BAD_COLOR: Bold attr ($_V_B)(0/1)"; return 1 ;;
            esac  # _B
            ;;
        39)     # unset foreground for default
            _FG="" ;
            # validate bold (0/1) - omit leading ; since no $1
            case "$_V_B" in
                0|1) _B="$_V_B" ;;
                *) echo "$E_BAD_COLOR: Bold attr ($_V_B)(0/1)"; return 1 ;;
            esac  # _B
            ;;  # allow unset args $(color) to equate to ${Boff}
        *) echo "$E_BAD_COLOR: Foreground ($_V_FG)(3x)"; return 1 ;;
    esac # _FG

    # validate background (4x) or set default (unset)
    case "$_V_BG" in
        4[0-7]) _BG=";$_V_BG" ;;
        49) _BG="" ;;  # allow unset _BG to imply terminal default
        *) echo "$E_BAD_COLOR: Background ($_V_BG)(4x)"; return 1 ;;
    esac
    # output the raw ANSI escape sequence
    printf "%s%s%s%s%s" "${CSI}" "${_FG}" "${_B}" "${_BG}" "m"
}

#---[ Box Drawing escape sequence stuff ]--------------------------
# See: https://en.wikipedia.org/wiki/Box-drawing_character
# Note: this is from Digital Equipment Corporation (DEC) command language (DCL) experiance
# I had at Nordson Corporation (Amherst, OH) Robotics EE Research department in 1982
# (though that was actual VT102 terminals connected by serial lines to a Vax-11/70 mainframe)
# DEC was the pioneer that developed the VT100 terminal in the late 1970s. DCL programs for the VT100
# used of escape sequences (\e or ESC) to control cursor movement, colors, and special character sets,
# and this became the industry standard. Most modern terminal emulators (like xterm, Konsole, or the
# console in BusyBox) still implement compatibility with these original VT series terminals
#
# Define the escape sequence initiator (ESCon) not to be confused with the CSI defined above
# with a Single Shift Unlock (SSU) followed by a character set selection.
# The SSU is: ascii "\e(", octal "\033(", or hex "\x1b(" ,  and appending character "0" makes ESCon
# a Character Set Selection that tells the terminal to switch the current font mapping
# (the G0 character set) from the standard ASCII font to the DEC Special Graphics font.
# (VT100-compatible terminals maintain four character sets, known as G0, G1, G2, and G3 -
#  G0 is the primary character set. It's what the terminal uses by default for all incoming
#  characters; G1-G3 are secondary sets)
# ESCon and ESCoff are thus SSU sequences that permanently map G0 to another G-set until
# another sequence shifts it again

# ESC(C Sequences (Explicit G0 Selection)
ESCon='\033(0'     # Maps G0 to DEC Special Graphics (Enable Graphics)
ESCoff='\033(B'    # Maps G0 to Standard ASCII (Disable Graphics)
# ESC)C Sequence (Explicit G1 Selection)
ESGon='\033)0'     # Maps G1 to DEC Special Graphics (Setup for SI/SO)

# Shift In/Out Control Characters (Fast G0/G1 Toggling)
SO='\016'          # Shift Out (Activate G1, Graphics ON - ASCII 14, hex \x0E)
SI='\017'          # Shift In (Activate G0, Standard ASCII ON - ASCII 15, hex \x0F)

vt_init() # set G0/G1 mappings to support SI/SO method (faster than ESCon/off)
{  printf "%b%b" "$ESCoff" "$ESGon" ; }
# *()* test first, the SI/SO method is supported on MOST, not ALL modern terminals

# Graphics Character Codes (Using portable octal escapes)
H_wall='\161'      # Horizontal line (0x71)
V_wall='\170'      # Vertical line (0x78)
UL_wall='\154'     # Upper-Left corner (0x6C)
UR_wall='\153'     # Upper-Right corner (0x6B)
LL_wall='\155'     # Lower-Left corner (0x6D)
LR_wall='\152'     # Lower-Right corner (0x6A)

# unicode line/box characters moved to script_header_joetoo_unicode (do not require the esc seq intro)

#---[ regex character class patterns ]-----------------------------
W0="[[:space:]]*" # regex match for zero or more whitespaces
W1="[[:space:]]+" # regex match for one or more whitespaces
P0="[[:print:]]*" # regex match for zero or more printable characters (incl. whitespace)
P1="[[:print:]]+" # regex match for one or more printable characters (incl. whitespace)
G0="[[:graph:]]*" # regex match for zero or more printable characters (excl. whitespace)
G1="[[:graph:]]+" # regex match for one or more printable characters (excl. whitespace)

#---[ Simple Cursor State Control ]-----------------------------------
SCP()    # save the current cursor position
{ printf "%b" "${CSI}s" ; return $?; }
RCP()    # restore the cursor to the saved position
{ printf "%b" "${CSI}u" ; return $?; }
HCU()    # Hide the cursor (Note: the trailing character is lowercase L)
{ printf "%b" "${CSI}?25l" ; return $?; }
SCU()    # Show the cursor
{ printf "%b" "${CSI}?25h" ; return $?; }
CLR()    # Clear stdout
{ printf "%b" "${CSI}2J" ; return $?; }
#---[ Cursor Absolute Positioning ]-----------------------------------
HVP()    # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{ _row="${1:-1}"; _col="${2:-1}"; if isnumber "$_row" && isnumber "$_col"; then
  printf "%b" "${CSI}${_row};${_col}f" ; return 0; else return 1; fi }
CUP()    # move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{ _row="${1:-1}"; _col="${2:-1}"; if isnumber "$_row" && isnumber "$_col"; then
  printf "%b" "${CSI}${_row};${_col}H" ; return 0; else return 1; fi }
#---[ Cursor Relative Movement ]-----------------------------------
CUU()    # Move the cursor back ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}A" ; return 0;
  else return 1; fi; }
CUD()    # Move the cursor back ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}B" ; return 0;
  else return 1; fi; }
CUF()    # Move the cursor back ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}C" ; return 0;
  else return 1; fi; }
CUB()    # Move the cursor back ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}D" ; return 0;
  else return 1; fi; }

# ---[ common function blocks ]------------------------------------------

isnumber()          # (POSIX) tests if $1 is a non-negative integer
{ [ $# -eq 0 ] && return 1  # Guard clause: Check if an argument was provided
  case $1 in
    ""       ) return 1 ;;
    *[!0-9]* ) return 1 ;;
    *        ) return 0 ;;
  esac ; }

ishex()             # (POSIX) test if $1 is a hexadecimal number
{ [ $# -eq 0 ] && return 1  # Guard clause: Check if an argument was provided
  case $1 in
    ""       ) return 1 ;;
    *[!0-9a-fA-F]* ) return 1 ;;
    *        ) return 0 ;;
  esac ; }

checkroot()         # Run as root, of course.
{ _UID=$(id -u); if [ "$_UID" -ne "$ROOT_UID" ]; then
 E_message "${E_NOTROOT}"; echo;
 E_message "exiting process [$$]" && exit 1; fi; }

checknotroot()      # Run as not root, of course.
{ _UID=$(id -u); if [ "$_UID" -eq "$ROOT_UID" ]; then
 E_message "${E_ROOT}"; echo;
 E_message "exiting process [$$]" && exit 1; fi; }

checkboot()         # check to see if /boot is a mountpoint and is properly mounted
{ _fstab_check=$(grep -E "${W1}/boot${W1}" /etc/fstab | grep -v '^#')
  if [ -z "$_fstab_check" ]; then return 2; fi # not supposed to be a mountpoint
  if grep -q "${W1}/boot${W1}" /proc/mounts 2>/dev/null || \
     grep -q "${W1}/boot${W1}" /etc/mtab 2>/dev/null); then
    return 0; # properly mounted
  else
    return 1; # Listed in fstab but NOT mounted
  fi; }

checkshell()        # reset colors if this shell is not interactive
{ [ -z "$PS1" ] && . ${non_interactive_header}; }

message()     # (POSIX) display text message $@
{ printf " ${BGon}*${Boff} " ; printf "$@\n" ; }
message_n()   # (POSIX) display text message $@ w/o newline
{ printf " ${BGon}*${Boff} " ; printf "$@" ; }
W_message()   # (POSIX) display text warning message $@
{ printf " ${BYon}*${Boff} " ; printf "$@\n" ; }
E_message()   # (POSIX) display text error message $@
{ printf " ${BRon}*${Boff} " ; printf "$@\n" ; }
E_message_n()       # (POSIX) display text error message $@ (no CR)
{ printf " ${BRon}*${Boff} " ; printf "$@" ; }

d_message()   # (POSIX) IAW verbosity, display text debugging message $@
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf " ${BGon}*${Boff} " ; printf "%b\n" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

d_message_n() # (POSIX) IAW verbosity, display text debugging message $@ (no CR)
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf " ${BGon}*${Boff} " ; printf "%b" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

d_echo()      # (POSIX) IAW verbosity, display debugging information
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf "%s\n" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

de_echo()      # (POSIX) IAW verbosity, display debugging information
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf "%b\n" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

de_echo_n()      # (POSIX) IAW verbosity, display debugging information
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf "%b" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

dE_message()   # (POSIX) IAW verbosity, display text debugging message $@
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf " ${BRon}*${Boff} " ; printf "%b\n" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

dE_message_n() # (POSIX) IAW verbosity, display text debugging message $@ (no CR)
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the message parts
      printf " ${BRon}*${Boff} " ; printf "%b" "$*"
    )
  fi # level
}
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

#---[ common logging functions ]-----------------------------------------

timestamp()         # (POSIX) echo a simple timestamp (yyyymmdd-hh:mm:ss)
{ printf "%s\n" "$(date +'%Y%m%d-%H:%M:%S')"; }

log_message()       # (POSIX) message() to stdout and $logFile owned by $user
{ _msg="$1" ; message "$(timestamp) - $_msg" | tee -a "$logFile" ; }

log_message_n()     # (POSIX) message_n() to stdout and $logFile owned by $user
{ _msg="$(timestamp) - $1" ; message_n "$_msg" ; message_n "$_msg" >> $logFile ; }

log_echo()          # (POSIX) echo to stdout and $logFile owned by $user
{ _msg="$1" ; printf "%s\n" "$_msg" | tee -a "$logFile" ; }

log_echo_e()        # (POSIX) echo -e to stdout and $logFile owned by $user
{ _msg="$1" ; printf "%b\n" "$_msg" | tee -a "$logFile" ; }

log_echo_n()        # (POSIX) echo -n "$1" to stdout and $logFile owned by $user
{ _msg="$1" ; printf "%s" "$_msg" | tee -a "$logFile" ; }

log_echo_e_n()      # (POSIX) echo -e -n "$1" to stdout and $logFile owned by $user
{ _msg="$1" ; printf "%b" "$_msg" | tee -a "$logFile" ; }

log_E_message()     # (POSIX) E_message() to stdout and $logFile owned by $user
{ _msg="$1" ; E_message "$(timestamp) - $_msg" | tee -a "$logFile" ; }

log_E_message_n()   # (POSIX) E_message_n() to stdout and $logFile owned by $user
{ _msg="$1" ; E_message_n "$(timestamp) - $_msg" | tee -a "$logFile" ; }

d_log_message()     # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    d_message $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_message_n()   # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    d_message_n $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo()        # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    d_echo $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_e()      # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    de_echo $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_n()      # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    d_echo_n $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_e_n()    # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    de_echo_n $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_E_message()   # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    dE_message $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_E_message_n() # (POSIX) pass $1 to log_message() if IAW verbosity
{ _ts_msg="$(timestamp) - "; ( eval "set -- \"$_ts_msg\" \"$@\"";
    dE_message_n $@ | tee -a "$logFile" ) ; return $?; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

debug_do()          # (POSIX) IAW verbosity, display debugging information
{ [ $# -lt 2 ] && return 1  # Guard. check fo min. 2 args (word + level)
  level="${!#}" # POSIX syntax to get the value of the last argument
  if [ "$level" -le "$verbosity" ]; then
    # Use a subshell to avoid changing the original positional parameters
    ( _count=$# ; _temp_args="" ; _i=1 ;
      # Loop over all arguments EXCEPT the last one
      while [ "$_i" -lt "$_count" ]; do
        # Safely capture the argument content, explicitly adding quotes around it
        _temp_args="$_temp_args \"${!_i}\"" ; _i=$((_i + 1))
      done
      # Use eval + set to rebuild the quoted positional parameter list and restore quoting safely
      eval "set -- $_temp_args"
      # Now "$@" safely holds the command parts
      eval "$@"
    ) ; return $? # Propagate the exit status of the command run in the subshell
  fi # level
  return 0   # Must return 0 if the command was skipped due to verbosity
}
# $* vs. $@ (Quoted) in the final eval statement: Inside double quotes, "$*" joins all positional
# parameters into a single string, which will not always be what we want, the reassembly info
# properly quoted arguments is better, requireing eval "$@"

status_color()      # (POSIX) emit escape seq for color per arg $1
{ # (T/F Y/N up/down)(1=0=$TRUE [Green], ""=$FALSE [Red])
case $1 in [yY]*|[tT]*|[uU]*|"$TRUE"|"0" ) printf "%b" ${BGon};;
           [nN]*|[fF]*|[dD]*|"$FALSE"    ) printf "%b" ${BRon};;
           *) printf "%b" ${BWon};; esac ; }

TrueFalse()         # (POSIX) echo "True" or "False", depending on truth of arg $1
{ # (T/F Y/N up/down)(1=0=$TRUE [Green], ""=$FALSE [Red])
case $1 in [yY]*|[tT]*|[uU]*|"$TRUE"|"0" ) printf "%s" "True" ;;
           [nN]*|[fF]*|[dD]*|"$FALSE"    ) printf "%s" "False" ;;
           *) printf "%s" "unset" ;; esac ; }

repeat()            # (POSIX) output a repeated string of char $1 (of len $2)
{ _thing="${1:- }"; _limit="${2:-1}"; _i=0;_out_str="";
  while [ "$_i" -lt "$_limit" ]; do _out_str="${_out_str}${_thing}"; _i=$((_i + 1)); done
  printf "%s" "$_out_str"; }


prompt()            # (POSIX) set external variable $answer based on reponse to prompt $1
{ _ps="$1"; answer=""; printf "%b" "\n\n"; CUU; SCP;
while ! expr "$answer" : '[yYnN]' >/dev/null; do
RCP; printf "%b" "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$_ps [Y/n]: " && read answer; done; }

new_prompt()        # (POSIX) set external variable $answer based on reponse to prompt $1
{ _ps="$1"; response=""; printf "%b" "\n\n"; CUU; SCP;
while ! expr "$response" : '[yYnNsS]' >/dev/null; do
RCP; printf "%b" "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$_ps [Yes/no/skip|Yns]: " && read response; done; }

right_most() {      # (POSIX) echo the right-most character in a string variable $1
mystring="$1"; [ -z "$mystring" ] && return 1; printf "%s" "${mystring#${mystring%?}}"; }
# echo ${mystring:$((${#mystring}-1)):1};        # other way 1 (non-POSIX string slicing; slower external echo)
# echo ${mystring} | sed "s|${mystring:0:-1}||"  # other way 2 (non-POSIX string slicing; slower external sed)
# echo ${mystring} | rev | cut -c 1 ; }          # other way 3 (non-POSIX rev/cut -c and slower external cut/rev)

alpha_words()       # (POSIX) alphabetize the words in a quoted input string
{ _output=$(for x in "$@"; do printf "%s\n" "$x"; done | sort -db ); printf "%s\n" "$_output" ; }

pur()               # (POSIX) ping ip address $1 until it is ready (0% loss of 3 packets)
{ _target="$1"; SCP; count=1; hits=0; status=""; hit_color="${Boff}"; while [ "$hits" -lt 3 ]; do
  if ping -c1 -W1 "$_target" >/dev/null 2>&1 ; then hits=$((hits + 1)); else hits=0; fi;
  case "$hits" in [01]) hit_color="${BRon}";; 2) hit_color="${BYon}";; 3) hit_color="${BGon}";; esac;
  RCP; printf "%b" "not ready -- try: [${count}], hits: [${hit_color}${hits}${Boff}]";
  count=$((count + 1)); sleep 1; done; RCP; printf "%s" "$(repeat ' ' $(termwidth))"; # Clear the line
  RCP; printf "\n%s\n" "OK - ready now" ; }

swr()               # (POSIX) ssh when nmap indicates port is ready (pur(), then ssh after nmap shows port)
{ _target="$1"; pur "$_target" ; _status=1; _ssh_port=22
  message "confirming $1 has started sshd ..."
  while [ "$_status" -ne 0 ]; do
  (exec 3<> /dev/tcp/"$_target"/"$_ssh_port") 2>/dev/null ; _status=$?; sleep 1; done
  ssh "$_target" ; }

vercomp()           # (almost POSIX) compare versions return [0:equal|1:greaterthan|2:lessthan]
{ _candidate1="$1"; _candidate2="$2"; if [ "$_candidate1" == "$_candidate2" ]; then return 0;
  else _first=$(printf "%b" "$1\n$2" | sort -V | head -n1);
  if [ "$_first" == "$_candidate2" ] ; then return 1; else return 2; fi; fi; }

show_result()       # (POSIX) show the result of vercomp comparison, in english
{ case $1 in 1) printf "%b\n" "${LBon}>${Boff}";; 2) printf "%b\n" "${BRon}<${Boff}";; \
             0) printf "%b\n" "${BGon}=${Boff}";; *) printf "%b\n" "${BYon}*** Error ***${Boff}";; esac }

my_date()           # (POSIX) echo date string (DDD MM dd hh:mm:ss AP TZ yyyy)
{ _date_string=$(date "+%a %b %d %H:%M:%S %Z %Y"); printf "%s\n" "$_date_string" ; }

my_short_date()     # (POSIX) echo shorter date string (yyyymmdd-timehack)
{ _date_string=$(date "+%Y%m%d-%H:%M:%S"); printf "%s\n" "$_date_string" ; }

loggit()            # (POSIX) send a job completion status message to the cron logger
{ [ $# -gt 2 ] && { E_message "invalid loggit arguments" ; exit 1 }
if [ -z "$2" ] ; then EXIT_STATUS=0; else EXIT_STATUS="$2"; fi
if [ -z "$1" ] ; then PROGRAM=Unspecified; else PROGRAM="$1"; fi
  case "$EXIT_STATUS" in
    0 ) PRIORITY="notice"; MESSAGE="succeeded.";;
    * ) PRIORITY="err"; MESSAGE="failed with exit status ${EXIT_STATUS}";;
  esac
  /usr/bin/logger -p "cron.$PRIORITY" "$PROGRAM $MESSAGE" ; }

log_handle_result() # output ok_/_err_msg and right_stats to stdout and logFile
{ _exit_status="$1";
  if [ "$2" == "${no_msg}" ] ; then _ok_msg=""; else _ok_msg=" (${BGon}${2:-success!}${Boff})"; fi
  if [ "$3" == "${no_msg}" ] ; then _err_msg=""; else _err_msg=" (${BRon}${3:-error!}${Boff})"; fi
  if [ "$_exit_status" -eq 0 ] ; then
      log_echo_e_n "${_ok_msg}"
      log_right_status $TRUE
  else
      log_echo_e_n "${_err_msg}"
      log_right_status 1
      return 1
  fi ; return 0 ; }
# *()* usage - log_message_n ...; <command>] ; log_handle_result "$?" "_ok_msg" "_err_msg"
# *()* notes - substitute no_msg=" \b" for either, to "suppress"

validate_logfile()  # validate existence and ownership of logFile
{ d_log_message "in validate_logfile" 5
  _logFile_owner_uid=""; _logFile_group_gid=""
  _user_uid=""; _user_gid=""
  _msg=""
  log_message_n "looking for logFile [${logFile}]"
  if [ ! -f "${logFile}" ] ; then
      log_echo_e_n " (${BRon}not found${Boff})"
      log_right_status 1
      _msg="logFile [${logFile}] not found\n"
      _msg="${_msg}${BRon}Please run (as root) ${BGon}touch ${logFile}; chown ${user}:${user} ${logFile}${Boff}"
      log_E_message "${_msg}"
      return 1
  else
      log_echo_e_n " (${BGon}found${Boff})"
      log_right_status $TRUE
      log_message_n "checking logFile ownership"
      _logFile_owner_uid=$(ls -n "${logFile}" | awk '{print $3}')
      _logFile_group_gid=$(ls -n "${logFile}" | awk '{print $4}')
      _user_uid=$(id -u "${user}")
      _user_gid=$(id -g "${user}")
      if [ "${_logFile_owner_uid}:${_logFile_group_gid}" = "${_user_uid}:${_user_gid}" ] ; then
          log_echo_e_n " (${BGon}${_logFile_owner_uid}:${_logFile_group_gid}${Boff})"
          log_right_status $TRUE
      else
          log_echo_e_n "(${BRon}${_logFile_owner_uid}:${_logFile_group_gid}${Boff})"
          right_status 1
          _msg="bad ownership on logFile [${logFile}]\n"
          _msg="${_msg}${BRon}Please run (as root) ${BGon}chown ${user}:${user} ${logFile}${Boff}"
          log_E_message "${_msg}"
          return 1
      fi # ownership
  fi # existence
}
# *()* reminder - no arrays in ash/busybox, so don't use ${FUNCNAME[0]}
# *()* reminder - in ash, the =+ operator works for arithmetic but not text concatenation
# *()* reminder - logFile and user must be set apriori

termwidth()         # calculate and output the width of the terminal
{ _columns=$(stty size < /dev/tty 2>/dev/null | cut -d' ' -f2)
if [ -z "$_columns" ] ; then printf "%s" "80"; return 1;
else  printf "%s" "$_columns"; return 0; fi ; }
# uses stty size < /dev/tty (redirection) to read from the actaul tty and avoid ioctl errors
# when stdin and stdout are redirected like in a while read ... do ... done <<<$(source) loop

termheight()        # calculate and output the height of the terminal
{ _rows=$(stty size < /dev/tty 2>/dev/null | cut -d' ' -f1)
if [ -z "$_rows" ] ; then printf "%s" "25"; return 1;
else  printf "%s" "$_rows"; return 0; fi ; }
# uses stty size < /dev/tty (redirection) to read from the actaul tty and avoid ioctl errors
# when stdin and stdout are redirected like in a while read ... do ... done <<<$(source) loop

separator()         # draw a horizontal line with preface $1 and title $2
{ # to facilitate separation of portions of the output of various scripts
_msg=""; _msg_len=0;
_preface=${1:-$(hostname)}; _title=${2:-$(basename $0)}
_msg="${BYon}---[${BRon} ${_preface} ${LBon}${_title} ${BYon}]"
_reps=$(( $(termwidth) - ( ${#_preface} + ${#_title} + 8 ) ))
printf "%b" "$_msg" ; printf "%s" "$(repeat '-' $_reps)"; printf "%b\n" "${Boff}"; }

log_separator()     # output separator() to stdout and similar to logFile
{ _preface=${1:-$(hostname)}; _title=${2:-$(basename $0)}
separator "$_preface" "$_title" | tee -a "$logFile" ; }

#####################-----[ POSIX checked above this line -]-----#########################

show_config()       # show config with get_longest() and display_vars()
{ d_message "in show_config" 5 ; separator "${PN}-${BUILD}" "(configuration)"
  longest=$(get_longest ${varlist}) ; display_vars ${longest} ${varlist} ; }

log_show_config()   # show & log config w get_longest() and display_vars()
{ d_log_message "in lg_show_config" 5 ; log_separator "${PN}-${BUILD}" "(configuration)"
  longest=$(get_longest ${varlist}) ; display_vars ${longest} ${varlist}
  display_vars ${longest} ${varlist} >> "$logFile" ; }

get_longest()       # echo length of longest string in input $@
{ ans=0; for x in $@; do [ ${#x} -gt $ans ] && ans=${#x}; done ; echo $ans ; }

display_vars()      # show vals for vars in $@; incl bool/lv/; $1=longest
{
  if ! isnumber $1 ; then
    E_message "Error: arg \$1 must be numeric longest expected input var name"
    exit
  fi
  if [ $# -le 1 ] ; then set $@ "<empty>"; fi  # insert placeholder "<empty>" as $2
  maxlen=$(($1 + 2))
  shift
  for var_name in $@
  do
    if echo $var_name | grep -q "\."; then
      # display by type
      type="$(echo $var_name | awk -F \. '{print $1}')"
      var="$(echo $var_name | awk -F \. '{print $2}')"
      pad=" $(repeat '.' $(( ${maxlen} - ${#var})) )"
      case ${type:0:1} in
        [bB] )
          eval "key=\$${var}"
          message "${LBon}${var}${pad}: [ $(status_color ${key})$(TrueFalse ${key}) ${LBon}]${Boff}"
        ;;
        [yY]   )
          eval "key=\$${var}"
          message "${LBon}${var}${pad}: [ $(status_color ${key})${key} ${LBon}]${Boff}"
        ;;
        [lL]   )
          eval "key=\$${var}"
          message_n "${LBon}${var}${pad}: [ ${Boff}"
          echo_n_long ${maxlen} ${key}; echo -e " ${LBon}]${Boff}"
        ;;
        *      )
          # invalid variable type
          E_message "  (${type}) invalid variable type [${type}] for variable [${var_name}]"
          exit
        ;;
      esac
    elif [[ "$var_name" == "BREAK" ]] ; then
      echo
    else
      # untyped
      type=""
      var="$var_name"
      eval "key=\$${var}"
      pad=" $(repeat '.' $(( ${maxlen} - ${#var})) )"
      message "${LBon}${var}${pad}: [ ${Boff}${key} ${LBon}]${Boff}"
    fi
  done
}

initialize_vars()   # initialize values for vars in $@; incl bool. lv.
{
  [ $# -lt 1 ] && return
  parmlist=$(echo $@ | sed 's|verbosity||' | sed 's|bool.VERBOSE||')
  d_message "initializing vars: $parmlist" 5
  for var_name in $parmlist
  do
    if echo $var_name | grep -q "\."; then
      # initialize by type
      type="$(echo $var_name | awk -F \. '{print $1}')"
      var="$(echo $var_name | awk -F \. '{print $2}')"
      case ${type:0:1} in
        [bB] )
          # boolean convention: parameter is "bool.${var}" where ${var} is e.g. "VERBOSE"
          # initialize booleans $FALSE
          d_message_n "  (${type}) initializing ${var} FALSE ..." 2
          eval "${var}=\$FALSE" ; d_right_status $? 2
        ;;
        [yY]   )
          # yes/no convention: parameter is "yn.${var}" where ${var} is e.g. "EIX"
          # initialize yes/no to "no"
          d_message_n "  (${type}) initializing ${var} (no) ..." 2
          eval "${var}=''" ; d_right_status $? 2
        ;;
        [lL]   )
          # lonstring convention: parameter is "lv.${var}" where ${var} is e.g. "CMDLINE"
          # initialize longstring to null string
          d_message_n "  (${type}) initializing ${var} NULL ..." 2
          eval "${var}=''" ; d_right_status $? 2
        ;;
        *      )
          # invalid variable type
          E_message "  (${type}) invalid variable type [${type}] for variable [${var_name}]"
          exit
        ;;
      esac
    elif [[ "$var_name" == "BREAK" ]] ; then
      # ignore BREAK
      type=""
      d_message_n "  ignoring BREAK ..." 2
      d_right_status $TRUE 2
    else
      # untyped - initialize null
      type=""
      var="$var_name"
      d_message_n "  (${type}) initializing ${var} NULL ..." 2
      eval "${var}=''" ; d_right_status $? 2
    fi
    d_message "about to initialize $var_name of type: [ $type ]" 4
  done
}

echo_n_long()       # echo long string over several lines, if need. $1=start
{
  if ! isnumber $1 ; then E_message "Error: arg \$1 must be numeric starting caracter position"; exit; fi
  if [ $# -le 1 ] ; then set $@ "<empty>"; fi
  left=" * "; right=": [ "
  start=$(( $1 + ${#left} + ${#right} )); shift; input="$@"; tw=$(termwidth); newline=""
  for x in $input
  do
    d_echo "start: $start  #newline: ${#newline}   #x: ${#x}  tw: $tw   sum: $(( ${start} + ${#newline} + ${#x} + 1))" 6
    if [[  $(( ${start} + ${#newline} + ${#x} + 1)) -le ${tw} ]] ; then
      [[ ${#newline} -eq 0 ]] && newline="${x}" || newline="${newline} ${x}"
    else
      echo "${newline}"
      start=0   # since next will be a new line
      newline="${x}"
    fi
  done
  echo -n "${newline}"
}

right_status()      # output 8 char [ ok/fail ] status at the right margin
{ # test message_n "good_test" ; right_status $?
  #      E_message_n "fail_test" && cat unexistent 2>/dev/null; right_status $?
  local msg status=$1
  [[ $status -eq 0 ]] && msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}" || msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}"
  # go to start of line, *then* move fwd to 7 chars from the right margin ("[ xx ]" is 6)
  echo -en "\r" && CUF $(( $(termwidth) - 7 )) && echo -e "$msg" && return 0 || return 1 ; }

log_right_status()  # output rigit_status to stdout and logFile 
{ local msg status=$1; [[ $status -eq 0 ]] && msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}" || \
  msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}";
  echo -e -n "\r" && CUF $(( $(termwidth) - 7 )) && echo -e "$msg" && \
  echo -e " $msg" >> $logFile && return 0 || return 1 ; }

d_right_status()    # output rigit_status IAW verbosity
{ # test with v=((verbosity+1)) and v=(($verbosity-1))
  # d_message_n "good_test" $v; d_right_status $? $v
  #      dE_message_n "fail_test" $v && cat unexistent 2>/dev/null; d_right_status $? $v
  local status=$1
  [ "$VERBOSE" ] && [ "$2" -le "$verbosity" ] && right_status $status && return 0 || return 1 ; }

sh_countdown()      # count-down seconds (arg $1)
{ # special note: bb sh cannot use base#number notation with prefix 10# to ensure interpretation as base 10
  if [[ ! -z $1 ]]
  then rem_time="${1}" ;
  else
    message "no argument given, defaulting to 30 seconds"
    rem_time=30
  fi
  # execute countdown
  while [[ "${rem_time}" -gt "0" ]]
  do
    [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
    echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
    sleep 1
    let "rem_time--"
  done
  [[ "$rem_time" -lt "10" ]] && r_time="0"${rem_time} || r_time=${rem_time}
  echo -en "\r${BGon}*${Boff} Pausing. [ ${BGon}${r_time}${Boff} ] seconds remaining..."
  echo
  return 0
}

progress()          # show progress arrow (visualize $1 of $2 steps complete)
{
  [ $# -ne 2 ] && E_message "${BRon}Error - two arguments required (${BYon}step ${BRon}and ${BYon}number_of_steps${BRon})${Boff}"
  step=$1; number_of_steps=$2
  #---[ user configurable variables ]---------------------------------------------------------------------------------------------
  margin=10; marker="-"
  #---[ analytically determined variables ]---------------------------------------------------------------------------------------
  range=$(( $(termwidth) - 3 - $(( $margin * 2 )) ))   # the -3 accounts for the two brackets (|) and the arrow head (>)
  myprogress=$(( $range * $step / $number_of_steps ))    # this is how many $marker to draw to represent a single step of progress
  start=$(($margin + 1)); end=$(( $(termwidth) - $margin -1 ))
  myrow=$(termheight)
  startofline=$(($start +1))
  [ $step -lt $number_of_steps ] && endofline=$(($startofline + $myprogress)) || endofline=$(($end - 2))
  lengthofline=$(($endofline - $startofline + 1))
  percent=$((100 * $step / $number_of_steps))
  middlestart=$(( $(( $(termwidth) / 2 )) - $(( ${#percent} / 2 )) - 4 ))
  if [ $percent -ge 90 ]; then pct_color=${BGon}; else
  if [ $percent -lt 70 ]; then pct_color=${BRon}; else pct_color=${BYon}; fi; fi
  #---/ action: move to start, draw "|", draw line and ">", move to end and draw "|",
  #     move middle, show percent, return to original position /------------------------------------------------------------------
  SCP; CUP $myrow $start; echo -en "|"
  repeat $marker $lengthofline; echo -en ">"
  CUP $myrow $end; echo -en "|"
  CUP $myrow $middlestart; echo -en "( ${pct_color}$percent%${Boff} )"; RCP
}

fe()                # find ebuild files matching filter "*$1*"
{ echo "looking for ebuild(s) matching filter: $1"; find / -iname "*$1*.ebuild" -type f -print 2>/dev/null; }

non_stty_separator()       # expects TERMWIDTH to be set in environment
{
  local msg preface title msg_len
  [ ! -z "$1" ] && preface="$1" || preface=$(hostname)
  [ ! -z "$2" ] && title="$2" || title=$(basename $0)
  msg="${BYon}---[${BRon} ${preface} ${LBon}${title} ${BYon}]"
  msg_len=$(( ${#msg} - $(( ${#BYon} + ${#BRon} + ${#BBon} + ${#BYon} + ${#Boff} )) ));
  echo -en "$msg" && echo -n $(repeat "-" $(( ${TERMWIDTH} - $(( $msg_len + ${#Boff} )) ))) && echo -e ${Boff} && return 0 || return 1
}

non_stty_right_status()    # expects TERMWIDTH to be set in environment
{
    local msg status=$1;
    [[ $status -eq 0 ]] && msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}" || msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}";
    echo -en "\r" && CUF $(( ${TERMWIDTH} - 7 )) && echo -e "$msg" && return 0 || return 1
}

confirm_continue_or_exit() # use prompt() to confirm user wants to continue
{ answer="" ; msg="${BYon}Do you want to continue?" ; prompt "${msg}"
    case ${answer:0:1} in
        [yY] ) message "Affirmative response from user; continuing" ;;
        [nN] ) E_message "Negative response from user; quitting"; exit 1 ;;
        * ) E_message "invalid response to confirm_continue_or_exit"; exit 1 ;;
    esac ; return 0 ; }

die()                      # display reason with E_message and exit with status 1
{ msg="${1}" ; E_message "${msg}" ; exit 1 ; }

get_luks_keyfile()         # use arg1 (crypt_keydev) to identify keyfile
{
    # determine keydev type
    # if it starts with "/" it is a device name
    # if it contains "-" it may be a UUID
    # if it does not, it may be a LABEL
    message_n "examining crypt_keydev [ ${crypt_keydev} ] ..."
    if [ -b ${crypt_keydev} ] ; then
        crypt_keydev_type=devicename
    elif echo ${crypt_keydev} | grep "-" ; then
        crypt_keydev_type=UUID
    else
        crypt_keydev_type=LABEL
    fi
    # if it is not mounted, try to mount it
    if [[ ! -z "$( mount | grep ${crypt_keydev_mountpoint%/} )" ]] ; then
        echo -en " ${BGon}(mounted)${Boff}"
        right_status $TRUE
    else
        echo -en " trying to mount (${crypt_keydev_type}) [${crypt_keydev}] ..."
        case $crypt_keydev_type in
             "devicename" ) mount ${crypt_keydev} ${crypt_keydev_mountpoint} && right_status $? || \
                  ( right_status $? && die "could not mount crypt_keydev ($crypt_keydev_type)") ;;
             "UUID"       ) mount UUID=${crypt_keydev} ${crypt_keydev_mountpoint} && right_status $? || \
                  ( right_status $? && die "could not mount crypt_keydev ($crypt_keydev_type)") ;;

             "LABEL"      ) mount LABEL=${crypt_keydev} ${crypt_keydev_mountpoint} && right_status $? || \
                  ( right_status $? && die "could not mount crypt_keydev ($crypt_keydev_type)") ;;
             * )  right_status 1 ; die "invalid crypt_keydev" ;;
        esac
    fi
    # set keyfile pathname
    export keyfile=${crypt_keydev_mountpoint%/}/crypt/dat
    return 0
}

get_luks_edev_name()       # determine an edev name to use with this device
{
    # ( e.g. sda2->eda2 nvme0n1p2->ev012 mmcblk0p2->em02 )
    d_message_n "determining edev name ..." 3
    bn=$(basename ${luks_partition_device})
    case ${bn:0:2} in
      "sd" ) # scsi device
        myedev=$(echo ${bn} | sed 's/^s/e/')
        ;;
      "nv" ) # nvme device
        myedev=$(echo ${bn} | sed 's/^nvme/ev/' | sed 's/[np]//g')
        ;;
      "mm" ) # mmc device
        myedev=$(echo ${bn} | sed 's/^mmcblk/em/' | sed 's/p//g')
        ;;
      *    ) # tbd
        d_echo "" 3 ; d_E_message "Error: bad luks device name [${OUTPUTDEVICE}]" 3
        ;;
    esac ; result=$?
    d_echo " (${myedev})" 3 ; d_right_status $result 3
    export edev=${myedev}
    return $result
}

summarize_me()             # list functions in header ("source" to employ)
{
  echo
  separator "script_header_joetoo-$BUILD | content summary" && \
  message "This script header defines some ${BYon}common variables${Boff} for" && \
  message "  use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}" && \
  message "  ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and" && \
  message "  ${BYon}cursor${Boff} movement in my scripts, and it provides a number of" && \
  message "  useful ${BGon}functions${Boff}, for some routine tasks, as described below\n" && \
  grep "()" ${script_header_installed_dir%/}/script_header_joetoo | grep -v "grep" && echo && \
  msg="${BGon}* ${Boff}  ${BYon}About to run:\n        ${BBon}message${Boff}" && \
  msg="${msg}  ${BYon}\""'${BYon}VERBOSE is currently ' && \
  msg="${msg}${BGon}\$(${BBon}status_color \\\"${BRon}\$VERBOSE${BBon}\\\"${BGon})${Boff}" && \
  msg="${msg}${BGon}\$(${BBon}TrueFalse \\\"${BRon}\$VERBOSE${BBon}\\\"" && \
  msg="${msg}${BGon})${BYon}\"${BGon}; ${BBon}echo${Boff}" && echo -e "${msg}" && \
  echo && \
  cmd="${BGon}message${BWon} \"  \${BYon}VERBOSE is currently \$(${BGon}status_color ${BRon}\$VERBOSE)${BWon}\$(${BGon}TrueFalse ${BRon}\$VERBOSE${BWon})\${Boff}\"${Boff}"
  message "About to run ${cmd}"
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  message "  ${BYon}VERBOSE is currently $(status_color $VERBOSE)$(TrueFalse $VERBOSE)${Boff}" && echo && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 1 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}2 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 2 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 2${Boff}  " && \
  vercomp 1 2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0 ${BYon}to${BWon} 1.2.1${Boff}  " && \
  vercomp 1.2.0 1.2.1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0-r1 ${BYon}to${BWon} 1.2.0${Boff}  " && \
  vercomp 1.2.0-r1 1.2.0; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1..1 ${BYon}to${BWon} 1.2${Boff}  " && \
  vercomp 1..1 1.2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.0 ${BYon}to${BWon} 1.0-r10${Boff}  " && \
  vercomp 1.0 1.0-r10; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  " && \
  vercomp 3.4 3.4-r2; echo -e "$(show_result $?)" && echo && \
  message "${BYon}Conditionally execute \$@ IAW verbosity (3) with ${BGon}d_do ${Boff}echo \"line 1.1\" \\; echo \"line 1.2\" 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  d_do echo "line 1.1" \; echo "line 1.2" 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message "${BYon}Conditionally execute \$1 IAW verbosity (3) with ${BGon}debug_do ${Boff}'echo \"line 2.1\" ; echo \"line 2.2\"' 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  debug_do 'echo "line 2.1" ; echo "line 2.2"' 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && echo "" && \
  message "${BYon}Summary of some T/F tests with ${BGon}status_color${Boff}( ) and ${BGon}TrueFalse${Boff}( ) --" && \
  for x in y Y t T up n N f F down 0 1 z "" ; do message "  ${BWon}testing: [${LBon}${x}${BWon}] is $(status_color $x)$(TrueFalse $x)${Boff}" ; done && \
  message "  ${BWon}testing: [${LBon}\$TRUE${BWon}] is $(status_color $TRUE)$(TrueFalse $TRUE)${Boff}" && \
  message "  ${BWon}testing: [${LBon}\$FALSE${BWon}] is $(status_color $FALSE)$(TrueFalse $FALSE)${Boff}" && \
  E_message "Note: bash and most other shells evaluate a variable with null ('') value as ${BRon}FALSE${Boff} and any non-null value as ${BGon}TRUE${Boff}" && \
  echo && \
  msg="${BYon}About to run: ${BBon}sh_countdown ${Boff}3${BGon} && ${LBon}echo ${BGon}&& ${Boff}" && \
  msg="${msg}${BBon}message_n${Boff} \"" && \
  msg="${msg}Finishing with status of summarization ---> \" ${BGon}; ${BBon}right_status ${BRon}\$?${BGon}; ${BBon}echo${Boff}" && \
  message "${msg}" && \
  sh_countdown 3 && echo && \
  message_n "Finishing with status of summarization --->" ; right_status $?; echo

  return 0
}
