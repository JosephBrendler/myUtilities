#!/bin/sh
####!/bin/bash   ### switched so it's also valid in busybox (ash) shell
#   script header with basic functions
# Author: joe brendler 19 Jul 2014
#         24 June 2025 - v1.0.0 moved to /usr/sbin/ and consolidated as script_header_joetoo
#

#-----[ Define common variables ]---------------------------------------------
BUILD="0.0.0 (19620207)"  #redefine in base script
ROOT_UID=0       # Only users with $UID 0 have root privileges
script_header_installed_dir="/usr/sbin"
#script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo

#  Error message used by various scripts
E_NOTROOT="Must be root to run this script"
E_ROOT="Please run this script as user, not root"
E_BAD_ARGS="Improperly formatted command line argument"
E_BAD_OPT="Invalid option"
E_BAD_COLOR="Invalid color argument"

# pseudo-boolean values for most shells which have none
TRUE=0    # will evaluate to be logically true in a boolean operation
FALSE=""  # will evaluate to be logically false in a boolean operation
  # play with test function:
  # test() { [ $1 ] && echo "$1 is true" || echo "$1 is false"; }
# in comparison, exit status code must be tested with math, not logic
  # play with test function:
  # result=1; [ "$result" ] && echo true || echo false  {status 1 == failure; but this will return "true"}
  # to test an exit status, use [ "$result" -eq 0 ]

# no_msg is a space overwritten by a backspace, used log_handle_result() to send null message with a non-null string
no_msg=" \b"

# check set null vs unset and assign default VERBOSE and verbosity,
#  but only if not yet assigned by calling program
VERBOSE="${VERBOSE:-$FALSE}" # Set default ($FALSE) if VERBOSE is UNSET or NULL (already "$FALSE")
verbosity="${verbosity:-2}"  # Set default (2) if verbosity is UNSET or NULL

non_interactive_header="${script_header_installed_dir%/}/script_header_joetoo_noninteractive"

#--[ Easy ANSI Escape sequences to put color in my scripts ]---
#  see http://en.wikipedia.org/wiki/ANSI_escape_code
#  see also http://ascii-table.com/ansi-escape-sequences.php

# (POSIX) CSI - define the control sequence initiator: ascii "\e[", octal "\033[", or hex "\x1b["
# which is used for Parameterized Control (e.g., cursor positioning, setting colors, clearing screen)
# The sequence is always followed by numbers and a final letter (e.g., \e[31m for red text)
# LEGACY: assigning CSI='\033[' stores the characters of the "Literal Escape Sequence" in a string
#   requires an interpreter (echo -e or printf %b) to convert the '\' '0' '3' '3'
#   strings into a real control character
# UPGRADED: assigning CSI=$(printf '\033[') stores the "Raw ANSI Control Sequence"
# The subshell executes and emits the actual non-printing Escape Byte (Hex 1B)
# This is "Pre-Cooked"â-- it works in printf "%s" because the byte is already binary
CSI=$(printf '\033[')
#-----[ Select Graphics Rendition on/off ]------------------------------------------
BOLD="1"         # bold on
UL="4"           # underline on
BLINK="5"        # slow blink on
BLINKFAST="6"    # fast blink on
REVERSE="7"      # image: inverse (reverse video)
ULoff="24"       # underline off
BLINKoff="25"    # blink off
SGRoff="0"       # Bold off (reset all SGR (e.g. blink, underline)
#-----[ Set Text Color, Foreground ]------------------------------------------------
BLACK="30"       # foreground black
RED="31"         # foreground red
GREEN="32"       # foreground green
YELLOW="33"      # foreground yellow
BLUE="34"        # foreground blue
MAG="35"         # foreground magenta (it's like fucia)
CYAN="36"        # foreground cyan
LBLUE="36"       # foreground light blue (cyan)(deprecated - keep here for compatibility)
WHITE="37"       # foreground white
FG_DEFAULT="39"  # foreground to terminal default
#FG_SPEC="38"    # foreground to specified (e.g., 2 for RGB or 5 for a 256-color palette)
# For example, ${CSI}38;2;255;165;${SGRoff}m sets the foreground to orange
# NOT USED HERE. used in RGB_FG() in script_header_joetoo_extended
#-----[ Set Background Color ]------------------------------------------------------
BACKoff="40"     # background black
RBACK="41"       # background red
GBACK="42"       # background green
YBACK="43"       # background yellow
BBACK="44"       # background blue
MBACK="45"       # background magenta
CBACK="46"       # background cyan
LBACK="46"       # background light blue (cyan)(deprecated - keep here for compatibility)
WBACK="47"       # background white
BG_DEFAULT="49"  # foreground to terminal default
#BG_SPECB="38"   # background to specified (e.g., 2 for RGB or 5 for a 256-color palette)
# For example, ${CSI}48;2;0;0;${SGRoff}m sets the background to black
# NOT USED HERE. used in RGB_BG() in script_header_joetoo_extended
#-----[ My Favorite Colors (terminate with ${Boff} ]---------------------------------
Ron="${CSI}${RED}m"
Gon="${CSI}${GREEN}m"
Yon="${CSI}${YELLOW}m"
Bon="${CSI}${BLUE}m"
Mon="${CSI}${MAG}m"
Con="${CSI}${CYAN}m"
Lon="${CSI}${LBLUE}m"   # (deprecated - keep here for compatibility)
Won="${CSI}${WHITE}m"
BRon="${CSI}${RED};${BOLD}m"
BGon="${CSI}${GREEN};${BOLD}m"
BYon="${CSI}${YELLOW};${BOLD}m"
BBon="${CSI}${BLUE};${BOLD}m"
BMon="${CSI}${MAG};${BOLD}m"
BCon="${CSI}${CYAN};${BOLD}m"
LBon="${CSI}${LBLUE};${BOLD}m"   # (deprecated - keep here for compatibility)
BWon="${CSI}${WHITE};${BOLD}m"
RVon="${CSI}${REVERSE}m"
Boff="${CSI}${SGRoff}m"          # Bold off (reset all SGR (e.g. blink, underline)
#-----[ Here setting background as well ]--------------------------------------------
BBonY="${CSI}${BLUE};${YBACK};${BOLD}m"

color() {          # (POSIX) set FG $1, optional [bold $2], optional [BG $3]
    _FG=""    # Foreground (3x)
    _BG=""    # Background (4x)
    _B=""     # Bold (0/1)
    _V_FG="${1:-39}"  # Default _FG is 39 (terminal default)
    _V_B="${2:-0}"    # Default Bold is 0 (Normal)
    _V_BG="${3:-49}"  # Default _BG is 49 (terminal default)
    # validate foreground (3x) or set default 39; set bold appropriately
    case "$_V_FG" in
        3[0-7])  # foreground is set
            _FG="$_V_FG" ;
            # validate bold (0/1)
            case "$_V_B" in
                1) _B=";1" ;;
                0) _B="" ;;
                *) echo "$E_BAD_COLOR: Bold attr ($_V_B)(0/1)"; return 1 ;;
            esac  # _B
            ;;
        39)     # unset foreground for default
            _FG="" ;
            # validate bold (0/1) - omit leading ; since no $1
            case "$_V_B" in
                0|1) _B="$_V_B" ;;
                *) echo "$E_BAD_COLOR: Bold attr ($_V_B)(0/1)"; return 1 ;;
            esac  # _B
            ;;  # allow unset args $(color) to equate to ${Boff}
        *) echo "$E_BAD_COLOR: Foreground ($_V_FG)(3x)"; return 1 ;;
    esac # _FG

    # validate background (4x) or set default (unset)
    case "$_V_BG" in
        4[0-7]) _BG=";$_V_BG" ;;
        49) _BG="" ;;  # allow unset _BG to imply terminal default
        *) echo "$E_BAD_COLOR: Background ($_V_BG)(4x)"; return 1 ;;
    esac
    # output the raw ANSI escape sequence
    printf "%s%s%s%s%s" "${CSI}" "${_FG}" "${_B}" "${_BG}" "m"
    # Clean up local variables to maintain POSIX hygiene
    unset -v _FG _BG _B _V_FG _V_B _V_BG
}

#---[ Box Drawing escape sequence stuff ]--------------------------
# See: https://en.wikipedia.org/wiki/Box-drawing_character
# Note: this is from Digital Equipment Corporation (DEC) command language (DCL) experiance
# I had at Nordson Corporation (Amherst, OH) Robotics EE Research department in 1982
# (though that was actual VT102 terminals connected by serial lines to a Vax-11/70 mainframe)
# DEC was the pioneer that developed the VT100 terminal in the late 1970s. DCL programs for the VT100
# used of escape sequences (\e or ESC) to control cursor movement, colors, and special character sets,
# and this became the industry standard. Most modern terminal emulators (like xterm, Konsole, or the
# console in BusyBox) still implement compatibility with these original VT series terminals
#
# Define the escape sequence initiator (ESCon) not to be confused with the CSI defined above
# with a Single Shift Unlock (SSU) followed by a character set selection.
# The SSU is: ascii "\e(", octal "\033(", or hex "\x1b(" ,  and appending character "0" makes ESCon
# a Character Set Selection that tells the terminal to switch the current font mapping
# (the G0 character set) from the standard ASCII font to the DEC Special Graphics font.
# (VT100-compatible terminals maintain four character sets, known as G0, G1, G2, and G3 -
#  G0 is the primary character set. It's what the terminal uses by default for all incoming
#  characters; G1-G3 are secondary sets)
# ESCon and ESCoff are thus SSU sequences that permanently map G0 to another G-set until
# another sequence shifts it again

# ESC(C Sequences (Explicit G0 Selection)
ESCon='\033(0'     # Maps G0 to DEC Special Graphics (Enable Graphics)
ESCoff='\033(B'    # Maps G0 to Standard ASCII (Disable Graphics)
# ESC)C Sequence (Explicit G1 Selection)
ESGon='\033)0'     # Maps G1 to DEC Special Graphics (Setup for SI/SO)

# Shift In/Out Control Characters (Fast G0/G1 Toggling)
SO='\016'          # Shift Out (Activate G1, Graphics ON - ASCII 14, hex \x0E)
SI='\017'          # Shift In (Activate G0, Standard ASCII ON - ASCII 15, hex \x0F)

vt_init() # set G0/G1 mappings to support SI/SO method (faster than ESCon/off)
{  printf "%b%b" "$ESCoff" "$ESGon" ; }
# *()* test first, the SI/SO method is supported on MOST, not ALL modern terminals

# Graphics Character Codes (Using portable octal escapes)
H_wall='\161'      # Horizontal line (0x71)
V_wall='\170'      # Vertical line (0x78)
UL_wall='\154'     # Upper-Left corner (0x6C)
UR_wall='\153'     # Upper-Right corner (0x6B)
LL_wall='\155'     # Lower-Left corner (0x6D)
LR_wall='\152'     # Lower-Right corner (0x6A)

# unicode line/box characters moved to script_header_joetoo_unicode (do not require the esc seq intro)

#---[ regex character class patterns ]-----------------------------
W0="[[:space:]]*" # regex match for zero or more whitespaces
W1="[[:space:]]+" # regex match for one or more whitespaces
P0="[[:print:]]*" # regex match for zero or more printable characters (incl. whitespace)
P1="[[:print:]]+" # regex match for one or more printable characters (incl. whitespace)
G0="[[:graph:]]*" # regex match for zero or more printable characters (excl. whitespace)
G1="[[:graph:]]+" # regex match for one or more printable characters (excl. whitespace)

#---[ Simple Cursor State Control ]-----------------------------------
SCP()    # (ANSI) save the current cursor position
{ printf "%b" "${CSI}s" ; return $?; }
RCP()    # (ANSI) restore the cursor to the saved position
{ printf "%b" "${CSI}u" ; return $?; }
HCU()    # (ANSI) Hide the cursor (Note: the trailing character is lowercase L)
{ printf "%b" "${CSI}?25l" ; return $?; }
SCU()    # (ANSI) Show the cursor
{ printf "%b" "${CSI}?25h" ; return $?; }
CLR()    # (ANSI) Clear stdout
{ printf "%b" "${CSI}2J" ; return $?; }
EL()     # (ANSI) Erase line
{ printf "%b" "${CSI}K" ; return $?; }
#---[ Cursor Absolute Positioning ]-----------------------------------
HVP()    # (ANSI) move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{ _row="${1:-1}"; _col="${2:-1}"; if isnumber "$_row" && isnumber "$_col"; then
  printf "%b" "${CSI}${_row};${_col}f" ; unset -v _row _col; return 0; else unset -v _row _col; return 1; fi }
CUP()    # (ANSI) move cursor to position row=$1, col=$2 (both default to 1 if omitted)
{ _row="${1:-1}"; _col="${2:-1}"; if isnumber "$_row" && isnumber "$_col"; then
  printf "%b" "${CSI}${_row};${_col}H" ; unset -v _row _col; return 0; else unset -v _row _col; return 1; fi }
#---[ Cursor Relative Movement ]-----------------------------------
CUU()    # (ANSI) Move the cursor up ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}A" ; unset -v _reps; return 0; else unset -v _reps; return 1; fi; }
CUD()    # (ANSI) Move the cursor down ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}B" ; unset -v _reps; return 0; else unset -v _reps; return 1; fi; }
CUF()    # (ANSI) Move the cursor fwd/right ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}C" ; unset -v _reps; return 0; else unset -v _reps; return 1; fi; }
CUB()    # (ANSI) Move the cursor back/left ($1 cells)
{ _reps="${1:-1}"; if isnumber "$_reps"; then printf "%b" "${CSI}${_reps}D" ; unset -v _reps; return 0; else unset -v _reps; return 1; fi; }

# ---[ common function blocks ]------------------------------------------

isnumber()          # (POSIX) deprecated - use isint(); tests if $1 is an integer
{ [ $# -eq 0 ] && return 1  # guard clause: check if an argument was provided
  _val=$1
  _test_val="${_val#-}"  # Remove leading dash (negative # ok; test the rest)
  case "$_test_val" in
    "" | *[!0-9]* ) unset -v _val _test_val; return 1 ;;
    *        ) unset -v _val _test_val; return 0 ;;
  esac ; }

isint()             # (POSIX) tests if $1 is a decimal integer
{ [ $# -eq 0 ] && return 1  # guard clause: check if an argument was provided
  _val=$1
  _test_val="${_val#-}"  # Remove leading dash (negative # ok; test the rest)
  case "$_test_val" in
    "" | *[!0-9]* ) unset -v _val _test_val; return 1 ;;
    *        ) unset -v _val _test_val; return 0 ;;
  esac ; }

ishexint()          # (POSIX) tests if $1 is a hexidecimal integer
{ [ $# -eq 0 ] && return 1  # guard clause: check if an argument was provided
  _val=$1
  _test_val="${_val#-}"  # Remove leading dash (negative # ok; test the rest)
  case "$_test_val" in
    "" | *[!0-9a-fA-F]* ) unset -v _val _test_val; return 1 ;;
    *        ) unset -v _val _test_val; return 0 ;;
  esac ; }

isfloat()           # (POSIX) tests if $1 is a floating point decimal number
{ [ $# -eq 0 ] && return 1  # guard clause: check if an argument was provided
  _val=$1
  _test_val="${_val#-}"  # Remove leading dash (negative # ok; test the rest)
  case "$_test_val" in
    "" | "." | *[!0-9.]* ) unset -v _val _test_val; return 1 ;;    # reject if empty, just a dot, or contains non-numeric/non-dot chars
    *"."*"."*            ) unset -v _val _test_val; return 1 ;;    # eject if there is more than one dot
    *                    ) unset -v _val _test_val; return 0 ;;    # success
  esac
}

isnumeric()         # (POSIX) tests if $1 is any valid numeric type (Dec, Hex, or Float)
{ isint "$1" || ishexint "$1" || isfloat "$1" ; }

checkroot()         # Run as root, of course (${var:-0} means default to 0)
{ if [ "$(id -u)" -ne "${ROOT_UID:-0}" ]; then E_message "${E_NOTROOT}"; echo; E_message "exiting process [$$]"; exit 1; fi; }

checknotroot()      # Run as not root, of course (${var:-0} means default to 0)
{ if [ "$(id -u)" -eq "${ROOT_UID:-0}" ]; then E_message "${E_ROOT}"; echo; E_message "exiting process [$$]"; exit 1; fi; }

checkboot()         # check to see if /boot is a mountpoint and is properly mounted
{ _fstab_check=$(grep -E "${W1}/boot(${W1}|$)" /etc/fstab | grep -v "^${W0}#") # find /boot entries; strip comments
  if [ -z "$_fstab_check" ]; then set -- 2; # not supposed to be a mountpoint
  elif grep -qE "${W1}/boot(${W1}|$)" /proc/mounts 2>/dev/null || \
     grep -qE "${W1}/boot(${W1}|$)" /etc/mtab 2>/dev/null; then
    set -- 0; # properly mounted
  else
    set -- 1; # Listed in fstab but NOT mounted
  fi; unset -v _fstab_check; return ${1:-255}; }  # default 255 (so we know it broke if $1 is empty)
# fstab format: |<device|uuid> /boot ...| i.e. mountpoint is colunm 2 preceded by <device|uuid> and ${W1}
# followed by whitespace or (rarely) simply the end of the line -- (${W1}|$)

checkshell()        # reset colors if this shell is not interactive
{ [ -z "$PS1" ] && . ${non_interactive_header}; }

message()     # (POSIX) display text message $@
{ printf " ${BGon}*${Boff} " ; printf "$*"; printf "\n" ; }
# use "$*" to bind message as a single string (no word-split)
# old, below, used "$@" to print properly quoted words but
#{ printf " ${BGon}*${Boff} " ; printf "$@\n" ; }

message_n()   # (POSIX) display text message $@ w/o newline
{ _mn_msg="$*"; _mn_msg_len=$(_get_msg_len "$_mn_msg")
  _mn_status_width=6   # e.g. "[ Ok ]" = 6 char
  _mn_buffer=4         # padding for more visually appealing wrapping
  _mn_tw=$(termwidth); _mn_collision_threshold=$(( _mn_tw - _mn_status_width - _mn_buffer )) # prep to protect long msg
  [ "$_mn_collision_threshold" -lt 0 ] && _mn_collision_threshold=0   # clamp to 0 if negative
  printf " ${BGon}*${Boff} ";  # print the "prefix *"
  if [ $_mn_msg_len -gt $_mn_collision_threshold ]; then
    echo_n_long -5 $_mn_msg  # use $_mn_msg unquoted for smart word-wrap; room for right_status; -5 to align w indent
  else
     printf "%s" "$*"        # use "$*" quoted to pass a single string
  fi; unset -v _mn_msg _mn_msg_len _mn_status_width _mn_buffer _mn_tw _mn_collision_threshold ; }
# notes on use of echo_n_long, which works mainly for display_vars(0():
#   f$1 is length of longest var_name, _left _right count additional formatting
#    * longestvar .: [ <value>   # even the longest var gets dot pad before :
#   ^^^          ^^^^^
#   lll          rrrrr   l=3 // r=5
#   echo_n_long calculates length of _left=" * "; _right=" .: ["
#   (for clarity/maintainability; could have hard coded numbers)
# implication '==>' message_n must call echo_n_long with negative argument
# message family indent is 3
# echo_n_long will indent to $1 + 8
# so message_n must call echo_n_long -5 $msg (unquoted for word-wrapping)


SAFE_message_n()   # (POSIX) display text message $@ w/o newline
{ printf " ${BGon}*${Boff} "; printf "%s" "$*"; }
# use "$*" to avoid word-split and keep message_n simple
#{ printf " ${BGon}*${Boff} "; echo_n_long -4 $*; }  ## maybe malfunctioned
# use "$*" to calculate message length, but use $* to word-split for smart wrapping
# calling echo_n_long with $1 = -4 because it offsets _indent = $1 + 7 [display_vars format]
#(old){ printf " ${BGon}*${Boff} " ; printf "$@" ; }

W_message()   # (POSIX) display text warning message $@
{ printf " ${BYon}*${Boff} " ; printf "$@\n" ; }

E_message()   # (POSIX) display text error message $@
{ printf " ${BRon}*${Boff} " ; printf "$@\n" ; }

E_message_n()       # (POSIX) display text error message $@ (no CR)
{ printf " ${BRon}*${Boff} " ; printf "$@" ; }

_d_build_and_print() # Internal helper: Not for direct use.
{ # $1 = printf format string; $2...$n = message words and level
  # (level is compare to global verbosity by calling function but ignored by -lt test below)
  _fmt="$1"; shift
  # Use a subshell to avoid changing the original positional parameters ($@)
  ( _msg=""; _i=0; _word_count=$(( $# - 1 ))
    while [ "$_i" -lt "$_word_count" ]; do  # -lt excludes last element (level)
      _msg="${_msg}${_msg:+ }$1"; shift; _i=$((_i + 1)) # ${_msg:+ } is a space if _msg is set; nothing if unset
    done
    printf "$_fmt" "$_msg"
  )
}
# Legacy note; retained as a learning point.
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

d_message()   # (POSIX) IAW verbosity, display text debugging message $@
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print " ${BGon}*${Boff} %b\n" "$@"
  unset -v _level; }

d_message_n()   # (POSIX) IAW verbosity, display text debugging message $@ (no CR)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print " ${BGon}*${Boff} %b" "$@"
  unset -v _level; }

d_echo()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print "%s\n" "$@"
  unset -v _level; }

d_echo_n() # (POSIX) IAW verbosity, display text debugging message $@ (like echo -n)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print "%s" "$@"
  unset -v _level; }

de_echo()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo -e)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print "%b\n" "$@"
  unset -v _level; }

de_echo_n()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo -en)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print "%b" "$@"
  unset -v _level; }

dE_message()   # (POSIX) IAW verbosity, display text debugging error message $@
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print " ${BRon}*${Boff} %b\n" "$@"
  unset -v _level; }

dE_message_n()   # (POSIX) IAW verbosity, display text debugging error message $@ (w/o CR)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_print " ${BRon}*${Boff} %b" "$@"
  unset -v _level; }

#---[ common logging functions ]-----------------------------------------

timestamp()         # (POSIX) echo a simple timestamp (yyyymmdd-hh:mm:ss)
{ printf "%s\n" "$(date +'%Y%m%d-%H:%M:%S')"; }

log_message()       # (POSIX) message() to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; message "$_ts - $*"; printf "%s - %b\n" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_message_n()     # (POSIX) message_n() to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; message_n "$_ts - $*"; printf "%s - %b" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_echo()          # (POSIX) echo to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; printf "%s - %s\n" "$_ts" "$*"; printf "%s - %s\n" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_echo_e()        # (POSIX) echo -e to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; printf "%s - %b\n" "$_ts" "$*"; printf "%s - %b\n" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_echo_n()        # (POSIX) echo -n "$1" to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; printf "%s - %s" "$_ts" "$*"; printf "%s - %s" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_echo_e_n()      # (POSIX) echo -e -n "$1" to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; printf "%s - %b" "$_ts" "$*"; printf "%s - %b" "$_ts" "$*" >> "$logFile"; unset -v _ts; }
# We use "$*" to treat all arguments as a single message string

log_E_message()     # (POSIX) E_message() to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; E_message "$_ts - $*"; printf "%s - %b\n" "$_ts" "$*" >> "$logFile"; unset -v _ts; }

log_E_message_n()   # (POSIX) E_message_n() to stdout and $logFile owned by $user
{ _ts="$(timestamp)"; E_message_n "$_ts - $*"; printf "%s - %b" "$_ts" "$*" >> "$logFile"; unset -v _ts; }


_d_build_and_log() # Internal helper: Not for direct use.
{ # $1 = printf format string; $2 = timestamp; $3...$n = message words and level
  # (level is compare to global verbosity by calling function but ignored by -lt test below)
  # note: _fmt for logging should be "%s - %s"  w/ or w/o \n depending on calling function
  _fmt="$1"; _ts="$2"; shift 2
  # Use a subshell to avoid changing the original positional parameters ($@)
  ( _msg=""; _i=0; _word_count=$(( $# - 1 ))
    while [ "$_i" -lt "$_word_count" ]; do  # -lt excludes last element (level)
      _msg="${_msg}${_msg:+ }$1"; shift; _i=$((_i + 1)) # ${_msg:+ } is a space if _msg is set; nothing if unset
    done
    # remember to pass two strings to match expected format in _fmt
    printf "$_fmt" "$_ts" "$_msg" >> "$logFile"
  )
  unset -v _fmt _ts; }

d_log_message()     # (POSIX) display and log message IAW verbosity
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; d_message "$@" )     # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b\n" "$_ts" "$@"     # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_message_n()     # (POSIX) display and log message IAW verbosity (w/o CR)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; d_message_n "$@" )   # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b" "$_ts" "$@"       # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo()        # (POSIX) display and log simple message IAW verbosity (like echo)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; d_echo "$@" )        # print to console screen (formatted/colored)
    _d_build_and_log "%s - %s\n" "$_ts" "$@"     # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_e()      # (POSIX) display and log simple message IAW verbosity (like echo -e)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; de_echo "$@" )       # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b\n" "$_ts" "$@"     # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_n()      # (POSIX) display and log simple message IAW verbosity (like echo -n)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; d_echo_n "$@" )      # print to console screen (formatted/colored)
    _d_build_and_log "%s - %s" "$_ts" "$@"       # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_echo_e_n()    # (POSIX) display and log simple message IAW verbosity (like echo -en)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; de_echo_n "$@" )     # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b" "$_ts" "$@"       # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_E_message()   # (POSIX) display and log error message IAW verbosity
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; dE_message "$@" )    # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b\n" "$_ts" "$@"     # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

d_log_E_message_n() # (POSIX) display and log error message IAW verbosity (w/o CR)
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  if [ "$_level" -le "$verbosity" ]; then _ts="$(timestamp)";
    ( set -- "$_ts -" "$@"; dE_message_n "$@" )    # print to console screen (formatted/colored)
    _d_build_and_log "%s - %b" "$_ts" "$@"     # print to logFile (clean/text-only)
  fi; unset -v _level _ts; }
# uses a sub-shell to safely rebuild the arguments to include the timestamp

_d_build_and_do() # Internal helper: Not for direct use.
{ (  _i=0; _arg_count=$(( $# - 1 ));
    while [ "$_i" -lt "$_arg_count" ]; do  # -lt excludes last element (level)
      _arg="$1"; shift; set -- "$@" "$_arg"; _i=$((_i + 1))  # ${_args:+ } is a space if _args is set; nothing if unset
    done ; shift  # discard last argument (level)
    "$@" # execute the command parts with original quoting preserved
  ) ; }
# $1= command # $2...$n = command ($1) args ($2 - n-1) and level ($n)
# (level is compare to global verbosity by calling function but ignored by -lt test below)
# Use a subshell to avoid changing the original positional parameters ($@)
# (*** this is trickier with a command and its args, because it is essential not to word-split the args ***)
# use a "rotation" scheme, use set and shift to pull each arg from $1 and append it to the end
# of the list of positional parameters (except, not the last; w/ -lt _arg_count)
# also note: the command itself is the _arg=$1 assigned in the first iteration

debug_do()          # (POSIX) IAW verbosity, display debugging information
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  if [ $# -lt 2 ] || [ -z "$verbosity" ] ; then return 1; fi
  for _level; do :; done; # _level now equals the last argument (equivalent to for _level in "$@"; do :; done)
  [ "$_level" -le "$verbosity" ] && _d_build_and_do "$@"
  unset -v _level; }

status_color()      # (POSIX) emit escape seq for color per arg $1
{ # (T/F Y/N up/down)(1=0=$TRUE [Green], ""=$FALSE [Red])
case $1 in [yY]*|[tT]*|[uU]*|[hH]|"$TRUE"|"0"  ) printf "%b" ${BGon};;
           [nN]*|[fF]*|[dD]*|[lL]|"$FALSE"     ) printf "%b" ${BRon};;
           *) printf "%b" ${BWon};; esac ; }
# Note: "0" is included as part of the "true" line because of the definition TRUE=0 atop this header
#       "1" is NOT included in the "false" (though that would map to exit code use)
#       this is a deliberate choice b/c binary numbering 1/0 is the opposite
#       High/Low and Up/Down are included instead

TrueFalse()         # (POSIX) echo "True" or "False", depending on truth of arg $1
{ # (T/F Y/N up/down)(1=0=$TRUE [Green], ""=$FALSE [Red])
case $1 in [yY]*|[tT]*|[uU]*|[hH]|"$TRUE"|"0" ) printf "%s" "True" ;;
           [nN]*|[fF]*|[dD]*|[lL]|"$FALSE"    ) printf "%s" "False" ;;
           *) printf "%s" "unset" ;; esac ; }
# Note: "0" is included as part of the "true" line because of the definition TRUE=0 atop this header
#       "1" is NOT included in the "false" (though that would map to exit code use)
#       this is a deliberate choice b/c binary numbering 1/0 is the opposite
#       High/Low and Up/Down are included instead

repeat()                # (POSIX) quickly output a string of char $1 (of len $2) (not for spaces)
{ _marker="${1:--}"; _reps="${2:-40}"; [ "${#_marker}" -gt 1 ] && \
  _marker=$(printf -- "%s" "${__marker%${_marker#?}}"); printf "%${_reps}s" | tr ' ' "$_marker" ; }

OLD_repeat()            # (POSIX) slower output a string of char $1 (of len $2)(does spaces)
{ _thing="${1:- }"; _limit="${2:-1}";
  [ "$_limit" -le 0 ] 2>/dev/null && return 0   # if limit is 0 or not a number, exit early
#  [ "${#_thing}" -gt 1 ] && _thing=$(left_most "$_thing"); _out="$_thing";
  [ "${#_thing}" -gt 1 ] && _thing="${_thing%${_thing#?}}"; _out="$_thing"; # i.e. leftmost, w/o a sub-shell
  while [ "${#_out}" -lt "$_limit" ]; do _out="${_out}${_out}"; done
  printf "%.${_limit}s" "$_out" ; unset -v _thing _limit _out ; }
# improves performance rel to earlier versions which appended one char only per loop
# trims to exact length using the precision dot format for printf ( %.[precision]s )
#   this specifies the maximum number of characters to be printed from the string

prompt()            # (POSIX) set external variable $answer based on reponse to prompt $1
{ _ps="$1"; answer=""; printf "%b" "\n\n"; CUU; SCP;
while ! expr "$answer" : '[yYnN]' >/dev/null; do
RCP; printf "%b" "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$_ps [Y/n]: " && read -r answer < /dev/tty; done; unset -v _ps ; }
# Note: answer is an external (global) variable (must be declared in the calling script)

new_prompt()        # (POSIX) set external variable $answer based on reponse to prompt $1
{ _ps="$1"; response=""; printf "%b" "\n\n"; CUU; SCP;
while ! expr "$response" : '[yYnNsS]' >/dev/null; do
RCP; printf "%b" "$(repeat ' ' $(termwidth))";  ## blank the line
RCP; message_n "$_ps [Yes/no/skip|Yns]: " && read -r response < /dev/tty; done; unset -v _ps ; }
# Note: response is an external (global) variable (must be declared in the calling script)

right_most()        # (POSIX) echo the right-most character in a string variable $1
{ _str="$1"; [ -z "$_str" ] && return 1; # guard clause; reject empty string
printf -- "%s" "${_str#${_str%?}}"     # -- prevents printf from treating leading "-" as a flag
unset -v _str; }                       # clean up local variable
# Note: ${_str%?} removes the last character from the string;
#   ${_str#...} tells the shell to "look at the full string and remove the prefix that matches ${_str%?}
#   (together, the only thing left is the last character)
# echo ${_str:$((${#_str}-1)):1};        # other way 1 (non-POSIX string slicing; slower external echo)
# echo ${_str} | sed "s|${_str:0:-1}||"  # other way 2 (non-POSIX string slicing; slower external sed)
# echo ${_str} | rev | cut -c 1 ; }          # other way 3 (non-POSIX rev/cut -c and slower external cut/rev)

left_most()         # (POSIX) echo the left-most character in a string variable $1
{ _str="$1"; [ -z "$_str" ] && return 1
  printf -- "%s" "${_str%${_str#?}}"
  unset -v _str ; }

alpha_words()       # (POSIX) alphabetize the words in a quoted input string
{ [ $# -eq 0 ] && return 0  # guard clause; just return 0 success if no args
  for _x in "$@"; do printf "%s\n" "$_x"; done | LC_ALL=en_US.UTF-8 sort -db 2>/dev/null || \
    for _x in "$@"; do printf "%s\n" "$_x"; done | sort -db # Fallback if UTF-8 locale is missing
  unset -v _x ; }
# sort -d (dictionary): Ignores punctuation and only looks at letters, digits, and blanks
# sort -b (ignore leading blanks) in case string has accidental leading spaces

pur()               # (POSIX) ping ip address $1 until it is ready (0% loss of 3 packets)
{ _pur_target="$1"; SCP; _pur_count=1; _hits=0; _hit_color="${Boff}"; _pur_max_retries=1000 ;
  while [ "$_hits" -lt 3 ] && [ "$_pur_count" -lt "$_pur_max_retries" ]; do
    if ping -c1 -W1 "$_pur_target" >/dev/null 2>&1; then _hits=$((_hits + 1)); else _hits=0; fi;
    case "$_hits" in [01]) _hit_color="${BRon}";; 2) _hit_color="${BYon}";; 3) _hit_color="${BGon}";; esac;
    RCP; printf "%b" "not ready -- try: [${_pur_count}], hits: [${_hit_color}${_hits}${Boff}] ";
    _pur_count=$((_pur_count + 1)); [ "$_hits" -lt 3 ] && sleep 1; done;
  RCP; EL ; # erase from cursor to end of line
  if [ "$_hits" -lt 3 ] ; then
    RCP; E_message "timed out"; unset -v _pur_target _pur_count _hits _hit_color _pur_max_retries; return 1 ;
  else
    RCP; message "${BGon}OK${Boff} - ready now" ; unset -v _pur_target _pur_count _hits _hit_color _pur_max_retries; return 0 ;
  fi ; }

swr()               # (POSIX) use pur() to check first; then ssh when netcat indicates port is ready
{ [ $# -lt 1 ] && return 1 ;   # guard; reject null target
  _swr_target="$1"; _swr_max_retries=10; _swr_count=0; _ssh_port="${2:-22}";  # default to port 22 but allow another to be specified as $2
  _yellow_thresh=$(($_swr_max_retries * 33/100)); _red_thresh=$(($_swr_max_retries * 75/100));
  pur "$_swr_target";
  if [ ! $? -eq 0 ] ; then
    E_message "pur() failed or timed out";
    unset -v _swr_target _ssh_port _swr_max_retries _swr_count _swr_color _yellow_thresh _red_thresh
    return 1;
  fi;
  message "confirming $1 has started sshd on port $_ssh_port ..." ; SCP;
  # use netcat to verify port is open on target (one hit is sufficient)
  while [ "$_swr_count" -lt "$_swr_max_retries" ] && ! nc -z -w 1 "$_swr_target" "$_ssh_port" 2>/dev/null; do
    RCP; EL;
    # set colors with POSIX logic
    if [ "$_swr_count" -le "$_yellow_thresh" ]; then
      _swr_color="${BGon}"
    elif [ "$_swr_count" -le "$_red_thresh" ]; then
      _swr_color="${BYon}"
    else
      _swr_color="${BRon}"
    fi
      printf "checking port %s -- try: [%b] " "$_ssh_port" "${_swr_color}${_swr_count}${Boff}";
    _swr_count=$((_swr_count + 1)); sleep 1; done;
  # test nc one last time to ensure the loop exited for success, not timeout
  if nc -z -w 1 "$_swr_target" "$_ssh_port" 2>/dev/null; then
    RCP; EL; message "${BGon}OK${Boff} - $_swr_target sshd is ready"
    ssh -p "$_ssh_port" "$_swr_target"
    _result=0
  else
    RCP; EL; E_message "sshd port $_ssh_port on $_swr_target not responding after $_swr_max_retries tries"
    _result=1
  fi
  unset -v _swr_target _ssh_port _swr_max_retries _swr_count _swr_color _yellow_thresh _red_thresh
  return $_result; }

vercomp()           # (almost POSIX) compare versions return [0:equal|1:greaterthan|2:lessthan]
{ _candidate1="$1"; _candidate2="$2"; _first=""
  if [ "$_candidate1" = "$_candidate2" ]; then
    unset -v _candidate1 _candidate2 _first
    return 0;
  else
     _first=$(printf "%b" "$1\n$2" | sort -V | head -n1);
    if [ "$_first" = "$_candidate2" ]; then
      unset -v _candidate1 _candidate2 _first
      return 1;
    else
      unset -v _candidate1 _candidate2 _first
      return 2;
    fi;  # _first
  fi;  # _candidates
}

show_result()       # (POSIX) show the result of vercomp comparison, in english
{ case $1 in 1) printf "%b\n" "${BCon}>${Boff}";; 2) printf "%b\n" "${BRon}<${Boff}";; \
             0) printf "%b\n" "${BGon}=${Boff}";; *) printf "%b\n" "${BYon}*** Error ***${Boff}";; esac }

my_date()           # (POSIX) echo date string (DDD MM dd hh:mm:ss TZ yyyy)
{ _date_string=$(date "+%a %b %d %H:%M:%S %Z %Y"); printf "%s\n" "$_date_string" ; unset -v _date_string; }

my_short_date()     # (POSIX) echo shorter date string (yyyymmdd-timehack)
{ _date_string=$(date "+%Y%m%d-%H:%M:%S"); printf "%s\n" "$_date_string" ; unset -v _date_string; }

loggit()            # (POSIX) send a job completion status message to the cron logger
{ [ $# -gt 2 ] && { E_message "invalid loggit arguments" ; return 1; }
  _loggit_exit_status="${2:-0}"
  _loggit_program="${1:-Unspecified}"
  case "$_loggit_exit_status" in
    0 ) _loggit_priority="notice"; _loggit_message="succeeded.";;
    * ) _loggit_priority="err"; _loggit_message="failed with exit status ${_loggit_exit_status}.";;
  esac
  logger -p "cron.$_loggit_priority" "$_loggit_program $_loggit_message"
  unset -v _loggit_exit_status _loggit_program _loggit_priority _loggit_message
}

log_handle_result() # output ok_/_err_msg and right_stats to stdout and logFile
{ _exit_status="$1"; _ok_msg_in="$2"; _err_msg_in="$3"
  if [ "$_ok_msg_in" = "${no_msg}" ] ; then _ok_msg=""; else _ok_msg=" (${BGon}${2:-success!}${Boff})"; fi
  if [ "$_err_msg_in" = "${no_msg}" ] ; then _err_msg=""; else _err_msg=" (${BRon}${3:-error!}${Boff})"; fi
  if [ "$_exit_status" -eq 0 ] ; then
      log_echo_e_n "${_ok_msg}"
      log_right_status $TRUE
  else
      log_echo_e_n "${_err_msg}"
      log_right_status 1
      unset -v _exit_status _ok_msg _err_msg _ok_msg_in _err_msg_in
      return 1
  fi
  unset -v _exit_status _ok_msg _err_msg _ok_msg_in _err_msg_in
  return 0; }
# *()* usage - log_message_n ...; <command>] ; log_handle_result "$?" "_ok_msg" "_err_msg"
# *()* notes - substitute no_msg=" \b" for either, to "suppress"

validate_logfile()  # validate existence and ownership of logFile
{ d_log_message "in validate_logfile" 5
  _logFile_owner_uid=""; _logFile_group_gid=""
  _user_uid=""; _user_gid=""
  _msg=""
  log_message_n "looking for logFile [${logFile}]"
  if [ ! -f "${logFile}" ] ; then
      log_echo_e_n " (${BRon}not found${Boff})"
      log_right_status 1
      _msg="logFile [${logFile}] not found\n"
      _msg="${_msg}${BRon}Please run (as root) ${BGon}touch ${logFile}; chown ${user}:${user} ${logFile}${Boff}"
      log_E_message "${_msg}"
      unset -v _logFile_owner_uid _logFile_group_gid _user_uid _user_gid _msg
      return 1
  else
      log_echo_e_n " (${BGon}found${Boff})"
      log_right_status $TRUE
      log_message_n "checking logFile ownership"
      _logFile_owner_uid=$(ls -n "${logFile}" | awk '{print $3}')
      _logFile_group_gid=$(ls -n "${logFile}" | awk '{print $4}')
      _user_uid=$(id -u "${user}")
      _user_gid=$(id -g "${user}")
      if [ "${_logFile_owner_uid}:${_logFile_group_gid}" = "${_user_uid}:${_user_gid}" ] ; then
          log_echo_e_n " (${BGon}${_logFile_owner_uid}:${_logFile_group_gid}${Boff})"
          log_right_status $TRUE
      else
          log_echo_e_n "(${BRon}${_logFile_owner_uid}:${_logFile_group_gid}${Boff})"
          right_status 1
          _msg="bad ownership on logFile [${logFile}]\n"
          _msg="${_msg}${BRon}Please run (as root) ${BGon}chown ${user}:${user} ${logFile}${Boff}"
          log_E_message "${_msg}"
          unset -v _logFile_owner_uid _logFile_group_gid _user_uid _user_gid _msg
          return 1
      fi # ownership
  fi # existence
  unset -v _logFile_owner_uid _logFile_group_gid _user_uid _user_gid _msg
  return 0
}
# *()* reminder - no arrays in ash/busybox, so don't use ${FUNCNAME[0]}
# *()* reminder - in ash, the =+ operator works for arithmetic but not text concatenation
# *()* reminder - logFile and user must be set apriori

termwidth()         # (POSIX plus) calculate and output the width of the terminal
{ _cols="$COLUMNS"   # prefer environment variable; if null try tput; or fall back to stty
  [ -z "$_cols" ] && _cols=$(tput cols 2>/dev/null)
  [ -z "$_cols" ] && _cols=$(stty size < /dev/tty 2>/dev/null | cut -d' ' -f2)
  printf "%s" "${_cols:-80}"   # fall back to default (standard) 80 cols if none of above worked
  unset -v _cols ; }

termheight()        # (POSIX plus) calculate and output the height of the terminal
{ _rows="$LINES"   # prefer environment variable; if null try tput; or fall back to stty
  [ -z "$_rows" ] && _rows=$(tput lines 2>/dev/null)
  [ -z "$_rows" ] && _rows=$(stty size < /dev/tty 2>/dev/null | cut -d' ' -f1)
  printf "%s" "${_rows:-25}"   # fall back to default (standard) 25 lines if none of above worked
  unset -v _rows ; }

separator()         # draw a horizontal line with preface $1 and title $2
{ # to facilitate separation of portions of the output of various scripts
  _s_preface=${1:-$(hostname)}; _s_title=${2:-$(basename "$0")}; _s_tw=$(termwidth)
  _s_reps=$(( _s_tw - ( ${#_s_preface} + ${#_s_title} + 8 ) ))
  [ "$_s_reps" -lt 0 ] && _s_reps=0  # clamp to 0 if negative
  printf "%b" "${BYon}---[${BRon} ${_s_preface} ${BCon}${_s_title} ${BYon}]"
  repeat '-' "$_s_reps"; printf "%b\n" "${Boff}"
  unset -v _s_preface _s_title _s_tw _s_reps; }

log_separator()     # (POSIX) output separator() to stdout and similar to logFile
{ _ls_preface=${1:-$(hostname)}; _ls_title=${2:-$(basename "$0")}
  _ls_ts="$(timestamp)"; _ls_tw=80  # standard fixed width for log files
  # construct the header string: "timestamp - ---[ preface title ]"
  _ls_clean_header="${_ls_ts} - ---[ ${_ls_preface} ${_ls_title} ]"
  _ls_reps=$(( _ls_tw - ${#_ls_clean_header} ))  # calculate the length of the rest of the  ----- line
  [ "$_ls_reps" -lt 0 ] && _ls_reps=0      # if negative, clamp to 0
  # output (console screen first, then log)
  separator "$_ls_preface" "$_ls_title"    # out to console screen
  # output a "clean" version (w/o colors) to the log file
  { printf "%s" "$_ls_clean_header"
    repeat '-' "$_ls_reps"
    printf "\n"
  } >> "$logFile"
  unset -v _ls_preface _ls_title _ls_ts _ls_clean_header _ls_reps ; }

print_center()      # (POSIX) print text $2 centered on row $1
{ _pc_row="$1"; _pc_text="$2"; _pc_w=$(termwidth)
  _pc_len=${#_pc_text}; _pc_col=$(( (_pc_w / 2) - (_pc_len / 2) ))
  [ "$_pc_col" -lt 1 ] && _pc_col=1  # Prevent negative/zero column
  CUP "$_pc_row" "$_pc_col" ; printf "%s" "$_pc_text" ;
  unset -v _pc_row _pc_text _pc_w _pc_len _pc_col ; }

test_colors()      # (POSIX) print the joetoo RGB name of each eponymous color
{ _rgb_color_names="BLACK RED GREEN YELLOW BLUE MAG CYAN WHITE"
  _h=$(termheight); _w=$(termwidth); _current_row=$(( (_h / 2) - 4 )); _c_idx=0
  # ensure start row is within screen bounds
  if [ "$_current_row" -lt 1 ]; then _current_row=1; fi
  for _name in $_rgb_color_names; do
    _fg_code=$(( 30 + _c_idx ))
    _bg_code="${BG_DEFAULT}"
    # special case: if text is BLACK (30), set background to WHITE (47)
    if [ "$_fg_code" -eq "${BLACK}" ]; then _bg_code="${WBACK}"; fi;
    _esc_start=$(color "$_fg_code" 0 "$_bg_code")
    _colored_text="${_esc_start}${_name}${Boff}"
    # centering logic (use the raw name length)
    _col=$(( (_w / 2) - (${#_name} / 2) ))
    CUP "$_current_row" "$_col"
    printf "%b" "$_colored_text"
#    printf "%b" "$(CUP "$_current_row" "$_col") $_colored_text"
    _current_row=$(( _current_row + 1 ))
    _c_idx=$(( _c_idx + 1 ))
  done
  CUP "$_h" 1
#  printf "%b" "$(CUP "$_h" 1)"
  unset -v _rgb_color_names _h _current_row _c_idx _name _fg_code \
      _bg_code _esc_start _esc_reset _colored_text _w _col ; }

test_terminal() {
    # clear screen and show dimensions
    CLR
    _W=$(termwidth)
    _H=$(termheight)
    # test absolute positioning (CUP) - print an X in each corner
    CUP 1 1; printf "X"
    CUP 1 "$_W"; printf "X"
    CUP "$_H" 1; printf "X"
    CUP "$_H" "$_W"; printf "X"
    # test centering
    _msg="Terminal: ${_W}x${_H}"
    _msg_len=${#_msg}
    _start_col=$(( (_W / 2) - (_msg_len / 2) )) # start message half-its-length left of center
    _start_row=$(( (_H / 2) - 10 ))             # start far enough above middle to leave room for colors
    CUP "$_start_row" "$_start_col"; SCP
    printf "%s" "_msg_len: $_msg_len"; RCP; CUD; SCP
    printf "%s\n" "$_msg"
    # run test_colors()
    test_colors
    # test save/restore cursor (SCP/RCP)
    CUP $((_start_row + 2)) "$_start_col"
    printf "Saving cursor position..."
    SCP
    # move away ...
    CUP 1 5 ; printf "[Moving]"
    # restore cursor to saved position and finish
    RCP; printf " ...Restored!"
    # test repeat() by drawing a screen-wide line of "=" chars
    CUP $((_start_row + 4)) 1
    repeat "=" "$_W"
    # move cursor to bottom for prompt
    CUP $(("$_H"-2)) 1; printf "\nTest Complete. Press Enter"
    read _junk < /dev/tty
    unset -v _W _H _msg _msg_len _start_col _start_row _junk
}

show_config()       # show config with get_longest and display_vars
{ d_message "in show_config" 5 ; separator "${PN}-${BUILD}" "(configuration)"
  _longest=$(get_longest ${varlist}) ; display_vars ${_longest} ${varlist} ; 
  unset -v _longest; }

log_show_config()   # show & log config w get_longest() and display_vars
{ d_log_message "in lg_show_config" 5 ; log_separator "${PN}-${BUILD}" "(configuration)"
  _longest=$(get_longest ${varlist}) ; display_vars "${_longest}" ${varlist}
  # strip ANSI codes and append to logFile
  display_vars "${_longest}" ${varlist} | sed 's/\x1b\[[0-9;]*m//g' >> "$logFile"
  unset -v _longest; }
# Note: regex pattern s/\x1b\[[0-9;]*m//g is standard for matching almost all SGR (Select Graphic Rendition) parameters

get_longest()       # echo length of longest string in input $@
{ _ans=0; for _x in $@; do [ ${#_x} -gt $_ans ] && _ans=${#_x}; done ; printf "%s" "$_ans"; unset -v _ans _x; }

display_vars()      # show vals for vars in $@; incl bool/lv/; $1=longest
{
  if ! isnumber $1 ; then
    E_message "Error: arg \$1 must be numeric longest expected input var name"
    exit
  fi
  if [ $# -le 1 ] ; then set $@ "<empty>"; fi  # insert placeholder "<empty>" as $2
  _dv_maxlen=$(($1 + 2))
  shift
  for _dv_var_name in $@
  do
  case "$_dv_var_name" in
    *.* )  # display by type
      _dv_type="${_dv_var_name%.*}"   # strip off chars right of and .
      _dv_var="${_dv_var_name#*.}"    # strip off chars left of and .
      _dv_pad=" $(repeat '.' $(( ${_dv_maxlen} - ${#_dv_var})) )"
      case ${_dv_type} in
        [bB]*  )
          eval "_dv_key=\$${_dv_var}"
          message "${BCon}${_dv_var}${_dv_pad}: [ $(status_color ${_dv_key})$(TrueFalse ${_dv_key}) ${BCon}]${Boff}"
          ;;
        [yY]*  )
          eval "_dv_key=\$${_dv_var}"
          message "${BCon}${_dv_var}${_dv_pad}: [ $(status_color ${_dv_key})${_dv_key} ${BCon}]${Boff}"
          ;;
        [lL]*  )
          eval "_dv_key=\$${_dv_var}"
          message_n "${BCon}${_dv_var}${_dv_pad}: [ ${Boff}"
          # use with ${_dv_key} (unquoted) so echo_n_long can split and wrap words properly
          echo_n_long "${_dv_maxlen}" ${_dv_key}
          printf "%b\n" " ${BCon}]${Boff}"
          ;;
        *      )
          # invalid variable _dv_type
          E_message "  (${_dv_type}) invalid variable type [${_dv_type}] for variable [${_dv_var_name}]"
          exit
          ;;
      esac
      ;;
    BREAK) printf "\n" ;; # BREAK, obviously (ignore it)
    * ) # untyped
      _dv_type=""
      _dv_var="$_dv_var_name"
      eval "_dv_key=\$${_dv_var}"
      _dv_pad=" $(repeat '.' $(( ${_dv_maxlen} - ${#_dv_var})) )"
      message "${BCon}${_dv_var}${_dv_pad}: [ ${Boff}${_dv_key} ${BCon}]${Boff}"
      ;;
    esac
  done
  unset -v _dv_maxlen _dv_var_name _dv_type _dv_var _dv_pad _dv_key ; }

initialize_vars()   # initialize values for vars in $@; incl bool. lv.
{ # returns 0: success; 1: fail (no args); 2: fail (invalid type)
  [ $# -lt 1 ] && {   unset -v _iv_item _iv_parmlist _iv_var_name _iv_type _iv_var; return 1; }
  _iv_parmlist=""
  for _iv_item in "$@"; do case "$_iv_item" in
      *verbosity*|*bool.VERBOSE*|*VERBOSE*) continue ;;
      *) _iv_parmlist="$_iv_parmlist $_iv_item" ;;
  esac; done
  d_message "initializing vars: $_iv_parmlist" 5
  for _iv_var_name in $_iv_parmlist
  do
    case $_iv_var_name in
      *.* )   # if echo $_iv_var_name | grep -q "\."; then
        # initialize by type
        _iv_type="${_iv_var_name%.*}"   # strip off chars right of and .
        _iv_var="${_iv_var_name#*.}"    # strip off chars left of and .
        case ${_iv_type} in
          [bB]*  )
            # (set $FALSE) boolean convention: parameter is "bool.${_iv_var}" where ${_iv_var} is e.g. "VERBOSE"
            d_message_n "  (${_iv_type}) initializing ${_iv_var} FALSE ..." 2
            eval "${_iv_var}=\"\$FALSE\"" ; d_right_status $? 2
          ;;
          [yY]*  )
            # (set "no") yes/no convention: parameter is "yn.${_iv_var}" where ${_iv_var} is e.g. "EIX"
            d_message_n "  (${_iv_type}) initializing ${_iv_var} (no) ..." 2
            eval "${_iv_var}='no'" ; d_right_status $? 2
          ;;
          [lL]*  )
            # (set "") lonstring convention: parameter is "lv.${_iv_var}" where ${_iv_var} is e.g. "CMDLINE"
            d_message_n "  (${_iv_type}) initializing ${_iv_var} NULL ..." 2
            eval "${_iv_var}=''" ; d_right_status $? 2
          ;;
          *      )
            # invalid variable _iv_type
            eval "${_iv_var}=''" ; d_right_status $? 2
            unset -v _iv_item _iv_parmlist _iv_var_name _iv_type _iv_var
            return 2
          ;;
        esac  # type
        ;;
      "BREAK" )  # elif [ "$_iv_var_name" = "BREAK" ] ; then
        # ignore BREAK
        _iv_type=""
        d_message_n "  ignoring BREAK ..." 2
        d_right_status $TRUE 2
        ;;
      * )  # else
        # untyped - initialize null
        _iv_type=""
        _iv_var="$_iv_var_name"
        d_message_n "  (${_iv_type}) initializing ${_iv_var} NULL ..." 2
        eval "${_iv_var}=''" ; d_right_status $? 2
        ;;
    esac  # _iv_var_name (fi)
    d_message "about to initialize $_iv_var_name of _iv_type: [ $_iv_type ]" 4
  done
  unset -v _iv_item _iv_parmlist _iv_var_name _iv_type _iv_var
  return 0; }

_get_msg_len()      # helper not to be called directly (get actual printable length of message)
{ # strip ANSI escape sequences, and use ${#var} to count what remains
  [ $# -lt 1 ] && return 1   # guard clause; reject if no message
  _stripped=$(printf "%b" "$*" | sed 's/\x1b\[[0-9;]*[mK]//g')
  _len="${#_stripped}"; echo "${_len:-0}" # if empty, return 0 
  unset -v _stripped _len; }
# use "$*" rather than "$1" to accomodate accidentally word-split messages

echo_n_long()       # wordwrap string; $1 = indent (e.g. align on " * " bullet, or column for var_names)
{  #echo -e "args: $@"; message "args: $@"; d_message "args: $@" 1
if ! isnumber $1 ; then E_message "Error: arg \$1 must be numeric starting caracter position"; return 1; fi
  [ $# -le 1 ] && set -- "$1" "<empty>"  # guard clause 2; set a default argument to "<empty>" if none provided
  # empirical offset calculations (_indent on left, _collision_limit on right for last wrap)
  # $1 is length of longest var_name, _left _right count additional formatting
  # * longestvar .: [ <value>   # even the longest var gets dot pad before :
  #^^^          ^^^^^
  #lll          rrrrr   l=3 // r=7
  _left=" * "; _right=" .: ["    # this for clarity/maintainability; could have hard coded numbers
  _left_len=${#_left}; _right_len=${#_right}
  _longest="$1"; shift  # remove the indent arg, leaving the message words in $@
  _indent=$(( _longest + _left_len + _right_len ))
  _tw=$(termwidth); isnumber "$_tw" || _tw=80  # ensure _tw is a save number for math
  _line_len="$_indent"
  # calculate the "right_status collision zone" so the last wrap keeps us clear of it
  _status_width=6   # e.g. "[ Ok ]" = 6 char
  _buffer=4         # padding for more visually appealing wrapping
  _collision_limit=$(( _tw - _status_width - _buffer ))
  [ "$_collision_limit" -lt 0 ] && _collision_limit=0  # clamp to avoid negative math errors
  set -f  # Disable globbing to prevent interpretation of "*" as wildcard to be expanded, etc.
  # smartly consider whether to print each word or wrap it to the _indent
  FIRST_WORD=$TRUE  # don't wrap for first word
  while [ $# -gt 0 ]; do
    # measure the length of remaining message
    _total_tail_len=$(_get_msg_len "$*")
    # if not the first word check if the remaining message will cross the collision limit...
    if [ $FIRST_WORD ]; then
        # start of line case (do we finish or step?)
        if [ $(( _line_len + _total_tail_len )) -le $_collision_limit ]; then
            printf "%s" "$*"; break                       # FINISH: it all fits, so print it all! (we're done)
        else  # start of like, the whole thing wont fit, only option is to print first word)(too bad if too big**)
            _x="$1"; _x_len=$(_get_msg_len "$_x"); shift   # STEP: assign word, measure, then drop from remaining message
            printf "%s" "$_x"                              #   print this word (start of line)
            _line_len=$(( _line_len + _x_len ))
            FIRST_WORD=$FALSE
        fi  # start-of-line finish or step
    else  # mid-line case (do we finish or step?)
        _x_peak=$1; _x_peak_len=$(_get_msg_len "$_x_peak") # preview; don't shift until necessary
        if [ $(( _line_len + _total_tail_len + 1 )) -le $_collision_limit ]; then
            printf " %s" "$*"; break                       # FINISH: it all fits, so print it all! (we're done)
        elif [ $(( _line_len + $(_get_msg_len ${1}) + 1 )) -le $_tw ]; then
            _x="$_x_peak"; _x_len="$_x_peak_len"; shift    # STEP: assign word, measure, then drop from remaining message
            printf " %s" "$_x"                             #   print this word (it will fit)
            _line_len=$(( _line_len + _x_len + 1 ))
            # FIRST_WORD remains $FALSE
        else
            printf "\n%s" "$(repeat ' ' $_indent)"         # WRAP: word wont fit, so print newline and indent
            _line_len=$_indent; FIRST_WORD=$TRUE
        fi  # mid-line finish, step, or wrap
    fi  # first word?
  done
  set +f  # re-enable globbing
  # clean up variables to maintain "local" scope in sourced environments
  unset -v _left _right _left_len _right_len _indent _tw _line_len _status_width _buffer \
  _collision_limit _total_tail_len _x _x_len _longest FIRST_WORD __x_peak _x_peak_len ; }
# Notes:
# generalized to use in message() family of functions as well as display_vars
#   display_vars indents to columnarize the varlist,
#   message indents to align on its "bullet" indent like outlining
# 'set -- ...' (used in guard above) tells the command to stop looking for options;
#   everything that follows is a positional argument (so e.g. "-o" or "--example"
#   won't be seen as command options
# echo_n_long is called by display_vars to employ a word wrapping strategy to display the text that follows
#   the first argument sent to echo_n_long ... the first argument sent to echo_n_long must be a number
#   indicating the length of the longest variable name being displayed by display_vars,
#   thus establishing the width of the variable name "column" of output.
# I intentionally use "for _x in $@; do" in order to guard against the possibility that the text to be displayed
#   by echo_n_long might already be word-split (e.g. passed as a variable without quotes like
#   echo_n_long 15 ${really_long_string_of_words}
# I do intentionally want it to wrap on words, so I need them split


right_status()      # output 8 char [ ok/fail ] status at the right margin
{ # test message_n "good_test" ; right_status $?
  #      E_message_n "fail_test" && cat unexistent 2>/dev/null; right_status $?
  [ $# -lt 1 ] && return 1
  _rs_status=$1; _rs_msg=""
  if [ "$_rs_status" -eq 0 ] ; then
    _rs_msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}"
  else
    _rs_msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}"
  fi
  # go to start of line, *then* move fwd to 7 chars from the right margin
  # Note: "[ xx ]" is 6 chars, so this should ensure no accidental extra line wrap
  _rs_tw=$(termwidth)
  # ensure we have a valid width for arithmetic
  isnumber "$_rs_tw" || _rs_tw=80
  # calculate movement value separately for clarity/safety
  _rs_move=$(( _rs_tw - 7 ))
  # clamp move value to 0 to prevent negative arguments to CUF
  [ "$_rs_move" -lt 0 ] && _rs_move=0
  # move
  printf "%b" "\r"  # beginning of current line (return 1 if failed)
  if ! CUF "$_rs_move" ; then unset -v _rs_status _rs_msg _rs_tw _rs_move; return 1; fi
  # final status output
  printf "%b" "${_rs_msg}\n"; unset -v _rs_status _rs_msg _rs_tw _rs_move; return 0; }

log_right_status()  # output rigit_status to stdout and logFile 
{ [ $# -lt 1 ] && return 1;  # guard; reject empty message
  _lrs_status=$1; if [ "$_lrs_status" -eq 0 ] ; then
    _lrs_msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}"
    _lrs_plain="[ Ok ]"
  else
    _lrs_msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}"
    _lrs_plain="[ !! ]"
  fi
  _lrs_ts=$(timestamp); _lrs_tw=$(termwidth)
  isnumber "$_lrs_tw" || _lrs_tw=80  # fallback to standard 80 cols
  printf "\r"
  if CUF $(( "$_lrs_tw" - 7 )) ; then printf "%b\n" "$_lrs_msg"; else printf " %b\n" "$_lrs_msg"; fi
  # clean logging
  if [ -n "$logFile" ]; then
    printf "%s - %s\n" "$_lrs_ts" "$_lrs_plain" >> "$logFile" || \
      { unset -v _lrs_msg _lrs_status _lrs_plain _lrs_tw _lrs_ts; return 1 ; }
  fi
  unset -v _lrs_msg _lrs_status _lrs_plain _lrs_tw _lrs_ts; return 0 ; }

d_right_status()    # output rigit_status IAW verbosity
{ [ $# -lt 1 ] && return 1 ;  # guard; reject empty message
  _drs_status=$1
  _drs_req_lvl=${2:-3} # default to level 3 (test verbosity vs) if not specified
  if [ "$VERBOSE" ] && [ "${verbosity:-3}" -ge "$_drs_req_lvl" ] ; then
    right_status "$_drs_status" || { unset -v _drs_status _drs_req_lvl; return 1 ; }
  fi; unset -v _drs_status _drs_req_lvl; return 0 ; }

d_log_right_status()# output log_right_status IAW verbosity
{ [ $# -lt 1 ] && return 1 # guard; reject empty message
  _dlrs_status=$1
  _dlrs_req_lvl=${2:-3}
  if [ "$VERBOSE" ] && [ "${verbosity:-3}" -ge "$_dlrs_req_lvl" ] ; then
    log_right_status "$_dlrs_status" || { unset -v _dlrs_status _dlrs_req_lvl; return 1 ; }
  fi; unset -v _dlrs_status _dlrs_req_lvl; return 0 ; }

sh_countdown()      # count-down seconds (arg $1)
{ # special note: bb sh cannot use base#number notation with prefix 10# to ensure interpretation as base 10
  _shc_rem_time="${1:-30}"  # guard; default to 30 sec. if no arg given
  [ "$1" = "" ] && message "No argument given, defaulting to 30 seconds"
  # execute countdown
  while [ "${_shc_rem_time}" -ge "0" ] ; do  # use -ge 0 to display the final state
    # bucket 1 - includes CSI + text + CSI
    # bucket 2 - the 2-digit integer formatted by %02d
    # bucket 3 - includes CSI + text + eraser spaces
    printf "\r%b%02d%b" \
      "${BGon}*${Boff} Pausing. [ ${BGon}" "$_shc_rem_time" "${Boff} ] seconds remaining...   "
    # exit loop immediatly after reaching/printing 00 (don't do "last" sleep cycle)
    [ "$_shc_rem_time" -eq 0 ] && break
    sleep 1; _shc_rem_time=$(($_shc_rem_time - 1))
  done
  printf "\n"  #clean up the line for the next command
  unset -v _shc_rem_time ; return 0 ; }

progress_inline() # show progress of silent process on next line $1=step, $2=total
{ _p_step=$1; _p_total=$2; _p_tw=$(termwidth); isnumber "$_p_tw" || _p_tw=80
  _p_percent=$(( (100 * _p_step) / _p_total ))
  # use 1/4 of screen width for the bar to keep room for text
  _p_bar_max=$(( _p_tw / 4 ))
  _p_filled=$(( (_p_bar_max * _p_step) / _p_total ))
  _p_empty=$(( _p_bar_max - _p_filled ))
  # determine which color to use for the "filled" markers and text NN% marker (heat map style)
  if [ "$_p_percent" -ge 90 ]; then _p_color="${BGon}"    # hot-good
  elif [ "$_p_percent" -ge 60 ]; then _p_color="${Gon}"   # warm-ok
  elif [ "$_p_percent" -ge 40 ]; then _p_color="${BCon}"  # luke-warm
  elif [ "$_p_percent" -ge 20 ]; then _p_color="${Yon}"  # luke-warm
  else _p_color="${Ron}"; fi                              # cold

  # print inline with console output by using carriage return \r
  # assuming the process is silent, this stays on one line until the task is done
  # BUCKETS: - 1:markers_done 2:markers_not_done 3:color 4: xx% 5:reset 6:step 7:total
  # this printf command is going to be over 190 characters, and I don't like using "\"
  # to break commands over multiple lines because you cannot safely copy/paste those lines
  # (e.g. for testing in another terminal), so I will use set to build it up
  #   start with the format string (see BUCKETS above note %b vs %s for ANSI color etc)
  set -- "\r Working: [%b%b] %b%3d%%%b (%d/%d)"
  #   append the bar segment buckets
  set -- "$@" "${_p_color}$(repeat "#" $_p_filled)${Boff}"
  set -- "$@" "${BBon}$(repeat "." $_p_empty)${Boff}"
  #   append the remaining status variables
  set -- "$@" "${_p_color}" "$_p_percent" "${Boff}" "$_p_step" "$_p_total"
  #   execute (double quotes are vital here, to preserve the quoting of the arguments)
  printf "$@"
#  printf "\r Working: [%b%b] %b%3d%%%b (%d/%d)" \
#    "${_p_color}$(repeat "#" $_p_filled)${Boff}" \
#    "${BBon}$(repeat "." $_p_empty)${Boff}" \
#    "${_p_color}" "$_p_percent" "${Boff}" "$_p_step" "$_p_total"
  # on 100%, move to next line so the bar remains as a record
  [ "$_p_step" -eq "$_p_total" ] && printf "\n"
  unset -v _p_step _p_total _p_tw _p_percent _p_bar_max _p_filled _p_empty _p_color ; }


fe()                # find ebuild files matching filter "*$1*"
{ [ $# -lt 1 ] && { E_message "please specify ebuild patter for search filter"; return 1 ; }
  _fe_repo_dir="/var/db/repos/"; _fe_filter="*$1*.ebuild"
  printf "%s\n" "${BYon}looking for ebuild(s) matching filter${Boff}: \"${Mon}${_fe_filter}${Boff}\""
  _fe_output=$(find "${_fe_repo_dir}" -iname "${_fe_filter}" -type f -print 2>/dev/null)
  if [ -z "${_fe_output}" ] ; then
    E_message "no files matching ${_fe_filter} found in ${_fe_repo_dir}"
    unset -v _fe_repo_dir _fe_filter _fe_output ; return 1
  else
    printf "%s\n" "${BWon}${_fe_output}${Boff}"
  fi
  unset -v _fe_repo_dir _fe_filter _fe_output ; return 0 ; }

non_stty_separator()       # (deprecated; use separator)
{
  E_message "${BYon}Warning:${Boff} non_stty_separator is deprecated (use separator(), which has been upgraded)"
  separator "$@"
}

non_stty_right_status()    # (deprecated; use right_status)
{
  E_message "${BYon}Warning:${Boff} non_stty_right_status is deprecated (use right_status(), which has been upgraded)"
  right_status "$@"
}

confirm_continue_or_exit() # prompt() for confirm to continue (answer must be set globally)
{ answer="" ; _cce_msg="${BYon}Do you want to continue?" ; prompt "${_cce_msg}"
    case ${answer} in
        [yY]* ) message "Affirmative response from user; continuing" ;;
        [nN]* ) E_message "Negative response from user; quitting";
                # safeguard: only exit if running as a script, otherwise return 1
                case "$-" in
                    *i*) return 1 ;; # interactive: just return failure
                      *)   exit 1 ;; # script: kill execution
                esac ;;
        * ) E_message "invalid response to confirm_continue_or_exit"; return 1 ;;
    esac ; unset -v _cce_msg; return 0 ; }

die()                      # display reason with E_message and exit with status 1
{ _die_msg="${1:-"unknown fatal error"}" ; E_message "${BRon}FATAL: ${_die_msg}${Boff}"
  unset -v _die_msg
  case "$-" in       # use the $- (current shell flags/options)
    *i*) return 1 ;; # interactive: return failure to terminal
    *)   exit 1   ;; # script: exit with error code
  esac; }

get_luks_keyfile()         # use arg1 (_glk_crypt_keydev) to identify keyfile
{ # Note: crypt_keydev_mountpoint must be globally defined by the calling script
  [ $# -lt 1 ] && { E_message "please specify crypt_keydev as arg \$1"; return 1 ; }
  _glk_crypt_keydev="$1"
  # ensure trailing slashes are removed for a clean grep match
  _glk_mnt_fixed="${crypt_keydev_mountpoint%/}"
  # determine keydev type
  # if it starts with "/" it is a device name
  # if it contains "-" it may be a UUID
  # if it does not, it may be a LABEL
  message_n "examining _glk_crypt_keydev [ ${_glk_crypt_keydev} ] ..."
  # determine keydev type (POSIX case is faster than grep)
  case "${_glk_crypt_keydev}" in
    /*)   _glk_crypt_keydev_type="devicename" ;;
    *-*)  _glk_crypt_keydev_type="UUID" ;;
    *)    _glk_crypt_keydev_type="LABEL" ;;
  esac
  printf "%b" " (${Mon}${_glk_crypt_keydev_type}${Boff})"; right_status $TRUE
  # if _glk_crypt_keydev is not mounted, try to mount it
  # safe grep: match space-padded " /path " exactly to avoid partial directory false-matches
  # check /proc/mounts directly as the source of truth
  if grep -q " ${_glk_mnt_fixed} " /proc/mounts; then
    printf "%b" " (${BGon}mounted${Boff})"
    right_status $TRUE
  else
    message_n "trying to mount (${_glk_crypt_keydev_type}) [${_glk_crypt_keydev}] ..."
    case $_glk_crypt_keydev_type in
       "devicename" ) mount "${_glk_crypt_keydev}" "${_glk_mnt_fixed}" ;;
       "UUID"       ) mount UUID="${_glk_crypt_keydev}" "${_glk_mnt_fixed}" ;;
       "LABEL"      ) mount LABEL="${_glk_crypt_keydev}" "${_glk_mnt_fixed}" ;;
       * ) printf "%b" " (${BRon}failed${Boff}) ..."; right_status 1 ; die "invalid _glk_crypt_keydev" ;;
    esac
    _glk_result=$?
    case $_glk_result in
        0 ) printf "%b" " (${BGon}mounted${Boff})"; right_status $TRUE;;
        * ) right_status 1; die "could not mount _glk_crypt_keydev ($_glk_crypt_keydev_type)";;
    esac
  fi
  # set keyfile pathname
  export keyfile="${_glk_mnt_fixed}/crypt/dat"
  unset -v _glk_mnt_fixed _glk_crypt_keydev _glk_crypt_keydev_type _glk_result
  return 0
}

####----====----====----====----[ second review through this point ]----====----====----====----####
#####################-----[ POSIX checked above this line -]-----#########################

get_luks_edev_name()       # determine an edev name to use with this device
{ # Note: luks_partition_device must be globally defined
  [ -z "${luks_partition_device}" ] && die "luks_partition_device not defined"
  # ( e.g. sda2->eda2 nvme0n1p2->ev012 mmcblk0p2->em02 )
  _glen_bn="${luks_partition_device##*/}" # equivalent to $(basename ${luks_partition_device})
  d_message_n "determining edev name ..." 3
  case ${_glen_bn} in
      "sd"* ) # scsi device (sda2 -> eda2)
        # strip s w/ parameter expansion, and replace w/ e
        _glen_myedev="e${_glen_bn#s}"
        ;;
      "nv"* ) # nvme device (nvme0n1p2 -> ev012)
        # strip 'nvme'w/ parameter expansion, then delete the n and the p w/ printf | tr
        _glen_tmp="${_glen_bn#nvme}"
        _glen_myedev="ev$(printf "%s" "$_glen_tmp" | tr -d 'np')"
        ;;
      "mm"* ) # mmc device (mmcblk0p2 -> em02)
         # strip 'mmcblk'w/ parameter expansion, then delete the p w/ printf | tr
        _glen_tmp="${_glen_bn#mmcblk}"
        _glen_myedev="em$(printf "%s" "$_glen_tmp" | tr -d 'p')"
        ;;
      *    ) # tbd
        d_echo "" 3 ; die "bad luks device name [${_glen_bn}]" 3
        ;;
    esac
    _glen_result=$?
    d_echo_n " (${_glen_myedev})" 3 ; d_right_status $TRUE 3
    export edev=${_glen_myedev}
    unset -v _glen_bn _glen_myedev _glen_tmp _glen_result
    return 0
}

summarize_me()             # list functions in header ("source" to employ)
{
  echo
  separator "script_header_joetoo-$BUILD | content summary" && \
  message "This script header defines some ${BYon}common variables${Boff} for" && \
  message "  use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}" && \
  message "  ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and" && \
  message "  ${BYon}cursor${Boff} movement in my scripts, and it provides a number of" && \
  message "  useful ${BGon}functions${Boff}, for some routine tasks, as described below\n" && \
  grep "()" ${script_header_installed_dir%/}/script_header_joetoo | grep -v "grep" && echo && \
  msg="${BGon}* ${Boff}  ${BYon}About to run:\n        ${BBon}message${Boff}" && \
  msg="${msg}  ${BYon}\""'${BYon}VERBOSE is currently ' && \
  msg="${msg}${BGon}\$(${BBon}status_color \\\"${BRon}\$VERBOSE${BBon}\\\"${BGon})${Boff}" && \
  msg="${msg}${BGon}\$(${BBon}TrueFalse \\\"${BRon}\$VERBOSE${BBon}\\\"" && \
  msg="${msg}${BGon})${BYon}\"${BGon}; ${BBon}echo${Boff}" && echo -e "${msg}" && \
  echo && \
  cmd="${BGon}message${BWon} \"  \${BYon}VERBOSE is currently \$(${BGon}status_color ${BRon}\$VERBOSE)${BWon}\$(${BGon}TrueFalse ${BRon}\$VERBOSE${BWon})\${Boff}\"${Boff}"
  message "About to run ${cmd}"
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  message "  ${BYon}VERBOSE is currently $(status_color $VERBOSE)$(TrueFalse $VERBOSE)${Boff}" && echo && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 1 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}2 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 2 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 2${Boff}  " && \
  vercomp 1 2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0 ${BYon}to${BWon} 1.2.1${Boff}  " && \
  vercomp 1.2.0 1.2.1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0-r1 ${BYon}to${BWon} 1.2.0${Boff}  " && \
  vercomp 1.2.0-r1 1.2.0; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1..1 ${BYon}to${BWon} 1.2${Boff}  " && \
  vercomp 1..1 1.2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.0 ${BYon}to${BWon} 1.0-r10${Boff}  " && \
  vercomp 1.0 1.0-r10; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  " && \
  vercomp 3.4 3.4-r2; echo -e "$(show_result $?)" && echo && \
  message "${BYon}Conditionally execute \$@ IAW verbosity (3) with ${BGon}d_do ${Boff}echo \"line 1.1\" \\; echo \"line 1.2\" 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  d_do echo "line 1.1" \; echo "line 1.2" 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message "${BYon}Conditionally execute \$1 IAW verbosity (3) with ${BGon}debug_do ${Boff}'echo \"line 2.1\" ; echo \"line 2.2\"' 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  debug_do 'echo "line 2.1" ; echo "line 2.2"' 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && echo "" && \
  message "${BYon}Summary of some T/F tests with ${BGon}status_color${Boff}( ) and ${BGon}TrueFalse${Boff}( ) --" && \
  for x in y Y t T up n N f F down 0 1 z "" ; do message "  ${BWon}testing: [${BCon}${x}${BWon}] is $(status_color $x)$(TrueFalse $x)${Boff}" ; done && \
  message "  ${BWon}testing: [${BCon}\$TRUE${BWon}] is $(status_color $TRUE)$(TrueFalse $TRUE)${Boff}" && \
  message "  ${BWon}testing: [${BCon}\$FALSE${BWon}] is $(status_color $FALSE)$(TrueFalse $FALSE)${Boff}" && \
  E_message "Note: bash and most other shells evaluate a variable with null ('') value as ${BRon}FALSE${Boff} and any non-null value as ${BGon}TRUE${Boff}" && \
  echo && \
  msg="${BYon}About to run: ${BBon}sh_countdown ${Boff}3${BGon} && ${BCon}echo ${BGon}&& ${Boff}" && \
  msg="${msg}${BBon}message_n${Boff} \"" && \
  msg="${msg}Finishing with status of summarization ---> \" ${BGon}; ${BBon}right_status ${BRon}\$?${BGon}; ${BBon}echo${Boff}" && \
  message "${msg}" && \
  sh_countdown 3 && echo && \
  message_n "Finishing with status of summarization --->" ; right_status $?; echo

  return 0
}
