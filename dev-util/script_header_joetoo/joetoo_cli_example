#!/bin/ash
# takes no args

script_header_installed_dir="/usr/sbin"
#script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo
# source script_header
header="${script_header_installed_dir%/}/script_header_joetoo"

echo "header: $header"

if [ -f "$header" ]; then . "$header"; else printf '%s' "failed to source header; cannot continue"; exit 1; fi

#-----[ variables ]----------------------------------------------------

# varlist - these are initialized by app_configure_posix() and displayed by show_config()
## note: all of these (including logFile and verbosity) get anulled by initialize_vars;
#  need to explicitly reassign (as app_configure_posix does) or override in a .conf file
varlist="PN BUILD user logFile status_file config_dir verbosity"
varlist="${varlist} bool.INTERACTIVE bool.RESUME num_cmds starting_step stopping_step BREAK"
varlist="${varlist} local_usage local_cmdline_arguments local_cmdline_compound_arguments"

#-----[ functions ]----------------------------------------------------

initialize_command_sequence_posix() # (POSIX) initialize command sequence for joetoo cli framework
{ ret=0
  _ics_FLAGGED=$FALSE
  log_message_n "creating tempfile for command sequnce"
  cmd_seq_file=$(mktemp /tmp/${PN}.XXXXXX)
  log_handle_result $? "$cmd_seq_file" '' || _ics_FLAGGED=$TRUE

  log_message_n "setting trap to remove tempfile on EXIT"
  trap 'rm -f "$cmd_seq_file"' EXIT

  log_message_n "initializing command sequence"
  num_cmds=0   # global variable holding the length of the sequence
# heredoc needs to be on the left edge; no leading whitespace
# initialize/clear the command sequence file
while IFS= read -r _ics_entry; do
      [ -z "$_ics_entry" ] && continue
      # write directly to the file instead of using  ' set -- "$@" '
      printf '%s\n' "$_ics_entry" >> "$cmd_seq_file"
      num_cmds=$(( num_cmds + 1 ))
done <<EOF
printf '%s\n' "this is line 1"${US}print example line number one
printf '%s\n' "this is line 2"${US}print example line number two
printf '\n'${US}print a newline
printf '%s\n' "this is line 3 (after a blank line)"${US}print line number 3
test_function "${BGon}hello${Boff}"${US}run test_function
EOF
  log_handle_result $? "num_cmds: $num_cmds" '' || _ics_FLAGGED=$TRUE

  log_message_n "initailizing starting_step"
  starting_step=1
  log_handle_result $? "$starting_step" '' || _ics_FLAGGED=$TRUE

  log_message_n "initializing stopping step"
  stopping_step="$num_cmds"
  log_handle_result $? "$stopping_step" '' || _ics_FLAGGED=$TRUE

  [ "$_ics_FLAGGED" ] && ret=1
  export num_cmds
  export cmd_seq_file
  unset -v _ics_entry
  return $ret
}
# @usage initialize_command_sequence_posix || die "failed to initialize_command_sequence_posix"
# @vars sets global num_cmds, cmd_seq_file
# @vars initializes global starting_step=1, stopping_step=$num_cmds
# @rule creates a temporary file for command execution and sets an EXIT trap for cleanup
# @rule command sequency entry format 'command_string${US}description_string'
# @cont where: command_string is POSIX executable
# @cont and:   ${US} is teletype ero unit separator char \037 pre-cooked with printf
# @cont and:   description_string is a human-readable description of the command
# @ret 0 on success; 1 on failure

 #-----[ for testing only ]------------------------------------------------
test_function() {
  ret=0; _tf_in="$1"
  printf '%b\n' "this was printed by the test function: $_tf_in" || ret=1
  unset -v _tf_in
  return $ret
}
# @usage test_function <message>
#-----[ main script ]----------------------------------------------------

app_configure_posix || die "failed to app_configure_posix"


log_show_config
log_message "(BEFORE process_cmdline_posix)"

process_cmdline_posix "$@" || die "failed to process_cmdline_posix"

log_show_config
log_message "(AFTER process_cmdline_posix)"

run_sequence_posix "$status_file" '' ''
ret=$?
log_message_n "run_sequence_posix completed with "
log_handle_result $ret '' ''
exit $ret
