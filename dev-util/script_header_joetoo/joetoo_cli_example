#!/bin/ash
# takes no args

#script_header_installed_dir="/usr/sbin"
script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo
# source script_header
header="${script_header_installed_dir%/}/script_header_joetoo"
if [ -f "$header" ]; then . "$header"; else printf '%s' "failed to source header; cannot continue"; exit 1; fi

#-----[ variables ]----------------------------------------------------

# note: all of these (including logFile and verbosity) get them anulled; need to explicitly reassign below
varlist="PN BUILD user logFile status_file config_dir verbosity"
varlist="${varlist} bool.INTERACTIVE bool.RESUME num_cmds starting_step stopping_step"

#-----[ functions ]----------------------------------------------------

configure_posix() {
  separator "$PN" "(configuring)"
  _c_FLAGGED=$FALSE

  # sets all variables named in varlist to null/$FALSE/No
  initialize_vars $varlist
  message "done initialization"

  # tier 0 - prerequisites (note: can't log until logging is set up below
  # initialize package name for this script
  message_n "assigning PN"
  PN="${0##*/}"   # equivalent to PN=$(basename "$0") but w/o subshell
  handle_result $? "$PN" '' || _c_FLAGGED=$TRUE

  # identify and assign user name
  message_n "assigning user"
  user=$(whoami)
  handle_result $? "$user" '' || _c_FLAGGED=$TRUE

  # assign and/or check logFile (may have been set by config
  # (do this after $user is assigned but before starting logging
  d_message "draft logFile name: /var/log/${PN}.log" 2
  message_n "assigninging logFile"
  if [ -z "$logFile" ]; then
    logFile="/var/log/${PN}.log"
    handle_result $? "now assigned: $logFile" "error assigning logFile" || _c_FLAGGED=$TRUE
  else
    printf '%b' " (${BYon}already assigned: ${Gon}$logFile${Boff})"
    right_status 0
  fi
  # if it exists already, rotate it (with sudo, in a subshell)
  if [ -f "$logFile" ]; then
    # shift existing archives (delete the oldest, move others up)
    # use sudo sh -c "..." so we only need to call sudo once if needed for $user
    # (note: with " outside, the ' inside is just a literal single-quote
    #  char - interpreted AFTER expansion)
    message_n "rotating existing logFile(s)"
    sudo sh -c "
      [ -f '${logFile}.2' ] && mv -f '${logFile}.2' '${logFile}.3'
      [ -f '${logFile}.1' ] && mv -f '${logFile}.1' '${logFile}.2'
      mv -f '$logFile' '${logFile}.1'
      touch '$logFile'
      chown '${user}:${user}' '$logFile'
    " >/dev/null 2>&1
    handle_result $? "rotated" "error rotating logFile" || _c_FLAGGED=$TRUE
  else
    # create it and set permissoins
    message_n "creating logFile"
    sudo sh -c "
      touch '$logFile'
      chown '${user}:${user}' '$logFile'
    " >/dev/null 2>&1
    handle_result $? "created" "error rotating logFile" || _c_FLAGGED=$TRUE
  fi

  # tier 1 - global configuration
  # validate package config directory
  log_message_n "assigning config_dir"
  config_dir="/etc/${PN}"
  log_handle_result $? "$config_dir" "error assigning config_dir" || _c_FLAGGED=$TRUE
  validate_dir_posix "$config_dir"

  # BUILD="string" should be located in config_dir
  log_message_n "sourcing BUILD variable assignment"
  . "${config_dir}/BUILD"
  log_handle_result $? "$BUILD" '' || _c_FLAGGED=$TRUE

  # initialize INTERACTIVE - can be overridden by sourced config below (and cmdline)
  log_message_n "assigning default INTERACTIVE"
  INTERACTIVE=$TRUE
  log_handle_result $? "$INTERACTIVE" '' || _c_FLAGGED=$TRUE

  # initialize RESUME - can be overridden by sourced config below (and cmdline)
  log_message_n "assigning default RESUME"
  RESUME=$FALSE
  log_handle_result $? "$RESUME" '' || _c_FLAGGED=$TRUE

  # if the package has a config file at /etc/$PN or in customization_root configure it here
  log_message "looking for config file(s)"
  validate_dir_posix "/etc/${PN}"
  for _c_file in $(find "/etc/${PN}" -name "*.conf" -type f); do
    log_message_n "sourcing $_c_file"
    . "$_c_file"; log_handle_result $? || _c_FLAGGED=$TRUE
  done

  # tier 2 - local configuration
  # assign customization_root
  log_message_n "assigning customization_root variable"
  customization_root="${HOME}/.config/${PN}/"
  log_handle_result $? "$customization_root" "error assigning customization_root" || _c_FLAGGED=$TRUE

  # assign and validate status_file and customization_root
  log_message_n "assigning status_file variable"
  status_file="${customization_root%/}/${PN}.status"
  log_handle_result $? "$status_file" '' || _c_FLAGGED=$TRUE
  validate_file_posix "$status_file"   # note this also validates the directory

  # find (validates) *_example_local.cmdline_arguments; assign first match
  log_message_n "looking for local_cmdline_arguments"
  local_cmdline_arguments=$( \
    find "${customization_root%/}/" \
      -name "[[:alnum:]]*_example_local.cmdline_arguments" | \
    head -n 1 )
  log_handle_result $? "$local_cmdline_arguments" "error finding local_cmdline_arguments" || _c_FLAGGED=$TRUE

  # find (validates) *_example_local.cmdline_compound_arguments; assign first match
  log_message_n "looking for local_cmdline_compound_arguments"
  local_cmdline_compound_arguments=$( \
    find "${customization_root%/}/" \
      -name "[[:alnum:]]*_example_local.cmdline_arguments" | \
    head -n 1 )
  log_handle_result $? "$local_cmdline_compound_arguments" "error finding local_cmdline_compound_arguments" || _c_FLAGGED=$TRUE

  # set default verbosity if not set externally
  log_message_n "maybe assigning verbosity"
  if [ -z "$verbosity" ] ; then
    verbosity=3
    log_handle_result $? "now set: $verbosity" '' || _c_FLAGGED=$TRUE
  else
    log_handle_result $TRUE "already set: $verbosity" ''
  fi

  initialize_command_sequence_posix; _c_result=$?
  log_message_n "command_sequence initialization status"
  log_handle_result $_c_result '' '' || _c_FLAGGED=$TRUE

  [ "$_c_FLAGGED" ] && ret=1
  unset -v _c_FLAGGED _c_file _c_result
  return $ret
}
# @usage configure_posix
# @vars PN, BUILD, user, logFile, status_file, config_dir, verbosity, INTERACTIVE, RESUME
# @vars num_cmds, starting_step, stopping_step, varlist, FALSE, TRUE
# @deps separator, initialize_vars, message, message_n, handle_result, d_message, log_message_n
# @deps log_handle_result, sourcing, check_dir, check_file, process_cmdline_posix, initialize_command_sequence_posix
# @rule initializes and validates the entire script environment before execution
# @ret 0 on success; 1 if _c_FLAGGED is set during configuration
# @rules PN is package name and should be assigned = $(basename "$0") or ${0##*/} to identify the calling script
# @rules POSIX assignment 'BUILD="string"' should reside in "${customization_root%/}/BUILD"
# @rules customization_root may contain XXXX_local.cmdline_arguments extension file
# @rules customization_root may contain XXXX_local.cmdline_compound_arguments extension file


initialize_command_sequence_posix() # (POSIX) initialize command sequence for joetoo cli framework
{ ret=0
  _ics_FLAGGED=$FALSE
  log_message_n "creating tempfile for command sequnce"
  cmd_seq_file=$(mktemp /tmp/${PN}.XXXXXX)
  log_handle_result $? "$cmd_seq_file" '' || _ics_FLAGGED=$TRUE

  log_message_n "setting trap to remove tempfile on EXIT"
  trap 'rm -f "$cmd_seq_file"' EXIT

  log_message_n "initializing command sequence"
  num_cmds=0   # global variable holding the length of the sequence
# heredoc needs to be on the left edge; no leading whitespace
# initialize/clear the command sequence file
while IFS= read -r _ics_entry; do
      [ -z "$_ics_entry" ] && continue
      # write directly to the file instead of using  ' set -- "$@" '
      printf '%s\n' "$_ics_entry" >> "$cmd_seq_file"
      num_cmds=$(( num_cmds + 1 ))
done <<EOF
printf '%s\n' "this is line 1"${US}print example line number one
printf '%s\n' "this is line 2"${US}print example line number two
printf '\n'${US}print a newline
printf '%s\n' "this is line 3 (after a blank line)"${US}print line number 3
test_function "${BGon}hello${Boff}"${US}run test_function
EOF
  log_handle_result $? "num_cmds: $num_cmds" '' || _ics_FLAGGED=$TRUE

  log_message_n "initailizing starting_step"
  starting_step=1
  log_handle_result $? "$starting_step" '' || _ics_FLAGGED=$TRUE

  log_message_n "initializing stopping step"
  stopping_step="$num_cmds"
  log_handle_result $? "$stopping_step" '' || _ics_FLAGGED=$TRUE

  [ "$_ics_FLAGGED" ] && ret=1
  export num_cmds
  export cmd_seq_file
  unset -v _ics_entry
  return $ret
}
# @usage initialize_command_sequence_posix || die "failed to initialize_command_sequence_posix"
# @vars sets global num_cmds, cmd_seq_file
# @vars initializes global starting_step=1, stopping_step=$num_cmds
# @rule creates a temporary file for command execution and sets an EXIT trap for cleanup
# @rule command sequency entry format 'command_string${US}description_string'
# @cont where: command_string is POSIX executable
# @cont and:   ${US} is teletype ero unit separator char \037 pre-cooked with printf
# @cont and:   description_string is a human-readable description of the command
# @ret 0 on success; 1 on failure

usage_posix()                # explain default usage; mod with local "usage module"
{
  N=$(( ${num_cmds} -1 ))
  separator "${PN}-${BUILD}" "(usage)"
  log_E_message "${BRon}Usage: ${BGon}${PN} [-[options]] ${Boff}"
  log_message "${BYon}valid commandline options --${Boff}"
  log_message "  -i | --interactive......: run supervised; confirm execution of each step"
  log_message "  -n | --noninteractive...: run un-supervised; automatically do each step"
  log_message "  -s | --status....: return status (next step, step_number)"
  log_message "  -r | --resume....: resume at next step in status_file"
  log_message "  -v | --verbose...: increase verbosity"
  log_message "  -q | --quiet.....: decrease verbosity"
  log_message "  -[0-${N}]..........: save N to status file and resume at step N"
  log_message "  ${BYon}*${Boff} Single-character options may be combined."
  log_message "    e.g. ${BGon}${PN} --verbose -nqr8${Boff} would resume non-interactively"
  log_message "    (automatic, unsupervised) at step 8 with normal verbosity"
  log_message "${BMon}Caveat:${Boff}"
  log_message "   -i (interactive/supervised) is on by default"
  log_message "   -r (resume) sets starting_step to # in [ $status_file ]"
  log_message "   -[0-${N}] sets starting_step (default 0 otherwise)"
  # source user-script specific usage-module which should be built in the same format
  log_message "${BMon}additional ${customization_root} - commandline options:${Boff}"
  [ -f ${customization_root%/}/local.usage ] && source ${customization_root%/}/local.usage
  printf '\n'
  log_message "${BYon}${PN} workflow sequence (steps):${Boff}"
  for _u_step in $(seq 1 $num_cmds); do
    _u_entry=$(sed -n "${_u_step}p" "$cmd_seq_file") # extract the specific line corresponding to the current step counter
    _u_desc="${_u_entry#*${US}}"                     # human readable description
    printf '    %b[%b%02d%b]%b: ' "${BBon}" "${Mon}" "$_u_step" "${BBon}" "${Boff}"
    printf '%b%s%b\n' "${Con}" "${_u_desc}" "${Boff}"
  done

  unset -v _u_step _u_entry _u_desc
  die "dying; process [$$]"
}
# @usage usage_posix
# @vars PN, BUILD, num_cmds, status_file, customization_root, cmd_seq_file, US
# @deps separator, log_E_message, log_message, die, sed, seq, printf
# @rule displays standard options, sources local.usage if present, and prints workflow
# @ret calls die, resulting in exit 1 (non-zero) from script
# @note uses _u_ prefix for internal loop variables; unsets before termination


validate_dir_posix()  # validate or create a directory $1
{   ret=0
    [ $# -ne 1 ] && { log_E_message "Error: must specify dir_to_validate" ; return 1 ; }
    _vd_dir_to_validate=$1
    log_message_n "validating dir"
    if [ -d "${_vd_dir_to_validate}" ] ; then
        printf '%b%s%b' "${BGon}" " (valid) ... " "${Boff}"
        log_right_status $TRUE
    else
        printf '%b%s%b' "${BYon}" " (creating) ... " "${Boff}"
        # use sudo in case current user is not root
        sudo mkdir -p "${_vd_dir_to_validate}"
        log_handle_result $? "created" "failed to create $_vd_dir_to_validate" || return 1
    fi
    [ -d "${_vd_dir_to_validate}" ] ; ret=$?     # final validation
    unset -v _vd_dir_to_validate
    return $ret
}
# @usage validate_dir_posix <path>
# @args $1 (string) path to the directory to validate or create
# @deps log_E_message, log_message_n, log_right_status, log_handle_result, sudo, mkdir
# @rule ensures a directory exists, creating it with sudo -p if necessary
# @ret 0 if directory exists or was successfully created; 1 otherwise

validate_file_posix()  # validate or create command sequence status file $1
{   ret=0
    [ $# -ne 1 ] && { log_E_message "Error: must specify file_to_validate" ; return 1 ; }
    _vf_file_to_validate=$1
    _vf_dir_to_validate=$(dirname "${_vf_file_to_validate}")
    validate_dir_posix "$_vf_dir_to_validate"
    log_message_n "validating file"
    if [ -f "${_vf_file_to_validate}" ] ; then
        printf '%b%s%b' "${BGon}" " (valid)" "${Boff}"
        log_right_status $TRUE
    else
        # use sudo in case current user is not root
        sudo sh -c "
            printf '%b%s%b' '${BYon}' ' (creating)' '${Boff}'
            printf '%s' '1' > '${_vf_file_to_validate}'  # 1-indexed command sequence
            chown '${user}:${user}' '${_vf_file_to_validate}'
        " >/dev/null 2>&1
        log_handle_result $? "created" "failed to create ${_vf_file_to_validate}" || return 1
    fi
    # final validation
    [ -f "${_vf_file_to_validate}" ] ; ret=$?
    unset -v _vf_file_to_validate _vf_dir_to_validate
    return $ret
}
# @usage validate_file_posix <path>
# @args $1 (string) path to the status file to validate or create
# @vars  user
# @deps log_E_message, validate_dir_posix, log_message_n, log_right_status, log_handle_result, sudo, dirname
# @rule ensures file exists; initializes with '1' and sets ownership to $user if created
# @ret 0 if file exists or was successfully created; 1 otherwise

# local helper (defined only inside this scope) to get status for both --status and -s
_pc_emit_status_posix()
{ ret=0
    if [ -f "$status_file" ]; then
        read _pc_val < "$status_file"
        log_message "${BWon}Status: Step $(( _pc_val - 1 )) complete; next is [ ${BMon}${_pc_val:-1}${BWon} ]${Boff}"
    else
        log_message "${BWon}Status: No status file; sequence not yet started${Boff}"
    fi
    unset -v _pc_val
    return $ret
}
# @usage _pc_emit_status_posix
# @vars status_file (global) path to the command sequence status file
# @vars ret (global) un-prefixed exit status variable initialized to 0
# @deps log_message
# @rule reads the current step from the status file and calculates the previous step
# @ret 0 on completion
# @note uses _pc_ prefix for local variables; explicitly unsets _pc_val before return

process_cmdline_posix() # (POSIX) process command line arguments
{   ret=0
    _pc_arglist="$@"

    _pc_last=""
    d_message "processing command line with [ ${arglist} ]" 2
    d_message "my PID: $$" 5
    # shift each argument into position $1 and examine it
    #   process the argument or process it with its own arguments
    while [ ! -z "$1" ]; do
        d_message "arg1 = [ $1 ]" 3
        # if arg begins with a single dash, process it alone
        case $1 in

            -- )     # end of options (possible future use to care for the rest of $*
                shift; break ;;

            -[!-]* ) # short option try processing alone, but it could be a clustered compound argument
                d_message "processing [ $1 ] alone as single-dash argument" 3
                process_argument_posix "$1" "$2"   # incl $2 in case $1 uses an operand
                _pc_result=$?
                [ "${_pc_result}" -eq 6 ] && shift  # extra shift to clear operand
                shift ;;   # normal shift to next argument

            --* )    # if arg begins with a double dash, process it alone
                d_message "processing [ $1 ] alone as double-dash argument" 3
                process_argument_posix "$1" "$2"  # incl $2 in case $1 uses an operand
                _pc_result=$?
                [ "${_pc_result}" -eq 6 ] && shift  # extra shift to clear operand
                shift ;;   # normal shift to next argument

            * )      # invalid
                d_message "does not start with - or --" 3
                usage_posix; E_message "exiting process [$$]"; ret=1 ;;
        esac
    done
    d_message "done with process_command_line" 2

    unset -v _pc_last _pc_arglist _pc_result
    return $ret
}
# @usage process_cmdline_posix "$@"
# @args $@: positional parameters from the command line
# @vars verbosity, INTERACTIVE, _pc_result
# @deps d_log_message, process_compound_arg_posix, shift
# @rule parses short (-q, -v) and long (--noninteractive) options
# @ret 0 on completion
# @note uses _pc_result to track loop status and prevent arithmetic errors

_get_entry_posix() # (POSIX) get human readable description for command sequence step number
{ ret=0; if ! isint "$1"; then E_message "error: zero args; _get_desc requires $1 step number"; return 1; fi
  _gd_entry=$(sed -n "${1}p" "$cmd_seq_file") # extract the specific line corresponding to the current step counter
  _gd_desc="${_pa_entry#*${US}}"  # human readable description
  _gd_raw_cmd="${_pa_entry%%${US}*}"  # the actual command
  _gd_clean_cmd=$(printf -- '%b' "$_pa_cmd" | strip_ansi | _translate_escapes)
  case $2 in
    1 ) printf '%s' "_gd_desc" ;;
    2 ) printf '%s' "_gd_clean_cmd" ;;
    3 ) printf '%s' "_gd_raw_cmd" ;;
    * ) E_message "invalid format [$2]"; ret=1
  esac
  unset -v _gd_entry _gd_desc _gd_raw_cmd _gd_clean_cmd
  return $ret
}
# @usage _get_entry_posix <step_number> <format_type>
# @args $1 (int) the 1-indexed step number to retrieve from the command sequence
# @args $2 (int) format type: 1=description, 2=cleaned command, 3=raw command
# @vars cmd_seq_file (global) path to the temporary command sequence file
# @vars US (global) Unit Separator character used as the delimiter
# @vars ret (global) initialized to 0 for exit status tracking
# @deps isint, E_message, sed, printf, strip_ansi, _translate_escapes
# @rule extracts specific lines from the command sequence file and parses by $US delimiter
# @ret 0 on success (prints requested string to stdout); 1 on invalid arguments
# @note uses _gd_ prefix for local variables; unsets all before returning
# @note format 2 uses strip_ansi and _translate_escapes for log-safe output

process_argument_posix() # (POSIX) process one argument (considering the next a potential operand)
{ ret=0
  d_message "about to process [ $* ]" 2
  d_message "1: [ $1 ], 2: [ $2 ]" 2
  d_message "my PID: $$" 5
  # process command line argument (must be one of the following)
  [ -z "$1" ] && { E_message "empty arg1 [$1]"; return 1; }
  case "$1" in
    "-"[sS] | "--status"         )
      # display status
      d_message "${BYon}reading status file: [ ${BWon}${status_file}${BYon}  ]${Boff}" 2
      read starting_step < "${status_file}"
      ret=$?
      if [ "$starting_step" -eq 1 ] ; then
          _pa_msg="${BWon}Status: $starting_step ;"
      else
          _pa_msg="${BWon}Status: Step $(($starting_step - 1)) complete ;"
      fi
      _pa_desc=$(_get_entry_posix "starting_step" 1)
      _pa_msg="${_pa_msg} next step would be [ ${BMon}$starting_step${BWon} ]"
      _pa_msg="${_pa_msg} --[ ${BGon}${_pa_desc}${BWon} ]${Boff}"
      message "${_pa_msg}"
      E_message "exiting process [$$]"
      return 0;
      ;;
    "-"[rR] | "--resume"         )
      # resume at stored step unless that is overridden by a new start # (below)
      d_message "${BYon}reading status file: [ ${BWon}${status_file}${BYon}  ]${Boff}" 2
      export RESUME=$TRUE
      read starting_step < "${status_file};"
      ret=$?
      _pa_desc=$(_get_entry_posix "starting_step" 1)
      _pa_msg="${BWon}Resuming at step [ ${BMon}$starting_step${BWon} ]"
      _pa_msg="${_pa_msg} --[ ${BGon}${_pa_desc}${BWon} ]--${Boff}"
      d_message "${_pa_msg}" 2
      ;;
    -*[0-9]*  )
        # currently there are double-digit steps; if the next char is also numeric, append it
        _pa_arg="${1#?}"  # drop the leading "-" (strip shortest match of any single char '?')
        export RESUME=$TRUE
        if isint "$_pa_arg" && [ "$_pa_arg" -ge 0 ] && [ "$_pa_arg" -lt "$num_cmds" ] ; then
            export starting_step="$_pa_arg";
            ret=$?
            _pa_msg="${BYon}Saving next step ${BWon}${starting_step}${BYon}"
            _pa_msg="${_pa_msg} to status file [${Boff}${status_file}${BYon}]${Boff}"
            d_message "${_pa_msg}" 2
            printf '%s' "${starting_step}" > "${status_file}"
            _pa_desc=$(_get_entry_posix "starting_step" 1)
            _pa_msg="${BWon}Resuming at step [ ${BMon}${starting_step}${BWon} ]"
            _pa_msg="${_pa_msg} --[ ${BGon}${_pa_desc}${BWon} ]--${Boff}"
            d_message "${_pa_msg}" 2
        else
            # it may be a combination of numbers and letters - hand off to process_compound_arg_posix
            process_compound_arg_posix "$1"
            ret=$?
        fi
        ;;
    "-"[iI] | "--interactive"    )
      # interactive
      export INTERACTIVE=$TRUE;
      ret=$?
      d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
      ;;
    "-"[nN] | "--noninteractive" )
      # non-interactive
      export INTERACTIVE=$FALSE
      ret=$?
      d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
      ;;
    "-"[qQ] | "--quiet"          )
      # decrease verbosity
      if [ "${verbosity}" -gt 0 ] ; then
          verbosity=$(( $verbosity  - 1 ))
          ret=$?
      elif [ "${verbosity}" -eq 0 ] ; then
          export VERBOSE=$FALSE    # note: VERBOSE is deprecated (here for compatibility)
          ret=$?
          d_message "${BYon}decreased verbosity: ${verbosity}${Boff}" 2
      else
          # error
          ret=1
          dE_message "${BWon}error: negative verbosity: ${verbosity}${Boff}" 2
      fi
      ;;
    "-"[vV] | "--verbose"        )
      # increase verbosity
      export VERBOSE=$TRUE
      if [ $verbosity -lt 6 ] ; then
          verbosity=$(( verbosity + 1 ))
          ret=$?
          d_message "${BYon}increased verbosity: ${verbosity}${Boff}" 2
      fi
      ;;       # note: "numeric" args like -4 should fall through to this default
    *                            )
      # run local arg module if it exists (must end with "* ) process_compound_arg_posix $1 ;;")
      if [ -f "$local_cmdline_arguments" ] ; then
          . "$local_cmdline_arguments"
#      if [ -f /etc/${BPN}/local.cmdline_arguments ] ; then
#          source /etc/${BPN}/local.cmdline_arguments
          # each should set ret as shown above, and if needed USED_OPERAND
      else
          process_compound_arg_posix $1
          ret=$?
      fi
      ;;
  esac
  d_message "done with process_argument_posix" 3

  unset -v _pa_desc _pa_msg _pa_arg
  return $ret
}
# @usage process_argument_posix <arg> [operand]
# @args $1 (string) the flag or argument to process
# @args $2 (string) the potential operand following the flag
# @vars status_file, starting_step, num_cmds, verbosity, INTERACTIVE, RESUME
# @vars local_cmdline_arguments
# @deps d_message, message, E_message, _get_entry_posix, isint, process_compound_arg_posix
# @deps status_color, TrueFalse
# @rule parses flags (-s, -r, -i, -n, -q, -v) and numeric resume points (-[0-9])
# @note unsets _pa_ prefixed local variables before return
# @ret return 0 if success and processed no operand
# @ret return 6 if success and processed an operand $2
# @ret return 1 if error

process_compound_arg_posix()    # process a compount argument
{   ret=0
    d_message "about to process compound [ $* ]" 2
    d_message "my PID: $$" 5
    # must begin with a single dash | "${var%${var#?}}" = 1st char, or "left_most()" but save a function call
    if [ ! "${1%${1#?}}" = "-" ]; then E_message "${E_BAD_ARGS}"; usage_posix; E_message "exiting process [$$]"; return 1; fi
    # must not begin with two dashes (would have been picked in process_argument_posix) | "${var%${var#??}}" = 1st 2 chars
    if [ "${1%${1#??}}" = "--" ]; then E_message "${E_BAD_ARGS}"; usage_posix; E_message "exiting process [$$]"; return 1; fi
    # strip leading dash(es)
    _pca_args="${1##-}"   # strip longest match to - from left
    # handle remaining characters in sequence
    while [ ! -z "${_pca_args}" ]
    do
        #handle one character at at time, from the left
        case "${_pca_args}" in
            [sS]* )
                # display status
                d_message "${BYon}reading status file: [ ${BWon}${status_file}${BYon}  ]${Boff}" 2
                read starting_step < "${status_file};"
                if [ "$starting_step" -eq 0 ] ; then
                    _pca_msg="${BWon}Status: $starting_step ;"
                else
                    _pca_msg="${BWon}Status: Step $(($starting_step - 1)) complete ;"
                fi
                _pca_desc=$(_get_entry_posix "starting_step" 1)
                _pca_msg="${_pca_msg} next step would be [ ${BMon}$starting_step${BWon} ]"
                _pca_msg="${_pca_msg} [ ${BGon}${_pca_desc} ${BWon}]${Boff}"
                d_message "${_pca_msg}" 2
                E_message "exiting process [$$]" && return 0
                ;;
            [rR]* )
                # resume at stored step unless that is overridden by a new start # (below)
                d_message "${BYon}reading status file: [ ${BWon}${status_file}${BYon}  ]${Boff}" 2
                export RESUME=$TRUE
                read starting_step < "${status_file}"
                _pca_desc=$(_get_entry_posix "starting_step" 1)
                _pca_msg="${BWon}Resuming at step [ ${BMon}$starting_step${BWon} ]"
                _pca_msg="${_pca_msg} --[ ${BGon}${_pca_desc}${BWon} ]--${Boff}"
                d_message "${_pca_msg}" 2
                ;;
            [0-9]* )
                # since there may be double-digit steps, then if the next char is also numeric, append it and "shift"
                export RESUME=$TRUE
                starting_step="${_pca_args%${_pca_args#?}}"       # left_most
                if isint "${_pca_args%${_pca_args#??}}"; then     # left_most two
                    export starting_step="${_pca_args%${_pca_args#??}}"
                    _pca_args="${_pca_args#?}"   # strip 1st char
                fi
                if [ "$starting_step" -gt "$num_cmds" ] ; then
                    E_message "invalid starting_step [${starting_step}]"
                    usage_posix
                else
                    _pca_msg="${BYon}Saving next step ${BWon}${starting_step}${BYon}"
                    _pca_msg="${_pca_msg} to status file [${Boff}${status_file}${BYon}]${Boff}"
                    d_message "${_pca_msg}" 2
                    echo "$starting_step" > "$status_file"
                    _pca_msg="${BWon}Resuming at step [ ${BMon}${starting_step}${BWon} ]"
                    _pca_msg="${_pca_msg} --[ ${BGon}${msg1_sequence[${starting_step}]}${BWon} ]--${Boff}"
                    d_message "${_pca_msg}" 2
                fi
                ;;
            [iI]* )
                # interactive
                export INTERACTIVE=$TRUE
                d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
                ;;
            [nN]* )
                # non-interactive
                export INTERACTIVE=$FALSE
                d_message "${BYon}setting INTERACTIVE: $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}" 2
                ;;
            [qQ]* )
                # decrease verbosity
                [ "${verbosity}" -gt 0 ] && verbosity=$(( verbosity - 1 ))
                [ "${verbosity}" -eq 0 ] && export VERBOSE=$FALSE
                d_message "${BYon}decreased verbosity: ${verbosity}${Boff}" 2
                ;;
            [vV]* )
                # increase verbosity
                [ "${verbosity}" -lt 6 ] && verbosity=$(( verbosity + 1 ))
                export VERBOSE=$TRUE
                d_message "${BYon}increased verbosity: ${verbosity}${Boff}" 2
                ;;       # note: "numeric" args like -4 should fall through to this default
            *   )
                # run local arg module if it exists (must end with "* ) E_message "${E_BAD_ARGS}" && usage_posix ;;")
                if [ -f "$local_process_cmdline_compound_arguments" ] ; then
                    . "$local_process_cmdline_compound_arguments"
#                if [ -f /etc/${BPN}/local.cmdline_compound_arguments ] ;then
#                    source /etc/${BPN}/local.cmdline_compound_arguments
                else
                    E_message "${E_BAD_ARGS}"
                    usage_posix
                fi
                ;;
        esac
        #strip first char from _pca_args (i.e. "shift" one character)
        _pca_args="${_pca_args#?}"   # strip 1st char
    done
    d_message "done with process_compount_arg" 3

    unset -v _pca_msg _pca_args
    return $ret
}
# @usage process_compound_arg_posix "string"
# @args $1: the compound argument string (e.g., "qv")
# @vars verbosity, _pa_len, _pa_i, _pa_char
# @deps d_message, message
# @rule iterates through each character of a compound argument to apply settings
# @ret 0 on success

run_sequence_posix() # (POSIX) run command sequence; $1=status_file, $2=start, $3=stop
{ ret=0
  # guard 1 - minimum arguments check (status, start, stop, + at least 1 cmd)
  [ $# -lt 3 ] && { log_E_message "usage_posix: run_sequence_posix <status_file> <start> <stop>"; return 1; }
  _rs_status_file="$1"           # assign the status file
  _rs_start="${2:-1}"            # guard 2 - start step (default to zero but ensure it is an integer in range)
  ! isint "$_rs_start" && { log_E_message "run_sequence_posix: start_step '$2' must be an integer 1 - ${num_cmds}"; return 1; }
  if [ "$_rs_start" -lt 1 ] || [ "$_rs_start" -gt "$num_cmds" ]; then
     log_E_message "run_sequence_posix: start_step '$2' must be an integer 1 - ${num_cmds}"; return 1; fi
  _rs_stop="${3:-$num_cmds}" # guard 3 - stop step (default to num cmds but ensure it is an integer in range)
  ! isint "$_rs_stop" && { log_E_message "run_sequence_posix: stop_step '$3' must be '' or an integer 1 - ${num_cmds}"; return 1; }
  if [ "$_rs_stop" -lt 1 ] || [ "$_rs_stop" -gt "$num_cmds" ]; then
    log_E_message "run_sequence_posix: stop_step '$3' must be '' or an integer 1 - ${num_cmds}"; return 1; fi
  _rs_step=1
  while [ "$_rs_step" -le "$_rs_stop" ]; do        # enforces upper bound
    if [ "$_rs_step" -lt "$_rs_start" ]; then
      _rs_step=$(( _rs_step + 1 )); continue; fi   # enforces lower bound (shift into range)
    # assign commadn and description from input, delimitted by unit separator ($US)
    _rs_entry=$(sed -n "${_rs_step}p" "$cmd_seq_file") # extract the specific line corresponding to the current step counter
    _rs_cmd="${_rs_entry%%${US}*}"  # the actual command
    _rs_desc="${_rs_entry#*${US}}"  # human readable description
    _rs_clean_entry=$(printf -- '%b' "$_rs_entry" | strip_ansi | _translate_escapes)
    _rs_clean_cmd=$(printf -- '%b' "$_rs_cmd" | strip_ansi | _translate_escapes)

    d_log_message "_rs_start: $_rs_start" 5
    d_log_message "_rs_stop: $_rs_stop" 5
    d_log_message "_rs_step: $_rs_step" 5
    d_log_message "_rs_clean_entry: $_rs_clean_entry" 5
    d_log_message "_rs_clean_cmd: $_rs_clean_cmd" 5
    d_log_message "_rs_desc: $_rs_desc" 5
    d_log_message "termwidth: $(termwidth)" 5

    # if INTERACTIVE, confirm before executing the step
    if [ "$INTERACTIVE" ]; then
      _rs_msg="${BYon}Are you ready to (${_data_color}${_rs_step}${BYon})"
      _rs_msg="${_rs_msg} ${_op_color}${_rs_desc}${BYon}? ${Boff}"
      yns_prompt "$_rs_msg"
      _rs_response="$response"
    else
      _rs_response="yes"
    fi  # INTERACTIVE?
    # execute according to response
    case "$_rs_response" in
      [Yy]* )
        # start with a separator for every step
        d_log_separator "$PN" "(step [$_rs_step]: $_rs_desc)" 1
        d_log_message "${LBon}Executing: ${BYon}${_rs_clean_cmd}${Boff}" 1
        d_log_message "executing step [$_rs_step]: $_rs_clean_cmd" 2
        # eval expands variables inside the string
        eval "$_rs_cmd"; _rs_result=$?
        ### don't die - let the calling script decide what to do based on return
        ### d_log_handle_result $_rs_result 1 || die "failed to execute step [$_rs_step]: $_rs_clean_cmd"
        # display/log result and set bit in ret status binary bitmask
        d_log_handle_result $_rs_result '' "failed with exit code [$_rs_result]" 1 || \
            ret=$(( ret | 1 << _rs_step )) ;;
      [Ss]* )
        _rs_msg="${BYon}Skipping step [${_data_color}${_rs_step}${BYon}]:"
        _rs_msg="${_rs_msg} ${_op_color}${_rs_desc}${BYon} as instructed${Boff}"
        d_log_message "$_rs_msg" 1 ;;
      * )
        d_log_message "${BRon}Aborting sequence, as instructed${Boff}" 1
        ret=1; break ;;
    esac
    _rs_step=$(( _rs_step + 1 ))
  done
  unset -v _rs_status_file _rs_step _rs_cmd _rs_result _rs_entry _rs_desc
  unset -v _rs_response _rs_clean_cmd _rs_start _rs_stop _rs_msg
  return $ret
}
# @usage: run_sequence_posix <status_file> <start> <stop>
# @args: $1 (string) path to sequence status file
# @args: $2 (int) starting step (1-indexed)
# @rule: $2 start must be '' or integer 1(default) - num_cmds
# @args: $3 (int) stopping step (1-indexed)
# @rule: $3 stop must be '' or integer 1 - num_cmds(default)
# @vars: INTERACTIVE, logFile, PN, US, _data_color, _op_color
# @ret: 0 on success, 1 on abort, or bitmask of failed steps
# @deps: isint, yns_prompt, d_log_separator, d_log_message, d_log_handle_result, strip_ansi, _translate_escapes

linear_search_posix() {
    ret=0
    _ls_needle=$1
    # find line number where command (before US) matches needle
    _ls_idx=$(grep -n "^${_ls_needle}${US}" "$cmd_seq_file" | cut -d: -f1)
    printf '%s' "$_ls_idx"
    [ -z "$_ls_idx" ] && ret=1
    unset -v _ls_needle _ls_idx
    return $ret
}
# @usage linear_search_posix <target_string> <file_path>
# @args $1 (string) the command or key to search for
# @args $2 (string) the path to the command sequence file (e.g., $cmd_seq_file)
# @vars US (global) the Unit Separator used as a delimiter in the sequence file
# @vars ret (global) exit status variable; initialized to 0, not localized
# @deps grep, cut, printf
# @rule searches a file for a record starting with the target string followed by $US
# @ret 0 and prints the line number (1-indexed) if found; 1 if not found
# @note replaces the BASH array-based search from the extended header
# @note uses _ls_ prefix for local variables and unsets before return

 #-----[ for testing only ]------------------------------------------------
test_function() {
  ret=0; _tf_in="$1"
  printf '%b\n' "this was printed by the test function: $_tf_in" || ret=1
  unset -v _tf_in
  return $ret
}
# @usage test_function <message>
#-----[ main script ]----------------------------------------------------

configure_posix || die "failed to configure_posix"


log_show_config
log_message "(BEFORE process_cmdline_posix)"

process_cmdline_posix "$@" || die "failed to process_cmdline_posix"

log_show_config
log_message "(AFTER process_cmdline_posix)"

run_sequence_posix "$status_file" '' ''
ret=$?
log_message_n "run_sequence_posix completed with "
log_handle_result $ret '' ''
exit $ret
