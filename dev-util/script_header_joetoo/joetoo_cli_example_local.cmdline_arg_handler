#!/bin/sh
# user-script specific commandline argument module (to extend script_header_joetoo's process_cmdline capability)
#
# ** will be sourced by using script to make two functions available
# set result=0 for success with no operand
# set result=6 for success with operand
# set result = 1  for error

handle_local_arg() {
    # Expects $1=current arg, $2=potential operand
    _hla_arg="$1"
    _hla_operand="$2"
    _hla_ret=1 # Default error/unhandled

    case "$_hla_arg" in
        "-"[eE] | "--example" )
            export EXAMPLE="${TRUE}"
            _hla_ret=$?
            d_log_message "${BYon}set EXAMPLE = $(status_color ${EXAMPLE})$(TrueFalse ${EXAMPLE}) ${Boff}" 2
            ;;
        "-"[dD] | "--defaults" )
            export DEFAULTS="${TRUE}"
            _hla_ret=$?
            d_log_message "${BYon}set DEFAULTS = $(status_color ${DEFAULTS})$(TrueFalse ${DEFAULTS}) ${Boff}" 2
            ;;
        "-"[oO] | "--output" )
            # myOperand is a global variable, assigned here
            # ($2 is "consumed" in the parent loop via the ret=6 flag causing parent to "shift" twice)
            myOperand="$2"
            log_message "assigned myOperand: $_hla_operand"
            _hla_ret=6   # Signal to parent script to "shift 2"
            d_log_message "${BYon}set DEFAULTS = $(status_color ${DEFAULTS})$(TrueFalse ${DEFAULTS}) ${Boff}" 2
            ;;
        * )
            # note: "numeric" args like -4 should fall through to the default handler in the parent script
            # Do nothing here, fall back to the main script's logic
            _hla_ret=1 # Error or unhandled
            ;;
    esac
    unset -v _hla_arg _hla_operand
    return $_hla_ret
}


handle_local_compound_arg() {
    # This function expects the parent script to have already stripped the leading '-'
    # We examine the *first character* of the remaining _pca_args string

    _hlca_char="${_pca_args%${_pca_args#?}}" # Get the first character of _pca_args
    _hlca_ret=1 # Default error/unhandled

    case "$_hlca_char" in
        [eE] )
            export EXAMPLE="${TRUE}"
            d_log_message "${BYon}set EXAMPLE = $(status_color ${EXAMPLE})$(TrueFalse ${EXAMPLE}) ${Boff}" 2
            _hlca_ret=0
            ;;
        [dD] )
            export DEFAULTS="${TRUE}"
            d_log_message "${BYon}set DEFAULTS = $(status_color ${DEFAULTS})$(TrueFalse ${DEFAULTS}) ${Boff}" 2
            _hlca_ret=0
            ;;
         *   )
            # Note: Unrecognized args should fall through to the default in the parent script
            # This is not an error here, it just means the parent loop should handle it.
            _hlca_ret=1
            ;;
    esac
    unset -v _hlca_char
    return $_hlca_ret
}


handle_local_usage() {
  # user-script specific usage-module which should be built in the same format
  # this file must contain legitimate bash assignments and commands
  # it will be sourced by the script_header_joetoo_extended usage() function
  # Note: options i, n, s, r, v, q are already used by the default cmdline processor
  log_message "  -e | --example ............: example local option"
  log_message "  -d | --defaults ...........: example local option"
  log_message "  -o | --output <OPERAND>....: specify output text"
  echo
  log_message "${BMon}Note:${Boff}"
  log_message "${BYon}(1) --o output cannot be used as a single-letter options${Boff}"
  log_message " (example -ivo <operand> will fail b/c of ${BRon}-ivo${Boff}"
  log_message "${BWon}the word following -o|--output will be treated as its operand${Boff}"
  log_message "${BRon} minimal usage: ${BGon} ${PN} ${BMon}-o ${LBon}<OPERAND>${Boff}"


}
