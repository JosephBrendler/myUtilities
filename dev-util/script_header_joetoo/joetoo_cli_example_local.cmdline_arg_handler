#!/bin/sh
# this is a template for a local user-script specific commandline argument module
# (to extend script_header_joetoo's process_cmdline capability)
#
# ** will be sourced by using script to make these three functions available
# Convention for cmdline arg handling:
#   set result=0 for success with no operand
#   set result=6 for success with operand
#   set result=7 for file not found (to differentiate from error)
#   set result = 1  for error

handle_local_arg() # (POSIX) local compound arg handler to extend cli in script_header_joetoo
{ hla_ret=0; _hla_arg="$1"; _hla_operand="$2"
  j_msg -7 "in handle_local_arg with _hla_arg: [$_hla_arg], _hla_operand: [$_hla_operand]"
  case "$_hla_arg" in
    "-"[eE] | "--example" )
      export EXAMPLE="${TRUE}"; hla_ret=$?
      j_msg -6 "${BYon}set EXAMPLE = $(status_color ${EXAMPLE})$(TrueFalse ${EXAMPLE}) ${Boff}"
      ;;
    "-"[dD] | "--defaults" )
      export DEFAULTS="${TRUE}"; hla_ret=$?
      j_msg -6 "${BYon}set DEFAULTS = $(status_color ${DEFAULTS})$(TrueFalse ${DEFAULTS}) ${Boff}"
      ;;
    "-"[oO] | "--output" )
      # myOperand is a global variable, assigned here
      # ($2 is "consumed" in the parent loop via the ret=6 flag causing parent to "shift" twice)
      myOperand="$2"; _hla_result=$?
      case "$_hla_result" in
        0 ) hla_ret=6 ;;  # success; signal to parent script to "shift 2"
        * ) j_msg -3 "error assigning myOperand; exit status: [$_hla_result]"; hla_ret=1 ;;
      esac
      j_msg -5 "assigned myOperand: $_hla_operand"
      ;;
    * )
      # NOTICE: getting here does not mean error - it just means no single flag option matched,
      # but $1 could still be a compound argument (cluster of single-letter flags), so we have
      # to differentiate that (not found) status from "error", and fall back to the main script's logic
      hla_ret=7 # not found
      ;;
  esac
  j_msg -7 "handle_local_arg complete, returning [$hla_ret]"
  unset -v _hla_arg _hla_operand _hla_result
  return $hla_ret
}
# @usage handle_local_arg (called from script_header_joetoo)
# @args $1=current arg, $2=potential operand
# @ret 0: successful action option for flag identified, 1: error
# @ret 6: consumed an operand, 7: file not found
# @note operates at INFO severity level
# @note examines string for match to known flags (e.g. -r|--resume)

handle_local_compound_arg() # (POSIX) local compound arg handler to extend cli in script_header_joetoo
{ hlca_ret=0; _hlca_char="$1" # Get the first character of the parent's _pca_args directly as $1 now
#{ hlca_ret=0; _hlca_char="${_pca_args%${_pca_args#?}}" # Get the first character of _pca_args
  j_msg -7 "in handle_local_compound_arg with _pca_args: [$_pca_args], _hlca_char: [$_hlca_char]"
  case "$_hlca_char" in
    [eE] )
      export EXAMPLE="${TRUE}"; hlca_ret=$?
      j_msg -6 "${BYon}set EXAMPLE = $(status_color ${EXAMPLE})$(TrueFalse ${EXAMPLE}) ${Boff}"
      ;;
    [dD] )
      export DEFAULTS="${TRUE}"; hlca_ret=$?
      j_msg -6 "${BYon}set DEFAULTS = $(status_color ${DEFAULTS})$(TrueFalse ${DEFAULTS}) ${Boff}"
      ;;
    *    )
      # NOTICE: getting here does not mean error - it just means no single flag option matched,
      # but $1 could still be a compound argument (cluster of single-letter flags), so we have
      # to differentiate that (not found) status from "error", and fall back to the main script's logic
      hlca_ret=7 # not found
      ;;
  esac
  j_msg -7 "handle_local_compound_arg complete, returning [$hlca_ret]"
  unset -v _hlca_char
  return $hlca_ret
}
# @usage handle_local_compound_arg (called from script_header_joetoo)
# @ret 0: successful action option for flag identified, 1: error, 7: file not found
# @rule this function expects the parent script to have already stripped the leading '-'
# @note operates at INFO severity level
# @note examines the *first character* of the remaining _pca_args string

handle_local_usage() # (POSIX) local usage module to extend cli in script_header_joetoo
{ j_msg -5 "  -e | --example ............: example local option"
  j_msg -5 "  -d | --defaults ...........: example local option"
  j_msg -5 "  -o | --output <OPERAND>....: specify output text"
  j_msg -5 ""  # severity-sensitive newline
  j_msg -5 "${BMon}Note:${Boff}"
  j_msg -5 "${BYon}(1) --o output cannot be used as a single-letter options${Boff}"
  j_msg -5 " (example -ivo <operand> will fail b/c of ${BRon}-ivo${Boff}"
  j_msg -5 "${BWon}the word following -o|--output will be treated as its operand${Boff}"
  j_msg -5 "${BRon} minimal usage: ${BGon} ${PN} ${BMon}-o ${LBon}<OPERAND>${Boff}"
}
# @usage handle_local_usage  (called from usage() in script_header_joetoo)
# @rule user-script specific usage-module which should be built in joetoo format
# @rule this file must contain legitimate bash assignments and commands
# @note operates at NOTICE severity level
# @note options h, i, n, s, r, v, q V, Q are already used by the joetoo cmdline processor
