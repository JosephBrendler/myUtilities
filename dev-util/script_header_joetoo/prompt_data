with this///    # FUNCTIONs
    # with the list, calculate the length of the longest function name
    #   add 2 for "()" to get true max displayed length
    _sh_fn_max_len=$(( $(get_longest $_sh_fn_list) + 2 ))
    d_message "_sh_fn_max_len: $_sh_fn_max_len" 4
    # determine the offset to the function description column - this is where the cursor
    #   will be when echo_n_long is called to smart-wrap the description
    #   Math: _sh_fn_max_len + 2c.Lpad + 2c.dots(min) + 2c.Rpad
    _sh_fn_col=$((_sh_fn_max_len + 6))
    d_message "_sh_fn_col: $_sh_fn_col" 4
    # assign the number of the column to which to indent any subseqent lines of the description
    _sh_fn_indent="${_sh_fn_col}"   # for now, wrap/indent to align directly under start point
    # assign the internal separator to appear between function name and padding
    _sh_fn_sep=" "
    # calculate length of the column (between the gutters) to be passed to pad()-->echo_n_long()
    _sh_fn_col_width=$(( _sh_fn_max_len + ${#_sh_fn_sep} - 1 ))

    # METADATA
    # calculate the length of the longest metadata lable to determine the prinf column width
    #   for metadata (these are known a priori, but change)   
    _sh_tag_list="usage arguments variables dependencies requirements"
    _sh_tag_list="${_sh_tag_list} rules notes warning unknown"
    _sh_tag_max_len=$(get_longest $_sh_tag_list)
    d_message "_sh_tag_list: $_sh_tag_list" 4
    d_message "_sh_tag_max_len: $_sh_tag_max_len" 4
    # determine the offset to the metadata payload column - this is where the cursor
    #   will be when echo_n_long is called to smart-wrap the metadata payload
    #   Math: _sh_tag_max_len + 4c.Lpad + 2c.dots(min) + 2c.Rpad
    _sh_tag_col=$((_sh_tag_max_len + 8))
    d_message "_sh_tag_col: $_sh_tag_col" 4
    # assign the number of the column to which to indent any subsequent lines of metadata payload
    _sh_tag_indent="${_sh_tag_col}"   # for now, wrap/indent to align directly under start point
    # assign the internal separator to appear between metadata label and padding
    _sh_tag_sep=": "
    # calculate the length of the column (between the gutters) to be passed to pad()
    _sh_tag_col_width=$(( _sh_tag_max_len + ${#_sh_tag_sep} - 2 ))
///i get this/// summarize_header
 * looking for headers in /home/joe/myUtilities/dev-util
/script_header_joetoo/testing/script_header_joetoo*

---[ bash-0.0.0 (19620207) (content summary) ]----------
 * This script header defines common variables, ANSI
   sequences, and the following functions/utilities as
   described below:

---[ bash-0.0.0 (19620207) (script_header_joetoo_testdum
my) ]
  toc() ................  table of contents (this fn
                          just calls
                          summarize_header
    notes: .......  this is a test line intended to wrap
                    describes the usage syntax, options,
                    and arguments for a
                    function
    notes: .......  lines below starting '#' followed by
                    '
    usage: .......  <empty>
    arguments: ...  <empty>
    variables: ...  <empty>
    dependencies:   <empty>
    requirements:   <empty>
    rules: .......  <empty>
    notes: .......  <empty>
    warning: .....  <empty>
  SCP() ................  (ANSI) save the current cursor
                          position
  RCP() ................  (ANSI) restore the cursor to
                          the saved position
  HCU() ................  (ANSI) Hide the cursor (Note:
                          the trailing character is
                          lowercase L)
  isnumber() ...........  (POSIX) deprecated - use
                          isint(); tests if $1 is an
                          integer
  W_message() ..........  (POSIX) display text warning
                          message $@
  E_message() ..........  (POSIX) display text error
                          message $@
  E_message_n() ........  (POSIX) display text error
                          message $@ (no CR)
  _d_build_and_print() .  Internal helper: Not for
                          direct use.

 * To run functional tests, use: demonstrate_me
---[ gmki91 (complete) ]--------------------------------
joe@gmki91 ~/myUtilities/dev-util/script_header_joetoo $
 VERBOSE=$TRUE verbosity=5 summarize_header
 * looking for headers in /home/joe/myUtilities/dev-util
/script_header_joetoo/testing/script_header_joetoo*

---[ bash-0.0.0 (19620207) (content summary) ]----------
 * This script header defines common variables, ANSI
   sequences, and the following functions/utilities as
   described below:

---[ bash-0.0.0 (19620207) (script_header_joetoo_testdum
my) ]
 * _sh_fn_max_len: 20
 * _sh_fn_col: 26
 * _sh_tag_list: usage arguments variables dependencies 
requirements rules notes warning unknown
 * _sh_tag_max_len: 12
 * _sh_tag_col: 20
 * _sh_line: toc() # table of contents (this fn just cal
ls summarize_header
 * _sh_fn_name: [toc()]
  toc()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 5
................  table of contents (this fn
                          just calls
                          summarize_header
 * _sh_line: # @note this is a test line intended to wra
p describes the usage syntax, options, and arguments for
 a function
    notes: .......  this is a test line intended to wrap
                    describes the usage syntax, options,
                    and arguments for a
                    function
 * _sh_line: # @note lines below starting '#' followed b
y ' @xxx' are interpreted by summarize_header as metadat
a
    notes: .......  lines below starting '#' followed by
                    '
 * _sh_line: # @usage @usage describes the usage syntax,
 options, and arguments for a function
    usage: .......  <empty>
 * _sh_line: # @args @args defines positional parameters
 ($1, $2, etc) and their roles
    arguments: ...  <empty>
 * _sh_line: # @vars @vars identifies global variables r
equired or modified by the function
    variables: ...  <empty>
 * _sh_line: # @deps @deps lists function, script, or pa
ckage dependencies
    dependencies:   <empty>
 * _sh_line: # @req @req specifies prerequisites or stat
e requirements (e.g., must be root)
    requirements:   <empty>
 * _sh_line: # @rule @rule outlines logic constraints or
 mandatory behaviors
    rules: .......  <empty>
 * _sh_line: # @note @note provides administrative or ge
neral notes for the user or maintainer
    notes: .......  <empty>
 * _sh_line: # @warn @warn provides administrative warni
ng for user or maintainer
    warning: .....  <empty>
 * _sh_line: SCP()    # (ANSI) save the current cursor p
osition
 * _sh_fn_name: [SCP()]
  SCP()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 5
................  (ANSI) save the current cursor
                          position
 * _sh_line: RCP()    # (ANSI) restore the cursor to the
 saved position
 * _sh_fn_name: [RCP()]
  RCP()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 5
................  (ANSI) restore the cursor to
                          the saved position
 * _sh_line: HCU()    # (ANSI) Hide the cursor (Note: th
e trailing character is lowercase L)
 * _sh_fn_name: [HCU()]
  HCU()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 5
................  (ANSI) Hide the cursor (Note:
                          the trailing character is
                          lowercase L)
 * _sh_line: isnumber()          # (POSIX) deprecated - 
use isint(); tests if $1 is an integer
 * _sh_fn_name: [isnumber()]
  isnumber()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 10
...........  (POSIX) deprecated - use
                          isint(); tests if $1 is an
                          integer
 * _sh_line: W_message()   # (POSIX) display text warnin
g message $@
 * _sh_fn_name: [W_message()]
  W_message()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 11
..........  (POSIX) display text warning
                          message $@
 * _sh_line: E_message()   # (POSIX) display text error 
message $@
 * _sh_fn_name: [E_message()]
  E_message()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 11
..........  (POSIX) display text error
                          message $@
 * _sh_line: E_message_n()       # (POSIX) display text 
error message $@ (no CR)
 * _sh_fn_name: [E_message_n()]
  E_message_n()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 13
........  (POSIX) display text error
                          message $@ (no CR)
 * _sh_line: _d_build_and_print() # Internal helper: Not
 for direct use.
 * _sh_fn_name: [_d_build_and_print()]
  _d_build_and_print()  * _sh_fn_max_len: 20
 * #_sh_fn_name: 20
.  Internal helper: Not for
                          direct use.

 * To run functional tests, use: demonstrate_me
---[ gmki91 (complete) ]--------------------------------
joe@gmki91 ~/myUtilities/dev-util/script_header_joetoo $
 x="  RCP() ................  "; echo ${#x}
26
joe@gmki91 ~/myUtilities/dev-util/script_header_joetoo $
 y="    notes: .......  "; echo ${#y}
20
/// can you explain why I basically have to undo what I thought was necessary to accurately keep track of where the cursor is so I can tell echo_n_long  ?
