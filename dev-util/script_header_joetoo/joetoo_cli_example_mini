#!/bin/ash
# joetoo_cli_example - template app for joetoo CLI (c) Joe Brendler 2026-7789

script_header_installed_dir="/usr/sbin"
#script_header_installed_dir=/home/joe/myUtilities/dev-util/script_header_joetoo
# source script_header
header="${script_header_installed_dir%/}/script_header_joetoo"

echo "header: $header"

if [ -f "$header" ]; then . "$header"; else printf '%s' "failed to source header; cannot continue"; exit 1; fi
printf '%s' "Checking for header commands to confirm sourcing"
if command -v toc >/dev/null 2>&1 && command -v run_sequence >/dev/null 2>&1 ; then
handle_result $? ; else printf '%s\n' "Failed; header not sourced; cannot continue"; exit 1; fi

#-----[ variables ]----------------------------------------------------

# NOTE: varlist variables are initialized by app_configure() and displayed by show_config();
# the basic set of varlist variables is defined in script_header_joetoo and can be extended
# either in the using script or in its .conf files.
# An example is provided in the joetoo_cli_example script and in the template joetoo_cli_example.conf
#
# BREAK tells display_vars to add a newline spacer in its output
# $LOCALIZED exemplifies use of the joetoo pseudo-boolean data type for POSIX scripts
# $EXAMPLE and $DEFAULTS are pseudo-booleans defined in joetoo_cli_example_local.cmdline_arg_handler
# $INITIALIZED_ME and $SOURCED_ME exemplify use of the joetoo yn data type
# Note how each is named and how these types are prefixed in the varlist, to inform initialize_vars
# and display_vars how to handle them.
# $longone is a long string defined in script_header_joetoo to test and illustrate smart wrapping
# by the smart_wrap_n() function. its name is prefixed "lv." in this localized extension of varlist
# to indicate (long variable), so display_vars will use smart_wrap_n() to display the content of
# $longone (which is long-one btw, not long-gone)
#
# CAVEAT: varlist is instantiated when script_header_joetoo is sourced (above), so it IS safe to add
# variable names to it in a "variables" section at the top of your main script, but note that
# the standard joetoo cli script layout calls app_configure() after that --
# so anything you add to varlist before app_configure will be over-written when app_configure
# calls initialize_var. which sets all bool. to $FALSE, all yn. to "no" and all others to ""
#
# Bottom line: you can append variable names to varlist at the top of your script, but if you do, you
# ALSO need to reassign them AFTER app_configure runs. Thus it is "easier" to just append
# variable names to varlist in the .conf file, which app_configure() loads AFTER it calls
# initialize_vars, but be sure to also assign them, b/c they will not be initialized otherwise
LOCALIZED=$FALSE; INITIALIZED_ME="no"
varlist="${varlist} BREAK bool.LOCALIZED yn.INITIALIZED_ME"

#-----[ functions ]----------------------------------------------------

# note: this "mini" version (joetoo_cli_example_mini) is a template for scripts
#  wherein the tasks do not require seqencing and interactive oversight.
#  Thus, they can be coded directly into the scripts main body, or its
#  internal functions, or both, as illustrated in this template
# As such this "mini" version does not have or need an
#   initialize_command_sequence() function

 #-----[ for testing only ]------------------------------------------------
test_function() {
  test_ret=0; _tf_in="$1"
  printf '%b\n' "this was printed by the test function: $_tf_in" || test_ret=1
  unset -v _tf_in
  return $test_ret
}
# @usage test_function <message>
#-----[ main script ]----------------------------------------------------

app_configure || die "failed to app_configure"

# re-assign varlist variables appended at the top of the script and thus
# over-written by app_configure
j_msg -6n "(re)assigning LOCALIZED"
LOCALIZED=$TRUE
handle_result $? "$(TrueFalse $LOCALIZED)" "failed to reassign LOCALIZED" "$info"
j_msg -6n "(re)assigning INITIALIZED_ME"
INITIALIZED_ME="yes"
handle_result $? "$INITIALIZED_ME" "failed to reassign INITIALIZED_ME" "$notice" "$info"


d_do show_config "$info"  # show config prior to processing cmdline only at info/debug verbosity
j_msg -6 "(BEFORE process_cmdline)"

# note that without a defined command sequence and  the use of run_sequence
# the INTERACTIVE, RESUME envinronment variables and their corresponding
# command line flags (-r|--resume, -i|--interactive, -[0-9]* are all meaningless
process_cmdline "$@" || die "failed to process_cmdline"

show_config
j_msg -6 "(AFTER process_cmdline)"

# instead of calling run_sequence for interactive oversight of complex
# processes, simple tasks can be coded directly, right here
printf '%s\n' "this is line 1"
notice_msg "this is line 2, which will be logged if LOGGING=\$TRUE and verbosity -gt \$notice ($notice)"
printf '\n'
printf '%s\n' "this is line 3 (after a blank line)"
# or in functions above, called like this
test_function "${BGon}hello${Boff}"

result=$?
separator "$PN-$BUILD" "(Done)"
notice_msg_n "$PN complete. Results:"
handle_result $result "exemplary success" "exemplary failure" "$notice"
exit $result
