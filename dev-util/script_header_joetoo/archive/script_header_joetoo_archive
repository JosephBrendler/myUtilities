#!/bin/sh
####!/bin/bash   ### switched so it's also valid in busybox (ash) shell
#   script header with basic functions
# Author: joe brendler 19 Jul 2014
#         24 June 2025 - v1.0.0 moved to /usr/sbin/ and consolidated as script_header_joetoo
#
toc() # table of contents (this fn just calls summarize_header
{ # call summarize_header
summarize_header; printf "\n"
message "That's all I have to say about that"
}

#-----[ metadata tagging key ]------------------------------------------------
# @note lines below starting '# @xxx' are interpreted by summarize_header as metadata
# @usage @usage describes the usage syntax, options, and arguments for a function
# @args @args defines positional parameters ($1, $2, etc) and their roles
# @vars @vars identifies global variables required or modified by the function
# @deps @deps lists function, script, or package dependencies
# @req @req specifies prerequisites or state requirements (e.g., must be root)
# @rule @rule outlines logic constraints or mandatory behaviors
# @note @note provides administrative or general notes for the user or maintainer
# @warn @warn provides administrative warning for user or maintainer

SAFE_message_n()   # (POSIX) display text message $@ w/o newline
{ printf " ${BGon}*${Boff} "; printf "%s" "$*"; }
# use "$*" to avoid word-split and keep message_n simple
#{ printf " ${BGon}*${Boff} "; echo_n_long -4 $*; }  ## maybe malfunctioned
# use "$*" to calculate message length, but use $* to word-split for smart wrapping
# calling echo_n_long with $1 = -4 because it offsets _indent = $1 + 7 [display_vars format]
#(old){ printf " ${BGon}*${Boff} " ; printf "$@" ; }

arc_repeat()                # (POSIX) quickly output a string of char $1 (of len $2) (not for spaces)
{ _marker="${1:--}"; _reps="${2:-40}"; [ "${#_marker}" -gt 1 ] && \
  _marker=$(printf -- "%s" "${__marker%${_marker#?}}"); printf "%${_reps}s" | tr ' ' "$_marker" ; }

OLD_repeat()            # (POSIX) slower output a string of char $1 (of len $2)(does spaces)
{ _thing="${1:- }"; _limit="${2:-1}";
  [ "$_limit" -le 0 ] 2>/dev/null && return 0   # if limit is 0 or not a number, exit early
#  [ "${#_thing}" -gt 1 ] && _thing=$(left_most "$_thing"); _out="$_thing";
  [ "${#_thing}" -gt 1 ] && _thing="${_thing%${_thing#?}}"; _out="$_thing"; # i.e. leftmost, w/o a sub-shell
  while [ "${#_out}" -lt "$_limit" ]; do _out="${_out}${_out}"; done
  printf "%.${_limit}s" "$_out" ; unset -v _thing _limit _out ; }
# improves performance rel to earlier versions which appended one char only per loop
# trims to exact length using the precision dot format for printf ( %.[precision]s )
#   this specifies the maximum number of characters to be printed from the string

arc_echo_n_long() # wordwrap string; $1 current col, $2 = indent, remainder = message words
{ #echo -e "args: $@"; message "args: $@"; d_message "args: $@" 1  ## debugging "residue"
#  logFile=/var/tmp/_enl_trace.log  # debugging log
# @note preliminary version; works but could not handle quoted message input (do not use)
  if [ $# -lt 2 ] ; then E_message "minimum 2 args: current_col, indent; remaining args = msg words"; return 1; fi
  if ! isnumber $1 ; then E_message "Error: arg \$1 must be numeric starting caracter position"; return 1; fi
  _enl_current_col=$1                                            # assign _enl_current_col
  if isnumber "$2"; then _enl_indent=$2; else _enl_indent=0; fi  # assign _enl_indent
  shift 2  # remainder of $* are the words of the message to be smart-wrapped
  [ $# -eq 0 ] && set -- "$@" "<empty>"  # after shift; set a default message argument to "<empty>" if none provided
  _enl_tw=$(termwidth); isnumber "$_enl_tw" || _enl_tw=80  # ensure _enl_tw is a save number for math
  # calculate the "right_status collision zone" so the last wrap keeps us clear of it
  _enl_status_width=6   # e.g. "[ Ok ]" = 6 char
  _enl_buffer=4         # padding for more visually appealing wrapping
  _enl_collision_limit=$(( _enl_tw - _enl_status_width - _enl_buffer ))
  [ "$_enl_collision_limit" -lt 0 ] && _enl_collision_limit=0  # clamp to avoid negative math errors
  _enl_line_len="$_enl_current_col" # initialize with starting position
  _enl_trace=""  # for debuggin - use this to determine who printed what
  set -f  # Disable globbing to prevent interpretation of "*" as wildcard to be expanded, etc.
  # smartly consider whether to print each word or wrap it to the _enl_indent
  _enl_FIRST_WORD=$TRUE  # don't wrap for first word
#  d_log_message "_enl_tw: $_enl_tw" 5
#  d_log_message "_enl_current_col: $_enl_current_col" 5
#  d_log_message "_enl_indent: $_enl_indent" 5
#  d_log_message "_enl_collision_limit: $_enl_collision_limit" 5
#  d_log_message "_enl_line_len: $_enl_line_len" 5
#  d_log_message "_enl_FIRST_WORD: $(TrueFalse $_enl_FIRST_WORD)" 5
  while [ $# -gt 0 ]; do
    # measure the length of remaining message
    _enl_total_tail_len=$(_get_msg_len "$*")
    _enl_x_peak=$1; _enl_x_peak_len=$(_get_msg_len "$_enl_x_peak") # preview; don't shift until necessary
#    d_log_message "   [in while] _enl_total_tail_len: $_enl_total_tail_len" 5
#    d_log_message "   [in while] _enl_x_peak: $_enl_x_peak" 5
#    d_log_message "   [in while] _enl_x_peak_len: $_enl_x_peak_len" 5
    # if not the first word check if the remaining message will cross the collision limit...
    if [ $_enl_FIRST_WORD ]; then
        # start of line case (do we wrap, finish, or step?)
        if [ $(( _enl_line_len + _enl_x_peak_len )) -gt $_enl_collision_limit ]; then # wont fit; must wrap, but how?
            if [ "$_enl_line_len" -ne "$_enl_indent" ] ; then   # this is the very first word (first line) - do  a soft wrap
                # very first word is too big, switch to midline logic to wrap (stay "greedy")
#                _enl_trace="${_enl_trace}<noprint-softwrap> W1\n"
#                _enl_trace="${_enl_trace}   _enl_line_len: $_enl_line_len\n"
#                _enl_trace="${_enl_trace}   _enl_collision_limit: $_enl_collision_limit\n"
                printf "\n%b" "$(repeat ' ' $_enl_indent)"                  # W1: WRAP - soft-wrap
                _enl_line_len=$_enl_indent                                  # Note: _enl_FIRST_WORD remains true on new line
                continue   # skip the flow fi; fi; done; and while [] check; just restart while loop again with new state
            else  # this is first word of other than first line; non-fit is emergency ==> force hard wrap
                _enl_x="$1"; _enl_x_len=$(_get_msg_len "$_enl_x"); shift    # E2: WRAP - hard-wrap
                printf "%b" "$_enl_x"                                       # print whether it fits or not
#                _enl_trace="${_enl_trace}${_enl_x} E2\n"
                _enl_line_len=$(( _enl_line_len + _enl_x_len )); _enl_FIRST_WORD=$FALSE
            fi
        elif [ $(( _enl_line_len + _enl_total_tail_len )) -le $_enl_collision_limit ]; then
            printf "%b" "$*";                                               # F3: FINISH: it all fits, so print it all! (we're done)
#            _enl_trace="${_enl_trace}$* F3\n"
            break
        else  # start of line, first word exceeds limit
            _enl_x="$1"; _enl_x_len=$(_get_msg_len "$_enl_x"); shift        # S4: STEP: assign word, measure, then drop from remaining message
            printf "%b" "$_enl_x"                                           #   print this word (start of line)
#            _enl_trace="${_enl_trace}${_enl_x} S4\n"
            _enl_line_len=$(( _enl_line_len + _enl_x_len ))
            _enl_FIRST_WORD=$FALSE
        fi  # start-of-line finish or step
    else  # mid-line case (do we finish, step, or wrap?)
        if [ $(( _enl_line_len + _enl_total_tail_len + 1 )) -le $_enl_collision_limit ]; then
            printf " %b" "$*";                                              # F5: FINISH: it all fits, so print it all! (we're done)
#            _enl_trace="${_enl_trace}$* F5\n"
             break
        elif [ $(( _enl_line_len + _enl_x_peak_len + 1 )) -le $_enl_tw ]; then # remainder DOESN"T fit left of collision zone
            if  [ "$_enl_total_tail_len" -eq "$_enl_x_peak_len" ]; then     # this is the very last word
                # && [ $(( _enl_line_len + _enl_x_peak_len + 1 )) -gt "$_enl_collision_limit" ]
                #   is implied by the non selection of -le same things above for F5
                #fits in margin but last word (and we know WONT fit left of collision zone from above) - must wrap
                printf "\n$(repeat ' ' $_enl_indent)%s" "$_enl_x_peak"      # W6: WRAP/FINISH very last word, would fit in margin but not L of collision
                shift                                                       # drop for remainder (overkill - break will jump us out anyway)
#                _enl_trace="${_enl_trace}<last-word-soft-wrap> W6\n"
                _enl_line_len=$(( _enl_indent + _enl_x_peak_len ))          # also overkill - very last word already printed; don't need this any more
                break
            else
                # not last word - step (only last word needs to be bumped from collision zone
                # so there is another line on which to put right_status
                _enl_x="$_enl_x_peak"; _enl_x_len="$_enl_x_peak_len"; shift # S7: STEP: assign word, measure, then drop from remaining message
                printf " %b" "$_enl_x"                                      #   print this word (it will fit)
#                _enl_trace="${_enl_trace}${_enl_x} S7\n"
                _enl_line_len=$(( _enl_line_len + _enl_x_len + 1 ))
                # _enl_FIRST_WORD remains $FALSE
            fi
        else
            printf "\n%b" "$(repeat ' ' $_enl_indent)"                      # W8: WRAP: word wont fit, so print newline and indent
#            _enl_trace="${_enl_trace}<indent> W8\n"
            _enl_line_len=$_enl_indent; _enl_FIRST_WORD=$TRUE
        fi  # mid-line finish, step, or wrap
    fi  # first word?
  done
#  d_log_message "${_enl_trace}" 4
  set +f  # re-enable globbing
  # clean up variables to maintain "local" scope in sourced environments
  unset -v _enl_left _enl_right _enl_left_len _enl_right_len _enl_indent _enl_tw
  unset -v _enl_line_len _enl_status_width _enl_buffer _enl_collision_limit
  unset -v  _enl_total_tail_len _enl_x _enl_x_len _enl_longest _enl_FIRST_WORD 
  unset -v _enl_x_peak _enl_x_peak_len ; }
# @note keeping this as archive because it does work
# Design logic and Notes, for echo_n_long:
# (1) This function is a fragment-aware layout engine designed for posix ash compatibility
# (2) Primary objective: deterministic word-wrapping to protect the right_status collision zone
# (3) Secondary objective: visual alignment via hanging indentation
# (4) The function must know twp facts, for absolute reliability --
#     (a) where it is starting and (b) how far to indent
# (5) Thus the API must mandate the following usage rules/expectations,
#     for absolute reliability --
#     (a) $1: must be supplied as a valid number and will be assigned as _enl_current_col.
#         This informs the engine where the cursor is located before it starts printing.
#         _enl_current_col is then used to initialize tracking needed to calculate
#         (for every step) whether the considered output can fit on the current line or not,
#         thus enabling the FINISH/STEP/WRAP methodology (the basic algorithm of the function)
#     (b) $2: must be set (either to a valid number or to a null value), and it will be
#         used to assign _enl_indent (indicating how far the engine should indent any
#         second and/or subsequent line(s)-- and how to adjust its position-tracking when it
#         word-wraps the output.  If set to a null value, the function will assign
#         _enl_indent=0 (no hanging indent)
# (6) Guard/assignment logic rejects null input $1 (_enl_current_col),
#     to prevent non-deterministic wrapping behavior
# (7) Guard/assignment logic allows a null input for $2 (_enl_indent),
#     in which case, it will assign _enl_indent=0 (default)
# (8) Onus is on the caller to assign and provide the correct value for $1
#     (_enl_current_col), and consequences of this choice are thus purely
#     attributable to the caller
# Other notes:
# use printf "%b" throughout, to handle ANSI color codes, etc
# loop uses set -- $* to force word-splitting of strings for word-by-word evaluation
# clean scope is maintained by unsetting all _enl_ prefixed variables at exit
# generalized to support multiple callers objectively
# 'set -- ...' (used in guard above) tells the command to stop looking for options;
#   everything that follows is a positional argument (so e.g. "-o" or "--example"
#   won't be seen as command options
# echo_n_long is called to employ a word wrapping strategy to display its message --
#   it begins wherever the cursor is when it is called, then -
#   it respects the callers indentation request for the left edge of every wrapped line, and
#   it respects the space required for right_status on the right margin of the last line of the message
#     the first argument sent to echo_n_long ... the first argument sent to echo_n_long must be a number
# intentionally uses "for _enl_x in $@; do" (unquoted $@) in order to word split/wrap efficiently

arc_summarize_me()             # list functions in header ("source" to employ)
{
  echo
  separator "script_header_joetoo-$BUILD | content summary" && \
  message "This script header defines some ${BYon}common variables${Boff} for" && \
  message "  use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}" && \
  message "  ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and" && \
  message "  ${BYon}cursor${Boff} movement in my scripts, and it provides a number of" && \
  message "  useful ${BGon}functions${Boff}, for some routine tasks, as described below\n" && \
  grep "()" ${script_header_installed_dir%/}/script_header_joetoo | grep -v "grep" && echo && \
  msg="${BGon}* ${Boff}  ${BYon}About to run:\n        ${BBon}message${Boff}" && \
  msg="${msg}  ${BYon}\""'${BYon}VERBOSE is currently ' && \
  msg="${msg}${BGon}\$(${BBon}status_color \\\"${BRon}\$VERBOSE${BBon}\\\"${BGon})${Boff}" && \
  msg="${msg}${BGon}\$(${BBon}TrueFalse \\\"${BRon}\$VERBOSE${BBon}\\\"" && \
  msg="${msg}${BGon})${BYon}\"${BGon}; ${BBon}echo${Boff}" && echo -e "${msg}" && \
  echo && \
  cmd="${BGon}message${BWon} \"  \${BYon}VERBOSE is currently \$(${BGon}status_color ${BRon}\$VERBOSE)${BWon}\$(${BGon}TrueFalse ${BRon}\$VERBOSE${BWon})\${Boff}\"${Boff}"
  message "About to run ${cmd}"
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  message "  ${BYon}VERBOSE is currently $(status_color $VERBOSE)$(TrueFalse $VERBOSE)${Boff}" && echo && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 1 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}2 ${BYon}to${BWon} 1${Boff}  " && \
  vercomp 2 1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1 ${BYon}to${BWon} 2${Boff}  " && \
  vercomp 1 2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0 ${BYon}to${BWon} 1.2.1${Boff}  " && \
  vercomp 1.2.0 1.2.1; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.2.0-r1 ${BYon}to${BWon} 1.2.0${Boff}  " && \
  vercomp 1.2.0-r1 1.2.0; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1..1 ${BYon}to${BWon} 1.2${Boff}  " && \
  vercomp 1..1 1.2; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}1.0 ${BYon}to${BWon} 1.0-r10${Boff}  " && \
  vercomp 1.0 1.0-r10; echo -e "$(show_result $?)" && \
  message_n "${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  " && \
  vercomp 3.4 3.4-r2; echo -e "$(show_result $?)" && echo && \
  message "${BYon}Conditionally execute \$@ IAW verbosity (3) with ${BGon}d_do ${Boff}echo \"line 1.1\" \\; echo \"line 1.2\" 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  d_do echo "line 1.1" \; echo "line 1.2" 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && \
  message "${BYon}Conditionally execute \$1 IAW verbosity (3) with ${BGon}debug_do ${Boff}'echo \"line 2.1\" ; echo \"line 2.2\"' 2" && \
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3 && \
  debug_do 'echo "line 2.1" ; echo "line 2.2"' 2 && \
  VERBOSE=$OLDVERBOSE && verbosity=$oldv && echo "" && \
  message "${BYon}Summary of some T/F tests with ${BGon}status_color${Boff}( ) and ${BGon}TrueFalse${Boff}( ) --" && \
  for x in y Y t T up n N f F down 0 1 z "" ; do message "  ${BWon}testing: [${BCon}${x}${BWon}] is $(status_color $x)$(TrueFalse $x)${Boff}" ; done && \
  message "  ${BWon}testing: [${BCon}\$TRUE${BWon}] is $(status_color $TRUE)$(TrueFalse $TRUE)${Boff}" && \
  message "  ${BWon}testing: [${BCon}\$FALSE${BWon}] is $(status_color $FALSE)$(TrueFalse $FALSE)${Boff}" && \
  E_message "Note: bash and most other shells evaluate a variable with null ('') value as ${BRon}FALSE${Boff} and any non-null value as ${BGon}TRUE${Boff}" && \
  echo && \
  msg="${BYon}About to run: ${BBon}sh_countdown ${Boff}3${BGon} && ${BCon}echo ${BGon}&& ${Boff}" && \
  msg="${msg}${BBon}message_n${Boff} \"" && \
  msg="${msg}Finishing with status of summarization ---> \" ${BGon}; ${BBon}right_status ${BRon}\$?${BGon}; ${BBon}echo${Boff}" && \
  message "${msg}" && \
  sh_countdown 3 && echo && \
  message_n "Finishing with status of summarization --->" ; right_status $?; echo

  return 0
}


old_d_build_and_do() # Internal helper: Not for direct use.
{ (  _i=0; _arg_count=$(( $# - 1 ));
    while [ "$_i" -lt "$_arg_count" ]; do  # -lt excludes last element (level)
      _arg="$1"; shift; set -- "$@" "$_arg"; _i=$((_i + 1))  # ${_args:+ } is a space if _args is set; nothing if unset
    done ; shift  # discard last argument (level)
    "$@" # execute the command parts with original quoting preserved
  ) ; }
# $1= command # $2...$n = command ($1) args ($2 - n-1) and level ($n)
# (level is compare to global verbosity by calling function but ignored by -lt test below)
# Use a subshell to avoid changing the original positional parameters ($@)
# (*** this is trickier with a command and its args, because it is essential not to word-split the args ***)
# use a "rotation" scheme, use set and shift to pull each arg from $1 and append it to the end
# of the list of positional parameters (except, not the last; w/ -lt _arg_count)
# also note: the command itself is the _arg=$1 assigned in the first iteration


old_debug_do()          # (POSIX) IAW verbosity, execute one command
{ # guard; check for min. 2 args (word + level) and for unset global verbosity
  [ $# -lt 2 ] && { E_message "minimum 2 args required <command string> <level>"; return 1 }
  [ -z "$verbosity" ] && { E_message "Error: global verbosity not set"; return 2; }
  # assign the last argument to _dbd_level
  #   _dbd_level will now equal the last argument (equivalent to for _dbd_level in "$@"; do :; done)
  for _dbd_level; do :; done;
  [ "$_dbd_level" -le "$verbosity" ] && _d_build_and_do "$@"
  unset -v _dbd_level; }

old_demonstrate_header() # demonstrate classes of capability in this header file
{
  # @usage demonstrate_header
  # @args none
  # @note each script header file in the script_header_joetoo family has a similarly named demonstrate_header function
  # @note e.g. demonstrate_header_unicode() in script_header_joetoo_unicode
  _dh_PN=$(basename "$0")
  _dh_FLAGGED=$FALSE
  # localize color variables to differentiate 'live' UI color from 'literal' payload text
  _BRon="${BRon}" ; _BGon="${BGon}" ; _BYon="${BYon}" ; _BBon="${BBon}"
  _BMon="${BMon}" ; _BCon="${BCon}" ; _BWon="${BWon}" ; _Boff="${Boff}"
  _Ron="${Ron}" ; _Gon="${Gon}" ; _Yon="${Yon}" ; _Bon="${Bon}"
  _Mon="${Mon}" ; _Con="${Con}" ; _Won="${Won}" 

  separator "${_dh_PN}" "(demonstration)"

  # use message_n -> echo_n_long to smart wrap a colorized description of header general capabilities
#  _dh_msg="This script header defines some ${BYon}common variables${Boff} for"
#  _dh_msg="${_dh_msg} use in various scripts, it provides pre-formatted ${BYon}easy-to-use${Boff}"
#  _dh_msg="${_dh_msg} ${BYon}ANSI Escape sequences${Boff} to facilitate the use of ${BMon}color${Boff} and"
#  _dh_msg="${_dh_msg} ${BYon}cursor${Boff} movement in my scripts, and it provides a number of"
#  _dh_msg="${_dh_msg} useful ${BGon}functions${Boff}, for some routine tasks, as described below\n"
#  message_n "${_dh_msg}"
# use message_n -> echo_n_long to smart wrap a colorized description of header general capabilities

  # use message_n -> echo_n_long to smart wrap a colorized description of header general capabilities
  _dh_msg="This script header is a robust ${BYon}POSIX-compliant utility suite${Boff}. Its core capabilities include:"
  message "${_dh_msg}"

  # Variable Definitions
  _dh_msg="${BCon}Variable Definitions:${Boff} Constants for error messages, pseudo-booleans "
  _dh_msg="${_dh_msg}(${BYon}TRUE=0/FALSE=\"\"${Boff}), and terminal state defaults."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # Validation Functions
  _dh_msg="${BCon}Validation Functions:${Boff} Logic to verify specific numeric types like integers, "
  _dh_msg="${_dh_msg}hex values, and floats (${BYon}isint, ishexint, isfloat${Boff}), consolidated in ${BYon}isnumeric${Boff}."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # System and Shell Checks
  _dh_msg="${BCon}System and Shell Checks:${Boff} Tools to verify root status (${BYon}checkroot${Boff}), "
  _dh_msg="${_dh_msg}specific mount points (e.g., ${BYon}checkboot${Boff}), and shell interactivity."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # ANSI Escape Sequences
  _dh_msg="${BCon}ANSI Escape Sequences:${Boff} A comprehensive set of variables for text styling "
  _dh_msg="${_dh_msg}(colors, bold, underline, reverse) and cursor manipulation (${BYon}HCU/SCU, SCP/RCP, CUP${Boff})."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # Messaging Tier
  _dh_msg="${BCon}Messaging Tier:${Boff} A categorized system including standard (${BYon}message${Boff}), "
  _dh_msg="${_dh_msg}warning (${BYon}W_message${Boff}), and error (${BYon}E_message${Boff}) outputs with visual color-coded distinction."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # Box Drawing
  _dh_msg="${BCon}Box Drawing:${Boff} Mappings for DEC Special Graphics characters (e.g., "
  _dh_msg="${_dh_msg}${BYon}H_wall='q', V_wall='x', corners${Boff}) and state control (${BYon}ESCon, SO, SI${Boff})."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  # Debugging and Logging
  _dh_msg="${BCon}Debugging and Logging:${Boff} Conditional execution/messaging based on verbosity "
  _dh_msg="${_dh_msg}levels and timestamped file logging functions (e.g., ${BYon}d_log_message${Boff})."
  printf "    "; message_n ""; echo_n_long 7 7 "${_dh_msg}"; printf "\n"

  [ $? -eq 0 ] || _dh_FLAGGED=$TRUE

  # demonstrate message, status_color, TrueFalse, and use of VERBOSE and color codes
  cmd="${_Gon}message${_Won} \"  ${Mon}\${BYon}${_Boff}VERBOSE is currently \$(${_Gon}status_color"
  cmd="${cmd} ${_Ron}\$VERBOSE)${_Won}\$(${_Gon}TrueFalse"
  cmd="${cmd} ${_Ron}\$VERBOSE${_Won})${Mon}\${Boff}\"${_Boff}"
  message "$BYon}About to run:${Boff}\n    ${cmd}"
  OLDVERBOSE=$VERBOSE ; oldv=$verbosity ; VERBOSE=$TRUE ; verbosity=3
  message "  ${BYon}VERBOSE is currently $(status_color $VERBOSE)$(TrueFalse $VERBOSE)${Boff}"
  [ $? -eq 0 ] || _dh_FLAGGED=$TRUE
  VERBOSE=$OLDVERBOSE && verbosity=$oldv

  # demonstrate vercomp with a variety of comparisons
  for _dh_vtest in "1 1" "2 1" "1 2" "1.2.0 1.2.1" "1.2.0-r1 1.2.0"; do
    _dh_v1=${_dh_vtest% *}
    _dh_v2=${_dh_vtest#* }
    message_n "${_BYon}Compare version ${_BWon}${_dh_v1} ${_BYon}to ${_BWon}${_dh_v2}${_Boff}  "
    vercomp "$_dh_v1" "$_dh_v2"
    _dh_vercomp_result=$?
    printf "%b\n" "$(show_result $_dh_vercomp_result)"
    show_result $_dh_vercomp_result >/dev/null 2>&1
    _dh_show_ressult_status_code=$?
    [ $_dh_show_ressult_status_code= -eq 0 ] || _dh_FLAGGED=$TRUE
  done

  # demonstrate numeric validation utilities
  message "${BYon}Demonstrating Numeric Validation Utilities --${Boff}"

  _dh_tests="isint|123|0 isint|abc|1 isfloat|3.14|0 isfloat|123|1 ishexint|0xAF|0 ishexint|123|1 isnumeric|42.5|0 isnumeric|0xCC|0 isnumeric|xyz|1"
  _dh_sep=" "; _dh_sep_len=${#_dh_sep}
  _dh_min=2

  # First Pass: Calculate max lengths and fixed column widths (_col)
  _dh_max_test_len=0; _dh_max_val_len=0
  for _dh_t in ${_dh_tests}; do
    _dh_test=$(echo "${_dh_t}" | cut -d'|' -f1); [ ${#_dh_test} -gt $_dh_max_test_len ] && _dh_max_test_len=${#_dh_test}
    _dh_val=$(echo "${_dh_t}" | cut -d'|' -f2); [ ${#_dh_val} -gt $_dh_max_val_len ] && _dh_max_val_len=${#_dh_val}
  done

  # Set fixed widths for the three padded columns
  _dh_col_test=$((_dh_max_test_len + _dh_min))
  _dh_col_val=$((_dh_max_val_len + 10)) # Account for " with '...'"
  _dh_col_TF=10                        # Fixed width for "[True ]" / "[False]"

  # Second Pass: Print Aligned Table
  for _dh_t in ${_dh_tests}; do
    _dh_test=$(echo "${_dh_t}" | cut -d'|' -f1)
    _dh_val=$(echo "${_dh_t}" | cut -d'|' -f2)
    _dh_exp=$(echo "${_dh_t}" | cut -d'|' -f3)

    ${_dh_test} "${_dh_val}" >/dev/null 2>&1
    _dh_result=$?

    [ "$_dh_result" -eq 0 ] && _dh_RESULT=$TRUE || _dh_RESULT=$FALSE
    _dh_RESULT="[$(TrueFalse $_dh_RESULT)]"
    _dh_colored_status="$(status_color $_dh_RESULT)${_dh_RESULT}${Boff}"

    [ "${_dh_result}" -ne "${_dh_exp}" ] && { _dh_FLAGGED=$TRUE; _dh_pass_fail="${BRon}FAIL${Boff}"; } || _dh_pass_fail="${BGon}PASS${Boff}"

    # 1. Row Start
    message_n "Testing "

    # 2. Pad Function Name (Column 1)
    printf "%b%s%b%s" "$BCon" "$_dh_test" "$Boff" "$_dh_sep"
    pad "$_dh_test" "$_dh_sep_len" "$_dh_min" "$BCon" "." "$_dh_col_test"

    # 3. Pad Value Segment (Column 2)
    _dh_v_label="with '${_dh_val}'"
    printf " with '%b%s%b'%s" "$BYon" "$_dh_val" "$Boff" "$_dh_sep"
    pad "$_dh_v_label" "$_dh_sep_len" "$_dh_min" "$BCon" "." "$_dh_col_val"

    # 4. Pad Status Segment (Column 3)
    printf " %b%s" "${_dh_colored_status}" "$_dh_sep"
    pad "$_dh_RESULT" "$_dh_sep_len" "$_dh_min" "$BCon" "." "$_dh_col_TF"

    # 5. Result and Pass/Fail
    printf " (ret:%s) -> %b\n" "$_dh_result" "$_dh_pass_fail"
  done

  unset -v _dh_tests _dh_sep _dh_sep_len _dh_min _dh_max_test_len _dh_max_val_len \
           _dh_col_test _dh_col_val _dh_col_TF _dh_t _dh_test _dh_val _dh_exp \
           _dh_result _dh_RESULT _dh_RESULT _dh_colored_status _dh_pass_fail _dh_v_label
  printf "\n"

  # demonstrate d_do with a complex 2-part command
  cmd="${_BGon}d_do ${_BYon}\"echo \\\" line 1.1\\\"; echo \\\" line 1.2\\\"\" ${_BMon}2${Boff}"
  message "$BYon}About to run:${Boff}\n ${cmd}"
  OLDVERBOSE=$VERBOSE && oldv=$verbosity && VERBOSE=$TRUE && verbosity=3
  message "Demonstrating debug_do with its verosity level: 2 and actual verbosity: [$verbosity] ..."
  d_do 'echo "      line 1.1"; echo "      line 1.2"' 2
  [ $? -eq 0 ] || _dh_FLAGGED=$TRUE ; printf "\n"
  VERBOSE=$OLDVERBOSE && verbosity=$oldv

  # demonstrate T/F Y/N tests
  cmd="${_BGon}for ${_BCon}x ${_BGon}in ${_BYon}y Y t T up n N f F down 0 1 z \"\" ${_BGon}; do${Boff}\n"
  cmd="${cmd}    ${_BWon}message_n ${_BYon}\"  \${BWon}testing: [\${BCon}\${x}\${BWon}] is \$(${_BGon}status_color ${_BCon}\$x${_BWon})\$(${_BGon}TrueFalse ${_BCon}\$x${_BWon})\${Boff}\"${Boff}\n"
  cmd="${cmd}    ${_BGon}if [ ${_BYon}\"\$(${_BGon}TrueFalse ${_BCon}\$x${_BYon})\" ${_BWon}== ${_BYon}\"True\" ${_BGon}] ; then ${_BWon}right_status ${_BCon}\$TRUE${Boff}\n"
  cmd="${cmd}    ${_BGon}else ${_BWon}right_status ${_BMon}1${_BGon}; fi${Boff}"
  message "$BYon}About to run:${Boff}\n${cmd}"
  printf "\n"
  message "${BYon}Summary of some T/F tests with ${BGon}status_color${Boff}( ) and ${BGon}TrueFalse${Boff}( ) --"
  for x in y Y t T up n N f F down 0 1 z "" ; do
    message_n "  ${BWon}testing: [${BCon}${x}${BWon}] is $(status_color $x)$(TrueFalse $x)${Boff}"
    if [ "$(TrueFalse $x)" == "True" ] ; then right_status $TRUE
    else right_status 1; fi
    [ $? -eq 0 ] || _dh_FLAGGED=$TRUE
  done
  message "  ${BWon}testing: [${BCon}\$TRUE${BWon}] is $(status_color $TRUE)$(TrueFalse $TRUE)${Boff}"
  message "  ${BWon}testing: [${BCon}\$FALSE${BWon}] is $(status_color $FALSE)$(TrueFalse $FALSE)${Boff}"
  E_message_n ""; echo_n_long 3 "" "Note: bash and most other shells evaluate a variable with null ('') value as ${BRon}FALSE${Boff} and any non-null value as ${BGon}TRUE${Boff}"
  printf "\n"
  # demonstrate progress_inline progress bar
  cmd="${_BGon}for ${_BCon}x ${_BGon}in ${_BWon}\$(${_BGon}seq ${_BMon}0 25${_BWon})${_Boff}${_BGon}; do ${_BWon}progress_inline ${_BCon}\$x ${_BMon}25${_Boff}${_BGon}; sleep ${_BMon}0.2${_Boff}${_BGon}; done${Boff}"
  message "$BYon}About to run:${Boff}\n ${cmd}"
  for x in $(seq 0 25); do progress_inline $x 25; sleep 0.2; done
  [ $? -eq 0 ] || _dh_FLAGGED=$TRUE
  printf "\n"

  # demonstrate countdown
  cmd="${_BGon}sh_countdown ${_BMon}3${_Boff}"
  message "$BYon}About to run:${Boff}\n ${cmd}"
  sh_countdown 3
  [ $? -eq 0 ] || _dh_FLAGGED=$TRUE

  printf "\n"
  # demonstrate message_n and right_status
  cmd="${_BGon}message_n ${_BYon}\"${_BCon}\${BCon}${_BYon}Finishing with status of summarization --->\${Boff}\"${Boff}"
  message "$BYon}About to run:${Boff}\n ${cmd}"
  message_n "${Con}Finishing with status of summarization --->${Boff}" ; [ $_dh_FLAGGED ] ; right_status $?
  printf "\n"

  return 0
}

_d_build_and_log() # Internal helper: Not for direct use.
{ # internal "heavy lifter" for the old (pre d_do) d_log_message family
  # It handled the isolation of the verbosity level (the last argument) from the message string
  # $1 = printf format string; $2 = timestamp; $3...$n = message words and level
  # (level is compare to global verbosity by calling function but ignored by -lt test below)
  # note: _fmt for logging should be "%s - %s"  w/ or w/o \n depending on calling function
  _fmt="$1"; _ts="$2"; shift 2
  # Use a subshell to avoid changing the original positional parameters ($@)
  ( _msg=""; _i=0; _word_count=$(( $# - 1 ))
    while [ "$_i" -lt "$_word_count" ]; do  # -lt excludes last element (level)
      _msg="${_msg}${_msg:+ }$1"; shift; _i=$((_i + 1)) # ${_msg:+ } is a space if _msg is set; nothing if unset
    done
    # remember to pass two strings to match expected format in _fmt
    printf "$_fmt" "$_ts" "$_msg" >> "$logFile"
  )
  unset -v _fmt _ts; }


_d_build_and_print() # Internal helper: Not for direct use.
{ # internal "heavy lifter" for the old (pre d_do) d_message family
  # It handled the isolation of the verbosity level (the last argument) from the message string
  # $1 = printf format string; $2...$n = message words and level
  # (level is compare to global verbosity by calling function but ignored by -lt test below)
  _fmt="$1"; shift
  # Use a subshell to avoid changing the original positional parameters ($@)
  ( _msg=""; _i=0; _word_count=$(( $# - 1 ))
    while [ "$_i" -lt "$_word_count" ]; do  # -lt excludes last element (level)
      _msg="${_msg}${_msg:+ }$1"; shift; _i=$((_i + 1)) # ${_msg:+ } is a space if _msg is set; nothing if unset
    done
    printf "$_fmt" "$_msg"
  )
}
# Legacy note; retained as a learning point.
# $* vs. $@ (Quoted) in the final printf: Inside double quotes, "$*" joins all positional
# parameters into a single string separated by the first character of $IFS (which is
# typically a space). This converts the injected timestamp and the message into one string

isnumber() # (POSIX) deprecated - use isint(); tests if $1 is an integer
{ [ $# -eq 0 ] && return 1  # guard clause: check if an argument was provided
  _val=$1
  _test_val="${_val#-}"  # Remove leading dash (negative # ok; test the rest)
  case "$_test_val" in
    "" | *[!0-9]* ) unset -v _val _test_val; return 1 ;;
    *        ) unset -v _val _test_val; return 0 ;;
  esac ; }


myBOX()     # draw an esc-seq single-line box
{
  local i; local ULrow; local ULcol; local WT; local HT; local myBOX=""
  local FG; local BG; local B
  # default position to centered, upper 1/3
  [[ -z $3 ]] && WT=50 || WT=$3; [[ -z $4 ]] && HT=15 || HT=$4
  [[ -z $1 ]] && ULrow=$(( $(termheight)/3 - $HT/2 )) || ULrow=$1
  [[ -z $2 ]] && ULcol=$(( $(termwidth)/2 - $WT/2 )) || ULcol=$2
  [[ -z $5 ]] && FG=${WHITE} || FG=$5; [[ -z $6 ]] && BG=${BACKoff} || BG=$6
  [[ -z $7 ]] && B=${SGRoff} || B=$7
  # begin box draw with openning escape sequence
  myBOX=${myBOX}${ESCon}
  # draw top line with spaces, UL corner, H-lines, UR corner, <CR>
  myBOX=${myBOX}${Boff}$(repeat " " ${ULcol})$(color ${FG} ${BG} ${B})${UL_wall}$(repeat ${H_wall} ${WT})${UR_wall}${Boff}"\n"
  # draw HT number of : space, V-line, space, V-line, <CR>
  for ((i=1;i<${HT};i++)); do
    myBOX=${myBOX}$(repeat " " ${ULcol})$(color ${FG} ${BG} ${B})${V_wall}$(repeat " " ${WT})${V_wall}${Boff}"\n"; done
  # draw bottom line with spaces, LL corner, H-lines, LR corner, <CR>
  myBOX=${myBOX}$(repeat " " ${ULcol})$(color ${FG} ${BG} ${B})${LL_wall}$(repeat ${H_wall} ${WT})${LR_wall}${Boff}"\n"
  # complete box draw with closing escape sequnce
  myBOX=${myBOX}${ESCoff}
  # position curson at left of upper row inside box
  CLR; CUP ${ULrow} 1
  printf "${myBOX}"
  CUP $(termheight) 1
  return 0
}

msgBOX()    # draw an esc-seq single-line message box
{
  local i; local ULrow; local ULcol; local WT; local HT; local myBOX=""
  local FG; local BG; local B; local TITLE; local MSG; local LINE
  # default position to centered, upper 1/3
  [[ -z $3 ]] && WT=50 || WT=$3; [[ -z $4 ]] && HT=15 || HT=$4
  [[ -z $1 ]] && ULrow=$(( $(termheight)/3 - $HT/2 )) || ULrow=$1
  [[ -z $2 ]] && ULcol=$(( $(termwidth)/2 - $WT/2 )) || ULcol=$2
  [[ -z $5 ]] && FG=${WHITE} || FG=$5; [[ -z $6 ]] && BG=${BACKoff} || BG=$6
  [[ -z $7 ]] && B=${SGRoff} || B=$7
  [[ -z $8 ]] && TITLE="joetoo MessageBox" || TITLE="$8"
  [[ -z $9 ]] && MSG="Message goes here..." || MSG="$9"

  myBOX "$ULrow" "$ULcol" "$WT" "$HT" "$FG" "$BG" "$B"
  LINE="${MSG:$(($WT - 4))}"
  # break message up into appropriate width chuncks, using a 2-space margin inside the box

  CUP $(termheight) 1
  return 0
}

my_u_BOX()  # draw a unicode single-line box
{
  local i; local ULrow; local ULcol; local WT; local HT; local myBOX=""
  [[ -z $1 ]] && ULrow=1 || ULrow=$1; [[ -z $2 ]] && ULcol=1 || ULcol=$2
  [[ -z $3 ]] && WT=50 || WT=$3;      [[ -z $4 ]] && HT=15 || HT=$4
  myBOX=${myBOX}$(repeat " " ${ULcol})${uUL_wall}$(repeat ${uH_wall} ${WT})${uUR_wall}"\n"
  for ((i=1;i<${HT};i++)); do myBOX=${myBOX}$(repeat " " ${ULcol})${uV_wall}$(repeat " " ${WT})${uV_wall}"\n"; done
  myBOX=${myBOX}$(repeat " " ${ULcol})${uLL_wall}$(repeat ${uH_wall} ${WT})${uLR_wall}"\n"
  CLR; CUP ${ULrow} ${ULcol}
  printf "${myBOX}"
  return 0
}

my_uD_BOX() # draw a unicode double-line box
{
  local i; local ULrow; local ULcol; local WT; local HT; local myBOX=""
  [[ -z $1 ]] && ULrow=1 || ULrow=$1; [[ -z $2 ]] && ULcol=1 || ULcol=$2
  [[ -z $3 ]] && WT=50 || WT=$3;      [[ -z $4 ]] && HT=15 || HT=$4
  myBOX=${myBOX}$(repeat " " ${ULcol})${uD_UL_wall}$(repeat ${uD_H_wall} ${WT})${uD_UR_wall}"\n"
  for ((i=1;i<${HT};i++)); do myBOX=${myBOX}$(repeat " " ${ULcol})${uD_V_wall}$(repeat " " ${WT})${uD_V_wall}"\n"; done
  myBOX=${myBOX}$(repeat " " ${ULcol})${uD_LL_wall}$(repeat ${uD_H_wall} ${WT})${uD_LR_wall}"\n"
  CLR; CUP ${ULrow} ${ULcol}
  printf "${myBOX}"
  return 0
}

modular_msg()          # w/in margins, output externally assigned ${MSG} to array ${LINE[@]}
{
[[ $# -gt 1 ]] && E_message "Too many arguments" && E_message "exiting process [$$]" && exit 1
local WT=0  ## width of box
local WIDTH=0 ## width between box margins
local LENGTH=0 ## length of current line

[[ -z $1 ]] && WT=70 || WT=$1
WIDTH=$(($WT - 4))

d_message "Box width=[${WT}]" 3
d_message "Available width=[${WIDTH}]" 3
# Break the message up into appropriate width chunks, with a 2-space margin, by inserting newline character
#   in place of appropriate spaces, or breaking words if the word itself is longer than the available width.
#   Don't split or count length of escape sequences
local i=1              ## line counter
local ESFLAG=$FALSE    ## flag to indicate whether the current character is part of an esc sequence
local c=0              ## character counter
local char=""          ## current character
local w=1              ## word counter
local WORD=("")        ## current word
local EOW=$FALSE       ## End of Word flag
local breakpoint=0     ## pointer to where we might break up a word
local LEFTOVER         ## part of a word that's left over if we have to break it up
local EOL=$FALSE       ## End of Line flag

d_message "MSG=[${MSG}]" 2
echo

MSG=$(echo "$MSG" | sed 's/^[ \t]*//')  # strip leading whitespace
d_message "stripped MSG=[${MSG}]" 2
echo

# fill one line, one character at at time, escape sequences don't have "length" to count
LINE[i]=""; let "LENGTH=0"  ## (re)initialize
d_message "Now working on line $i" 3
WORD[w]=""; let "WLEN=0"
d_message "Now working on word $w" 3
for ((c=0; c<${#MSG}; c++))
do
  ## fill a word until you get to a space or termination of escape sequence, then if it will fit, add the word
  #    to the current line, if not then if it's not just longer than a whole line, add it to the next, else split
  #    it to finish this and add the rest to the next
  char=${MSG:$c:1}
  d_message "  examining char $c, [${char}]" 3
  case "${char}" in
    '\' ) # escaped char(s) coming (this has no "length" so just keep adding to current word at no "length cost")
      ESFLAG=$TRUE
      d_message "Started escape sequence with special character [${char}]" 3
      ;;
    [tnrm] ) # these char's can terminate an escape sequence if ESFLAG is TRUE, if so they also terminate a word
      # or they can count as length if not part of an esc seq
      if [[ $ESFLAG ]]
      then
        EOW=$TRUE
        ESFLAG=$FALSE
        d_message "Terminated escape sequence and word with special character [${char}]" 3
      else
        let "WLEN+=1"
        d_message "Added (tnrm) character [${char}] to WORD[$w]" 3
      fi
      ;;
    " " )  # a space terminates a word
      EOW=$TRUE
      let  "WLEN+=1"
      d_message "Added space character [${char}] to WORD[$w]" 3
      ;;
    * ) # all other characters, handle depending on status of ESFLAG
      # count the char only if not part of an esc sequence
      if [[ ! $ESFLAG ]]; then let "WLEN+=1"; d_message "Added (non-special) char [${char}] to WORD[$w]" 3 ;
      else d_message "Added (non-special) char [${char}] to escape sequence WORD[$w]" 3 ; fi
      ;;
  esac
  WORD[w]+="${char}"  # add char to the current word
  d_message_n "${BYon}>>>${Boff}  " 3 ; [[ $verbosity -ge 3 ]] && d_echo "WORD[$w]=[${WORD[w]}]" 3
  d_message "ESFLAG=[$(status_color $ESFLAG)$(TrueFalse $ESFLAG)${Boff}]" 3
  d_message "EOW=[$(status_color $EOW)$(TrueFalse $EOW)${Boff}]" 3
  d_message "EOL=[$(status_color $EOL)$(TrueFalse $EOL)${Boff}]" 3

  # if we got to the end of the word, dispose of it and start a new one
  if
 [[ $EOW ]]
  then
    if [[ $((${LENGTH} + ${WLEN})) -lt ${WIDTH} ]]
    then   # its added length will fit, so just add the word to the current line, and count the new length
      LINE[i]+="${WORD[w]}"
      let "LENGTH+=${WLEN}"
      d_message "Disposed of word by adding to current line" 3
    elif [[ ${WLEN} -gt ${WIDTH} ]]
    then   # it is bigger than a whole line, so break it to put what will fit on the current line and put the rest on the next line
      breakpoint=$((${WIDTH} - ${LENGTH}))
      LINE[i]+="${WORD[w]:0:${breakpoint}}"
      LEFTOVER="${WORD[w]:${breakpoint}}"
      let "LENGTH+=${breakpoint}"
      EOL=$TRUE
      d_message "Disposed of word by breaking it at [${breakpoint}] to finish LINE[$i]; LEFTOVER=[${LEFTOVER}]" 3
    else   # close out this line, and add this word to the *next* line
      EOL=$TRUE
      LEFTOVER="${WORD[w]}"
      d_message "Disposed of word WORD[$w], which was too big to fit on LINE[$i] but fits the next, by deferring it; LEFTOVER=[${LEF>
    fi
    d_message_n "${BYon}Final word: ${Boff}" 3 ; d_echo "WORD[$w]=[${WORD[w]}], WLEN=[${WLEN}]" 3
    d_message_n "${BYon}Current line: ${Boff}" 2 ; d_echo "LINE[$i]=[${LINE[i]}], LENGTH=[${LENGTH}]" 2
    let "w+=1"; d_echo 3 ; d_message "Now working on word $w" 3
    WORD[w]=""; let "WLEN=0"; EOW=$FALSE  ## (re)initialize
  fi
  # if we filled the line, start a new one
  if [[ $EOL ]]
  then
    d_message_n "${BMon}Final line: ${Boff}" 2 ; d_echo "LINE[$i]=[${LINE[i]}], LENGTH=[${LENGTH}]" 2
    let "i+=1"; d_echo 2; d_message "Now working on line $i" 2
    LINE[i]="${LEFTOVER}"; let "LENGTH=${#LEFTOVER}"; LEFTOVER=""; EOL=$FALSE  ## (re)initialize
    d_message_n "Starting with LINE[$i]=" 2 ; d_echo "[${LINE[i]}], LENGTH=[${LENGTH}]" 2
  fi
done

# now dump the array --> do something like this in calling function (see summarize_my_extension, below)
#d_echo "dumping array ..." 1
#for ((i=1; i<${#LINE[@]}; i++))
#do
#  SCP; echo -en ${LINE[i]}; RCP; CUD 1
#done

}

echo_n_long() # wordwrap string; $1 current col, $2 = indent, remainder = message words
{ # @warn need to incorporate _msg=$(printf '%b' "$*" | tr '\t\n' '  ') to filter/translate these special cases - but don't want to bre>
#echo -e "args: $@"; message "args: $@"; d_message "args: $@" 1  ## debugging "residue"
#  logFile=/var/tmp/_enl_trace.log  # debugging log
  if [ $# -lt 2 ] ; then E_message "minimum 2 args: current_col, indent; remaining args = msg words"; return 1; fi
  if ! isint $1 ; then E_message "Error: arg \$1 must be numeric starting caracter position"; return 1; fi
  _enl_current_col=$1                                            # assign _enl_current_col
  if isint "$2"; then _enl_indent=$2; else _enl_indent=0; fi  # assign _enl_indent
  shift 2  # remainder of $* are the words of the message to be smart-wrapped
  # (do not translate internal escapes ([:control:] chars like \n, \t, \r, etc.)
  #  b/c want to preserve (e.g. multi-line prompt) line formatting, and
  #  do not strip_ansi b/c want to preserve color codes, etc; only remove those in subshell to get_msg_len)
#  _enl_msg=$(printf '%b' "$*" | _translate_escapes)   # operate on entire set of args as a single string "$*"
  _enl_msg="$*"   # operate on entire set of args as a single string "$*"
  # perform controlled split on the remaining parameters ($@)
  set -f     # Disable globbing to prevent interpretation of "*" as wildcard to be expanded, etc.
  # safely convert a positional parameters (either multiple args or a single quoted string) into individual words
  set -- $_enl_msg    # set with $_enl_msg unquoted so each split word becomes a positional parameter
  set +f     # re-enable globbing (minimize the "blast radius" of the globbing-disabled state)
  # after shift and reassembly; set a default message argument to "<empty>" if none provided
  [ $# -eq 0 ] && set -- "$@" "<empty>"
  _enl_tw=$(termwidth); isint "$_enl_tw" || _enl_tw=80  # ensure _enl_tw is a save number for math
  # calculate the "right_status collision zone" so the last wrap keeps us clear of it
  _enl_status_width=6   # e.g. "[ Ok ]" = 6 char
  _enl_buffer=4         # padding for more visually appealing wrapping
  _enl_collision_limit=$(( _enl_tw - _enl_status_width - _enl_buffer ))
  [ "$_enl_collision_limit" -lt 0 ] && _enl_collision_limit=0  # clamp to avoid negative math errors
  _enl_line_len="$_enl_current_col" # initialize with starting position
  _enl_trace=""  # for debuggin - use this to determine who printed what
  # smartly consider whether to print each word or wrap it to the _enl_indent
  _enl_FIRST_WORD=$TRUE  # don't wrap for first word
#  d_log_message "_enl_tw: $_enl_tw" 5
#  d_log_message "_enl_current_col: $_enl_current_col" 5
#  d_log_message "_enl_indent: $_enl_indent" 5
#  d_log_message "_enl_collision_limit: $_enl_collision_limit" 5
#  d_log_message "_enl_line_len: $_enl_line_len" 5
#  d_log_message "_enl_FIRST_WORD: $(TrueFalse $_enl_FIRST_WORD)" 5
  while [ $# -gt 0 ]; do
    # measure the length of remaining message
    _enl_total_tail_len=$(get_msg_len "$*")
    _enl_x_peak=$1; _enl_x_peak_len=$(get_msg_len "$_enl_x_peak") # preview; don't shift until necessary
#    d_log_message "   [in while] _enl_total_tail_len: $_enl_total_tail_len" 5
#    d_log_message "   [in while] _enl_x_peak: $_enl_x_peak" 5
#    d_log_message "   [in while] _enl_x_peak_len: $_enl_x_peak_len" 5
    # if not the first word check if the remaining message will cross the collision limit...
    if [ $_enl_FIRST_WORD ]; then
        # start of line case (do we wrap, finish, or step?)
        if [ $(( _enl_line_len + _enl_x_peak_len )) -gt $_enl_collision_limit ]; then # wont fit; must wrap, but how?
            if [ "$_enl_line_len" -ne "$_enl_indent" ] ; then   # this is the very first word (first line) - do  a soft wrap
                # very first word is too big, switch to midline logic to wrap (stay "greedy")
#                _enl_trace="${_enl_trace}<noprint-softwrap> W1\n"
#                _enl_trace="${_enl_trace}   _enl_line_len: $_enl_line_len\n"
#                _enl_trace="${_enl_trace}   _enl_collision_limit: $_enl_collision_limit\n"
                printf "\n%b" "$(repeat ' ' $_enl_indent)"                  # W1: WRAP - soft-wrap
                _enl_line_len=$_enl_indent                                  # Note: _enl_FIRST_WORD remains true on new line
                continue   # skip the flow fi; fi; done; and while [] check; just restart while loop again with new state
            else  # this is first word of other than first line; non-fit is emergency ==> force hard wrap
                _enl_x="$1"; _enl_x_len=$(get_msg_len "$_enl_x"); shift    # E2: WRAP - hard-wrap
                printf '%b' "$_enl_x"                                       # print whether it fits or not
#                _enl_trace="${_enl_trace}${_enl_x} E2\n"
                _enl_line_len=$(( _enl_line_len + _enl_x_len )); _enl_FIRST_WORD=$FALSE
            fi
        elif [ $(( _enl_line_len + _enl_total_tail_len )) -le $_enl_collision_limit ]; then
            printf '%b' "$*";                                               # F3: FINISH: it all fits, so print it all! (we're done)
#            _enl_trace="${_enl_trace}$* F3\n"
            break
        else  # start of line, first word exceeds limit
            _enl_x="$1"; _enl_x_len=$(get_msg_len "$_enl_x"); shift        # S4: STEP: assign word, measure, then drop from remaining m>
            printf '%b' "$_enl_x"                                           #   print this word (start of line)
#            _enl_trace="${_enl_trace}${_enl_x} S4\n"
            _enl_line_len=$(( _enl_line_len + _enl_x_len ))
            _enl_FIRST_WORD=$FALSE
        fi  # start-of-line finish or step
    else  # mid-line case (do we finish, step, or wrap?)
        if [ $(( _enl_line_len + _enl_total_tail_len + 1 )) -le $_enl_collision_limit ]; then
            printf " %b" "$*";                                              # F5: FINISH: it all fits, so print it all! (we're done)
#            _enl_trace="${_enl_trace}$* F5\n"
             break
        elif [ $(( _enl_line_len + _enl_x_peak_len + 1 )) -le $_enl_tw ]; then # remainder DOESN"T fit left of collision zone
            if  [ "$_enl_total_tail_len" -eq "$_enl_x_peak_len" ]; then     # this is the very last word
                # && [ $(( _enl_line_len + _enl_x_peak_len + 1 )) -gt "$_enl_collision_limit" ]
                #   is implied by the non selection of -le same things above for F5
                # fits in margin but last word (and we know WONT fit left of collision zone from above) - must wrap
                printf "\n$(repeat ' ' $_enl_indent)%s" "$_enl_x_peak"      # W6: WRAP/FINISH very last word, would fit in margin but n>
                shift                                                       # drop for remainder (overkill - break will jump us out any>
#                _enl_trace="${_enl_trace}<last-word-soft-wrap> W6\n"
                _enl_line_len=$(( _enl_indent + _enl_x_peak_len ))          # also overkill - very last word already printed; don't nee>
                break
            else
                # not last word - step (only last word needs to be bumped from collision zone
                # so there is another line on which to put right_status
                _enl_x="$_enl_x_peak"; _enl_x_len="$_enl_x_peak_len"; shift # S7: STEP: assign word, measure, then drop from remaining >
                printf " %b" "$_enl_x"                                      #   print this word (it will fit)
#                _enl_trace="${_enl_trace}${_enl_x} S7\n"
                _enl_line_len=$(( _enl_line_len + _enl_x_len + 1 ))
                # _enl_FIRST_WORD remains $FALSE
            fi
        else
            printf "\n%b" "$(repeat ' ' $_enl_indent)"                      # W8: WRAP: word wont fit, so print newline and indent
#            _enl_trace="${_enl_trace}<indent> W8\n"
            _enl_line_len=$_enl_indent; _enl_FIRST_WORD=$TRUE
        fi  # mid-line finish, step, or wrap
    fi  # first word?
  done
#  d_log_message "${_enl_trace}" 4
  # clean up variables to maintain "local" scope in sourced environments
  unset -v _enl_buffer _enl_collision_limit _enl_current_col _enl_FIRST_WORD
  unset -v _enl_indent _enl_line_len _enl_status_width _enl_total_tail_len
  unset -v _enl_trace _enl_tw _enl_x _enl_x_len _enl_x_peak _enl_x_peak_len
}
# @usage echo_n_long "$start" "$indent" "$message"
# @deps _translate_escapes, strip_ansi
# @req The function must know two facts, for absolute reliability -- where it is starting and (b) how far to indent
# @rule $1 (start) must be supplied as a decimal integer. This informs the engine where the cursor is located before it starts printing>
# @rule $2 (indent) must be set (either to a decimal integer or null value). This informs the engine where to put the indent on subsequ>
# @note (1) This function is a fragment-aware smart-wrapping layout engine designed for posix ash compatibility
# @note (2) Primary objective: deterministic word-wrapping to protect the right_status collision zone
# @note (3) Secondary objective: visual alignment via hanging indentation
# @warn The engine is highly reliable. Onus is on the caller to assign and provide the correct values for $1 and $2 and consequences of>
#
# Design and Maintenance Notes:
# _enl_current_col is then used to initialize tracking needed to calculate
#    (for every step) whether the considered output can fit on the current line or not,
#    thus enabling the FINISH/STEP/WRAP methodology (the basic algorithm of the function)
# _enl_indent indicates how far the engine should indent any second and/or subsequent line(s)
#    and how to adjust its position-tracking when it word-wraps the output
#    If set to a null value, the function will assign _enl_indent=0 (no hanging indent)
# Guard/assignment logic rejects null input $1 (_enl_current_col),
#     to prevent non-deterministic wrapping behavior
# Guard/assignment logic allows a null input for $2 (_enl_indent),
#     in which case, it will assign _enl_indent=0 (default)
# use printf '%b' throughout, to handle ANSI color codes, etc
# loop uses set -- $* inside set -f/set +f globbing protection to safely force word-splitting
#   of strings for word-by-word evaluation
# clean scope is maintained by unsetting all _enl_ prefixed variables at exit
# history: originally was a dedicated backend helper for display_vars, later generalized
#   to support multiple callers objectively
# 'set -- ...' (described above) tells the command to stop looking for options;
#   everything that follows is a positional argument (so e.g. "-o" or "--example"
#   won't be seen as command options
# The engine employs a word wrapping algorithm to display its message --
#   it begins wherever the cursor is when called, then -
#   it respects the callers indentation request for the left edge of every wrapped line, and
#   it respects the space required for right_status on the right margin of the last line
#     of the message

# dont need these anymore - I have posix version now
# CPR, QCR, and QCC moved here due to ash-incompatibility (uses bash array and ${var:n} form)
CPR()       # CPR [r|c] - echo # of cursor row, col, or both (w/o leading ESC[, trailing R)
{ QUERY="${CSI}6n"; echo -en "${QUERY}" ; read -sdR CURPOS < /dev/tty
  IFS=';' read -ra COORDS <<< "${CURPOS:2}" ; case ${1:0:1} in
    [rR]) echo "${COORDS[0]}" | cut -d';' -f1 ;; # report row
    [cC]) echo "${COORDS[1]}" | cut -d';' -f2 ;; # report col
    [sS]) :  ;;                                  # be silent
    *   ) echo "${COORDS[@]}" ;; esac ; }        # report both
# NOTE: read -sdR CURPOS reads from tty (force that), but read -ra COORDS reads from a variable

QCR()       # use silent CPR to report row
{ CPR s; echo "${COORDS[0]}" ; }
QCC()       # use silent CPR to report column
{ CPR s; echo "${COORDS[1]}" ; }

### this piece of shit Gemini suggestion does NOT work
process_cmdline() {
    separator "$PN" "(process_cmdline)"

    # pre-process all positional parameters to extract numbers and use to assign
    #   RESUME and starting_step, with last-man-wins prioritization
    d_log_message "about to start preprocessing with \$@: [$@]" 1
    _pc_new_args=""
    for _pc_arg in "$@"; do
        d_log_message "BREAK ============================================================" 1
        d_log_message "starting a new opro-processing loop iteration" 1
        d_log_message "_pc_arg: $_pc_arg" 1
        case "$_pc_arg" in
            --*)      # shield - ignore long-options completely
                _pc_new_args="${_pc_new_args} $_pc_arg"
                ;;

            -*[0-9]*) # "peeler" - matches -r27, -i3n17, -22, etc.
                # (matches any single-dash arg containing at least one digit)
                _pc_nums=$(printf '%s' "$_pc_arg" | tr -c '0-9' ' ')
                _pc_nums=$(echo $_pc_nums)    # squeeze spaces (not sure this is necessary)
                _pc_int=${_pc_nums##* }       # get last integer (last man wins)
                if [ ! -z "$_pc_int" ]; then
                    starting_step="$_pc_int"
                    RESUME=$TRUE
                    d_log_message "set RESUME = $(status_color $RESUME)$(TrueFalse RESUME)${Boff}; starting_step: [${Mon}$starting_step${Bof>
                fi
                # strip digits to leave clean flags (e.g., -i3n17 -> -in)
                _pc_clean_flag=$(printf '%s' "$_pc_arg" | tr -d '0-9')
                # Only pass back if it contains characters besides just the dash
                [ "$_pc_clean_flag" != "-" ] && _pc_new_args="${_pc_new_args} $_pc_clean_flag"
                ;;

            [0-9]*)   # "standalone" --matches "27" ( in (e.g.) --resume 27, or even -rsv 21, or JUST 5 )
                starting_step="$_pc_arg"
                RESUME=$TRUE
                d_log_message "set RESUME = $(status_color $RESUME)$(TrueFalse RESUME)${Boff}; starting_step: [${Mon}$starting_step${Boff}]">
                ;;

            *)        # default - 4. DEFAULT: Matches -i, -v, or non-numeric positional strings
                _pc_new_args="${_pc_new_args} $_pc_arg"
                ;;
        esac
    done
    # now set the result as the new positional parameters
    set -- $_pc_new_args
    OPTIND=0
    # now use nested loops to process --long_options in the outer loop and
    #   short_option clusters in the inner loop (with getopts)
    # optstring establishes the list of recognized flags) (see getopts --help)
    _pc_optstring="insrvq"
    d_log_message "_pc_optstring: $_pc_optstring" 5
    d_log_message "\$@: $@" 5
    while [ $# -gt 0 ]; do
        d_log_message "BREAK ============================================================" 1
        d_log_message "starting a new outer loop iteration" 1
        d_log_message "_pc_opt: $_pc_opt" 1
        d_log_message "OPTIND: $OPTIND" 1
        d_log_message "OPTARG: $OPTARG" 1
        d_log_message "OPTERR: $OPTERR" 1
        d_log_message "NAME: $NAME" 1
        d_log_message "\$1: $1" 1
        d_log_message "\$@: $@" 1
        case "$1" in
            # tier 1 - standard long options
            --status)  # POSIX math: report step-1 as completed
                if [ -f "$status_file" ]; then read _pc_val < "$status_file"
                    log_message "${BWon}Status: Step $(( _pc_val - 1 )) complete; next is [ ${BMon}${_pc_val}${BWon} ]${Boff}"
                else log_message "${BWon}Status: No status file; sequence not yet started${Boff}"; fi; exit 0 ;;
            --resume) RESUME=$TRUE; if isint "$2"; then starting_step="$2"; shift 2
                else  read starting_step < "$status_file" 2>/dev/null || starting_step=1; shift; fi
                d_log_message "set RESUME = $(status_color $RESUME)$(TrueFalse RESUME)${Boff}; starting_step: [${Mon}$starting_step${Boff}]">
            --interactive)    INTERACTIVE=$TRUE; shift
                d_log_message "set INTERACTIVE = $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff};" 2 ;;
            --noninteractive) INTERACTIVE=$FALSE; shift
                d_log_message "set INTERACTIVE = $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff};" 2 ;;
            --verbose)        verbosity=$(( verbosity + 1 )); shift
                d_log_message "set verbosity: [${Mon}$verbosity${Boff}]" 2 ;;
            --quiet)          verbosity=$(( verbosity - 1 )); shift
                d_log_message "set verbosity: [${Mon}$verbosity${Boff}]" 2 ;;
            # NOTE: to enable local extension of this baseline parser, unrecognized --options must
            #   be allowed to "fall through" to be processed by the local hook-script, if available
##            --* )  log_E_message "unrecognized long_option $1; (ignoring it)"; shift ;;

            # tier 2 - clustered shorts & embedded numbers (e.g. -iv12)
            -[!-]*)  # use getopts to process single-hyphen prefixed "short" (single-char) options
                # this inner-loop allows getopts to automatically advance through positional parameters
                # until it encounters an unrecognized option, at which point it will ... (what exactly?)
                # any non-failing iteration will assign _pc_opt (to "?" if unrecognized), and
                # the inner-loop case logic deals with each accordingly
                #
                # each iteration of "getopts $_pc_optstring _pc_opt" assigns the next
                # letter in the current positional parameter and OPTIND pointing at
                # the next parameter which will be processed when we run out of letters in the current one
                # (getopts then increments OPTIND, so the outer loop will know how many "shifts" to do before
                # resetting OPTIND to 1 and looping to the next word
                while getopts "$_pc_optstring" _pc_opt; do
                    d_log_message "BREAK -----------------------------------------------------" 1
                    d_log_message "starting a new inner loop iteration" 1
                    d_log_message "_pc_opt: $_pc_opt" 1
                    d_log_message "OPTIND: $OPTIND" 1
                    d_log_message "OPTARG: $OPTARG" 1
                    d_log_message "OPTERR: $OPTERR" 1
                    d_log_message "NAME: $NAME" 1
                    d_log_message "\$1: $1" 1
                    d_log_message "\$@: $@" 1

                   case "$_pc_opt" in
                        i) INTERACTIVE=$TRUE
                            d_log_message "set INTERACTIVE = $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff};" 2 ;;
                        n) INTERACTIVE=$FALSE
                            d_log_message "set INTERACTIVE = $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff};" 2 ;;
                        v) [ "$verbosity" -lt 6 ] && verbosity=$(( verbosity + 1 ))
                            d_log_message "set verbosity: [${Mon}$verbosity${Boff}]" 2 ;;
                        q) [ "$verbosity" -gt 0 ] && verbosity=$(( verbosity - 1 ))
                            d_log_message "set verbosity: [${Mon}$verbosity${Boff}]" 2 ;;
                        r) RESUME=$TRUE
                            # read file only if no number was found in this cluster
                            if [ -z "$_pc_num" ]; then read starting_step < "$status_file" 2>/dev/null || starting_step=1; fi
                            d_log_message "set RESUME = $(status_color $RESUME)$(TrueFalse RESUME)${Boff}  starting_step: [${Mon}$starting_s>
                        s) # re-use the status logic above (manually)
                           read _pc_val < "$status_file" 2>/dev/null || _pc_val=1
                           log_message "Next step: $_pc_val"; exit 0 ;;
                        *) # "bow out" and defer to hook script named by $local_process_cmdline_arguments, if it exists
                            if [ -f "$local_process_cmdline_arguments" ]; then
                                d_log_message "running hook script $local_process_cmdline_arguments $_pc_opt" 2
                                "$local_process_cmdline_arguments $_pc_opt"
                                # got here w/o getting shunted to usage - check return from local extension
                                # (code 0: success; 6: used an operand (need extra shift); other: fail
                                [ "$_rs_result" -eq 6 ] && shift
                                ret="$_rs_result"
                            else
                                d_log_message "unrecognized option [$_pc_opt]" 2
                            fi
                            ;;
                    esac
                done  # current positional parameter's letters have all been checked
                d_log_message "just exited inner loop with \$1 = $1" 1
                shift $(( OPTIND - 1 )) # shift to next word/arg
                OPTIND=1 ;;             # point at first word/arg again

            # tier 3 - any unrecognized - or -- options should be examined by local hook extension, if it exists

            *)  # defer to hook script named by $local_process_cmdline_arguments, if it exists
                if [ -f "$local_process_cmdline_arguments" ]; then
                    d_log_message "running hook script $local_process_cmdline_arguments" 2
                    "$local_process_cmdline_arguments"
                    # got here w/o getting shunted to usage - check return from local extension
                    # (code 0: success; 6: used an operand (need extra shift); other: fail
                    [ "$_rs_result" -eq 6 ] && shift
                    ret="$_rs_result"
                else
                   d_log_message "unrecognized option [$1]" 2
                fi
                ;;
        esac
    done  # done with $1 - each case above shifted at least 1, so drive on

    unset -v _pc_optstring _pc_cluster _pc_num _pc_val _pc_opt _pc_total_steps
    unset -f _pc_emit_status
    return $ret
}
# usage process_cmdline [args]
# args $@: command line arguments to be parsed
# vars INTERACTIVE, RESUME, starting_step, verbosity, status_file
# ret 0: success; exit 1: invalid operand or out of range
# deps isint, log_message, d_log_message, log_E_message, usage, tr, printf, read, cat
# rule  if $local_process_cmdline_arguments file exists,
# @cont it extends functionality local to the calling script
# rule starting_step is validated against global num_cmds
# rule last-instruction-wins precedence is enforced via linear while-loop;
# ex process_cmdline -iv24; process_cmdline --resume 5; process_cmdline -s


#--------------------------

old_checkboot() # check to see if /boot is a mountpoint and is properly mounted
{ _fstab_check=$(grep -E "${W1}/boot(${W1}|$)" /etc/fstab | grep -v "^${W0}#") # find /boot entries; strip comments
  if [ -z "$_fstab_check" ]; then set -- 2; # not supposed to be a mountpoint
  elif grep -qE "${W1}/boot(${W1}|$)" /proc/mounts 2>/dev/null || \
     grep -qE "${W1}/boot(${W1}|$)" /etc/mtab 2>/dev/null; then
    set -- 0; # properly mounted
  else
    set -- 1; # Listed in fstab but NOT mounted
  fi; unset -v _fstab_check; return ${1:-255}; }  # default 255 (so we know it broke if $1 is empty)
# @usage checkboot
# @ret 0: mounted; 1: in fstab but unmounted; 2: no /boot entry in fstab
# @ret 255: internal logic failure
# @rule uses REGEX_POSIX (W0, W1) to parse /etc/fstab and /proc/mounts safely
# @note status 2 indicates /boot is likely just a directory on the root partition
# @note fstab format: |<device|uuid> /boot ...| i.e. mountpoint is colunm 2 preceded by <device|uuid> and ${W1}
# @cont followed by whitespace or (rarely) simply the end of the line -- (${W1}|$)

message() # (POSIX) display text message $@ (like echo -e)
{ printf " ${BGon}*${Boff} " ; printf '%b\n' "$*" ; }
# @usage message "msg string"
# @args $* the message to display (quoted string recommended)
# @ret formatted message with green asterisk prefix to stdout
# @note use "$*" to bind message as a single string (no word-split)
# @note use '%b' (expand backslash) to interpret e.g. \n (like echo -e)


W_message() # (POSIX) display text warning message $@ (like echo -e)
{ printf " ${BYon}*${Boff} " ; printf '%b\n' "$*" ; }
# @usage W_message "warning string"
# @args $@ message components
# @ret formatted warning with yellow asterisk prefix to stdout
# @note use "$*" to bind message as a single string (no word-split)
# @note use '%b' (expand backslash) to interpret e.g. \n (like echo -e)

E_message() # (POSIX) display text error message $@ (like echo -e)
{ { printf " ${BRon}*${Boff} "; printf '%b\n' "$*"; } >&2; }
# @usage E_message "error string"
# @args $* the error message
# @ret formatted error with red asterisk prefix to stderr (FD 2)
# @note use "$*" to bind message as a single string (no word-split)
# @note use '%b' (expand backslash) to interpret e.g. \n (like echo -e)


log_message() # (POSIX) message() to stdout and $logFile owned by $user (like echo -e)
{ log_m_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  message "$*"        # print regular message w/o timestamp
  # filter the message through strip_ansi before logging
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  # print clean, timestamped message to logFile
  printf "%s - %s\n" "$_ts" "$_clean_msg" >> "$logFile" || log_m_ret=1
  unset -v _ts _clean_msg
  return $log_m_ret
}
# @usage log_message "msg string"
# @args $* the message to log (treated as a single string)
# @vars logFile
# @deps timestamp message _translate_escapes strip_ansi
# @note dual-output: terminal receives timestamped color message; log receives plain text
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%b' (expand backslash) to interpret e.g. \n in message (like echo -e)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

log_echo() # (POSIX) echo to stdout and $logFile owned by $user (like echo)
{ log_e_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  printf "%s\n" "$*" # screen gets color codes
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s\n" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_e_ret
}
# @usage log_echo "msg string"
# @args $* the message string
# @vars logFile
# @deps timestamp _translate_escapes strip_ansi
# @rule simple echo wrapper with automated timestamping and log archival
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%s' (no expand backslash) to interpret e.g. \n in message (like echo)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp



log_E_message() # (POSIX) E_message() to stdout and $logFile owned by $user (like echo -e)
{ log_E_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  E_message "$*"
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s\n" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_E_ret
}
# @usage log_E_message "error string"
# @args $* the error message components
# @vars logFile
# @deps timestamp E_message _translate_escapes strip_ansi
# @rule directs colorized output to stderr and sanitized plain-text to $logFile
# @note dual-stream logic: terminal sees RED alert; log records timestamped event
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%b' (expand backslash) to interpret e.g. \n in message (like echo -e)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

old_d_message()   # (POSIX) IAW verbosity, display text debugging message $@
{ d_do message "$@" >&2 ; }
# @usage d_message "message string" <level>

dE_message()   # (POSIX) IAW verbosity, display text debugging error message $@
{ d_do E_message "$@" >&2 ; }
# @usage dE_message "message string" <level>

d_log_message()     # (POSIX) display and log message IAW verbosity
{ d_do log_message "$@" >&2 ; }
# @usage d_log_message "message string" <level>

d_log_E_message()   # (POSIX) display and log error message IAW verbosity
{ d_do log_E_message "$@" >&2 ; }
# @usage d_log_E_message "message string" <level>

log_echo() # (POSIX) echo to stdout and $logFile owned by $user (like echo)
{ log_e_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  printf "%s\n" "$*" # screen gets color codes
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s\n" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_e_ret
}
# @usage log_echo "msg string"
# @args $* the message string
# @vars logFile
# @deps timestamp _translate_escapes strip_ansi
# @rule simple echo wrapper with automated timestamping and log archival
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%s' (no expand backslash) to interpret e.g. \n in message (like echo)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

d_echo()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo)
{ d_do echo "$@" >&2 ; }
# @usage d_echo "message string" <level>

de_echo()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo -e)
{ d_do echo -e "$@" >&2 ; }
# @usage de_echo "message string" <level>

d_log_echo()        # (POSIX) display and log simple message IAW verbosity (like echo)
{ d_do log_echo "$@" >&2 ; }
# @usage d_log_echo "message string" <level>

d_log_echo_e()      # (POSIX) display and log simple message IAW verbosity (like echo -e)
{ d_do log_echo_e "$@" >&2 ; }
# @usage d_log_echo_e "message string" <level>

separator() # (POSIX) draw a horizontal line with preface $1 and title $2
{ s_ret=0; _s_preface=${1:-$(hostname)}; _s_tw=$(termwidth)
  _s_title=${2:-${0##*/}}   # ${0##*/} is equivalent to basename "$0" but w/o subshell function call
  _s_reps=$(( _s_tw - ( ${#_s_preface} + ${#_s_title} + 8 ) ))
  [ "$_s_reps" -lt 0 ] && _s_reps=0  # clamp to 0 if negative
  # build this as one block so we can get a maintainable format and a single exit status code
  ( set -- '%b---[ %b%s %b%s %b]%s%b'
    set -- "$@" "$BYon" "$BRon"
    set -- "$@" "$_s_preface" "${Boff}${BCon}" "$_s_title"
    set -- "$@" "$BYon" "$(repeat '-' "$_s_reps")" "$Boff"
    printf "$@" ; ) ; s_ret=$?
  unset -v _s_preface _s_title _s_tw _s_reps
  return $s_ret
}
# to facilitate separation of portions of the output of various scripts
# @usage separator "preface" "title"
# @args $1 preface string (defaults to hostname); $2 title string (defaults to script name)
# @deps termwidth repeat
# @rule calculates terminal width to draw a full-width horizontal rule
# @note subtracts 8 characters for brackets and spacing to prevent wrapping

non_stty_separator() # (deprecated; use separator)
{ W_message "${BYon}Warning:${Boff} non_stty_separator is deprecated (use separator(), which has been upgraded)"
  separator "$@"; }
# @usage non_stty_separator "preface" "title"
# @note legacy wrapper; redirects to separator() after emitting a warning

log_separator() # (POSIX) output separator() to stdout and similar to logFile
{ ls_ret=0; _ls_preface=${1:-$(hostname)};
#  _ls_title=${2:-$(basename "$0")}
  _ls_title=${2:-${0##*/}}   # ${0##*/} is equivalent to basename "$0" but w/o subshell function call
  _ls_ts="$(timestamp)"; _ls_tw=80  # standard fixed width for log files
  # construct the header string: "timestamp - ---[ preface title ]"
  _ls_clean_header="${_ls_ts} - ---[ ${_ls_preface} ${_ls_title} ]"
  _ls_len=$(printf '%s' "$_ls_clean_header" | wc -c)
  _ls_reps=$(( _ls_tw - $_ls_len ))  # calculate the length of the rest of the  ----- line
  [ "$_ls_reps" -lt 0 ] && _ls_reps=0      # if negative, clamp to 0
  # output (console screen first, then log)
  separator "$_ls_preface" "$_ls_title"    # out to console screen
  # output a "clean" version (w/o colors) to the log file
  { printf '%s' "$_ls_clean_header"
    repeat '-' "$_ls_reps"
    printf "\n"
  } >> "$logFile" || ls_ret=1
  unset -v _ls_preface _ls_title _ls_ts _ls_clean_header _ls_reps _ls_len
  return $ls_ret
}
# @usage log_separator "preface" "title"
# @args $1 preface; $2 title
# @vars logFile
# @deps timestamp separator repeat
# @rule emits colorized line to stdout and a 80-char timestamped plain-text line to $logFile
# @note enforces a standard 80-character fixed width for log files to ensure readability


d_log_separator() # (POSIX) conditionally output separator() to stdout and similar to logFile IAW verbosity
{ d_do log_separator "$@" >&2 ; }
# @usage d_log_separator "preface" "title" <level>


right_status() # (POSIX) output 8 char [ ok/fail ] status at the right margin
{ [ $# -lt 1 ] && { E_message "Error: 0 args. right_status requires integer status code"; return 1; }
  _rs_status=$1; _rs_msg=""
  if [ "$_rs_status" -eq 0 ] ; then
    _rs_msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}"
  else
    _rs_msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}"
  fi
  # go to start of line, *then* move fwd to 7 chars from the right margin
  # Note: "[ xx ]" is 6 chars, so this should ensure no accidental extra line wrap
  _rs_tw=$(termwidth)
  # ensure we have a valid width for arithmetic
  isint "$_rs_tw" || _rs_tw=80
  # calculate movement value separately for clarity/safety
  _rs_move=$(( _rs_tw - 7 ))
  # clamp move value to 0 to prevent negative arguments to CUF
  [ "$_rs_move" -lt 0 ] && _rs_move=0
  # move
  printf '%b' "\r"  # beginning of current line (return 1 if failed)
  if ! CUF "$_rs_move" ; then unset -v _rs_status _rs_msg _rs_tw _rs_move; return 1; fi
  # final status output
  printf '%b' "${_rs_msg}\n"; unset -v _rs_status _rs_msg _rs_tw _rs_move; return 0; }
# @usage right_status "status"
# @args $1 integer status code
# @deps termwidth isint CUF
# @rule calculates movement value as termwidth - 7 to protect right margin
# @rule clamps move value to 0 to prevent negative CUF arguments
# @ret exit 0 on success; exit 1 on movement failure
# @ex message_n "good_test" ; right_status $?
# @ex E_message_n "fail_test" && cat unexistent 2>/dev/null; right_status $?
# @note go to start of line, *then* move fwd to 7 chars from the right margin
# @note "[ xx ]" is 6 chars, so this should ensure no accidental extra line wrap # @usage right_status "status"
# @args status must be integer status code
# guard - reject zero args
# @ex message_n "good_test" ; right_status $?
# @ex E_message_n "fail_test" && cat unexistent 2>/dev/null; right_status $?

old_log_right_status() # (POSIX) output rigit_status to stdout and logFile
{ log_rs_ret=0
  # guard - reject zero args
  [ $# -lt 1 ] && { E_message "Error: 0 args. right_status requires integer status code"; return 1; }
  _lrs_status=$1; if [ "$_lrs_status" -eq 0 ] ; then
    _lrs_msg="${BBon}[ ${BGon}Ok ${BBon}]${Boff}"
    _lrs_plain="[ Ok ]"
  else
    _lrs_msg="${BBon}[ ${BRon}!! ${BBon}]${Boff}"
    _lrs_plain="[ !! ]"
  fi
  # get width for screen positioning. note: termwidth() will fallback
  #   to standard 80 cols if COLUMNS, tput, and stty don't work
  _lrs_tw=$(termwidth); isint "$_lrs_tw"; _lrs_offset=$(( _lrs_tw - 7 ))
  printf "\r"
  if CUF "$_lrs_offset" ; then printf '%b\n' "$_lrs_msg"; else printf " %b\n" "$_lrs_msg"; fi
  # clean logging
  if [ -n "$logFile" ]; then printf '%s\n' "$_lrs_plain" >> "$logFile" || log_rs_ret=1; fi
  unset -v _lrs_msg _lrs_status _lrs_plain _lrs_tw _lrs_offset
  return $log_rs_ret
}
# @usage log_right_status "status"
# @args $1 integer status code
# @deps termwidth isint CUF E_message
# @rule uses \r and CUF to align terminal status to the far right margin
# @rule provides a clean [ Ok ] or [ !! ] entry to $logFile without timestamping
# @note maintainer note: deliberate decision to NOT have log_right_status timestamp
# @note its entries to help this "context aware" logging scheme be more readable
# @ex log_message_n "good_test" ; log_right_status $?
# @ex log_E_message_n "fail_test" && cat unexistent 2>/dev/null; log_right_status $?
# maintainer note: deliberate decision to NOT have log_right_status timestamp
#   its entries to help this "context aware" logging scheme be more readable
#   the alternative would be to "revert" to an "atomic" logging scheme
#   in which logged action goes on a separate line with its own timestamp
# note: 7 is the offset from right margin for six char status
#  [ ok ] or [ !! ], because it leaves a one-char buffer to guarantee
#  exactly one (and no accidental extra) newline

old_d_right_status()    # output rigit_status IAW verbosity
{ d_do right_status "$@" >&2 ; }
# @usage d_right_status <status_code> <level>

old_d_log_right_status()# output log_right_status IAW verbosity
{ d_do log_right_status "$@" >&2 ; }
# @usage d_log_right_status "message string" <level>

non_stty_right_status()    # (deprecated; use right_status)
{
  W_message "${BYon}Warning:${Boff} non_stty_right_status is deprecated (use right_status(), which has been upgraded)"
  right_status "$@"
}


handle_result() # (POSIX) output ok_/_err_msg and right_stats to stdout
{ hr_ret=0; _exit_status="$1"; _ok_msg_in="$2"; _err_msg_in="$3"
  if [ "$_ok_msg_in" = "${no_msg}" ] ; then _ok_msg=""; else _ok_msg=" (${BGon}${2:-success!}${Boff})"; fi
  if [ "$_err_msg_in" = "${no_msg}" ] ; then _err_msg=""; else _err_msg=" (${BRon}${3:-error!}${Boff})"; fi
  if [ "$_exit_status" -eq 0 ] ; then
      printf '%b' "${_ok_msg}"  # replicates echo -e -n
      right_status 0
  else
      printf '%b' "${_err_msg}"  # replicates echo -e -n
      right_status 1
      hr_ret=1
  fi
  unset -v _exit_status _ok_msg _err_msg _ok_msg_in _err_msg_in
  return $hr_ret; }
# @usage handle_result "$?" "ok_msg" "err_msg"
# @args $1 exit status; $2 success message; $3 error message
# @deps right_status status_color
# @rule handles optional message suppression via no_msg variable
# @ret exit 0 on success; exit 1 on failure
# @note usage - message_n ...; <command>] ; handle_result "$?" "_ok_msg" "_err_msg"
# @note notes - substitute no_msg=" \b" for either, to "suppress"
# @note use '%b' (expand backslash) to interpret e.g. \n (like echo -e)

old_log_handle_result() # (POSIX) output ok_/_err_msg and right_stats to stdout and logFile
{ log_hr_ret=0; _exit_status="$1"; _ok_msg_in="$2"; _err_msg_in="$3"
  if [ "$_ok_msg_in" = "${no_msg}" ] ; then _ok_msg=""; else _ok_msg=" (${BGon}${2:-success!}${Boff})"; fi
  if [ "$_err_msg_in" = "${no_msg}" ] ; then _err_msg=""; else _err_msg=" (${BRon}${3:-error!}${Boff})"; fi
  if [ "$_exit_status" -eq 0 ]; then
      printf "%b" "${_ok_msg}"             # print to screen (expanded)
      _c_msg=$(printf '%s' "${_ok_msg}" | _translate_escapes | strip_ansi)
      printf "%s" "$_c_msg" >> "$logFile"  # write to log (safe/cleaned) - NO NEW TIMESTAMP
      log_right_status 0
  else
      printf "%b" "${_err_msg}"
      _c_msg=$(printf '%s' "${_err_msg}" | _translate_escapes | strip_ansi)
      printf "%s" "$_c_msg" >> "$logFile"
      log_right_status 1
      log_hr_ret=1
  fi
  unset -v _exit_status _ok_msg _err_msg _ok_msg_in _err_msg_in _c_msg
  return $log_hr_ret
}   
# @usage log_handle_result "$?" "ok_msg" "err_msg"
# @args $1 exit status; $2 success string; $3 error string
# @note appends to existing screen/log entry w/o new timestamp
# @deps log_echo_e_n log_right_status
# @rule handles optional message suppression via no_msg variable
# @ret exit 0 on success; exit 1 on failure
# @ex log_message_n ...; <command>] ; log_handle_result "$?" "_ok_msg" "_err_msg"
# @note substitute no_msg=" \b" for either, to "suppress"

old_d_log_handle_result() # output ok_/_err_msg and right_stats to stdout and logFile
{ d_do log_handle_result "$@" >&2 ; }
# @usage d_log_handle_result "message string" <level>

old_d_handle_result() # output ok_/_err_msg and right_stats to stdout and logFile
{ d_do handle_result "$@" >&2 ; }
# @usage d_handle_result "message string" <level>

old_message_n() # (POSIX) display text message $@ w/o newline (like echo -e -n)
{ _mn_msg="$*"; _mn_msg_len=$(get_msg_len "$_mn_msg")
  _mn_status_width=6   # e.g. "[ Ok ]" = 6 char
  _mn_buffer=4         # padding for more visually appealing wrapping
  # | * message
  #  123
  _mn_col=3; _mn_indent=3; _mn_tw=$(termwidth)
  _mn_collision_threshold=$(( _mn_tw - _mn_status_width - _mn_buffer - _mn_col )) # prep to protect long msg
  [ "$_mn_collision_threshold" -lt 0 ] && _mn_collision_threshold=0   # clamp to 0 if negative
  printf " ${BGon}*${Boff} ";  # print the "prefix *"
  if [ $_mn_msg_len -gt $_mn_collision_threshold ]; then
    # use smart_wrap_n with "$_mn_msg" quoted for smart word-wrap; room for right_status; and align w indent
#    echo_n_long "${_mn_col}" "${_mn_indent}" "$_mn_msg"
    smart_wrap_n "${_mn_col}" "${_mn_indent}" "${_mn_indent}" "$_mn_msg"
  else
    printf '%b' "$*"        # use "$*" quoted to pass a single string
  fi; unset -v _mn_msg _mn_msg_len _mn_status_width _mn_buffer _mn_tw _mn_collision_threshold _mn_col _mn_indent; }
# @usage message_n "msg string"
# @args $* the message to display
# @deps get_msg_len termwidth smart_wrap_n
# @rule smart_wrap_n uses a collision threshold for last-word-wrapping, which
# @cont protects the right_status collision zone for subsequent right_status calls
# @note message family indent is 3; smart_wrap_n requires valid numbers for col, l_margin, r_margin

E_message_n() # (POSIX) display text error message $@ (no CR) (like echo -e -n)
{ { printf " ${BRon}*${Boff} " ; printf '%b' "$*" ; } >&2; }
# @usage E_message_n "error string"
# @args $* the error message
# @ret formatted error with red asterisk prefix to stderr without trailing newline
# @note protects the right_status collision zone for subsequent right_status calls
# @note use "$*" to bind message as a single string (no word-split)
# @note use '%b' (expand backslash) to interpret e.g. \n (like echo -e)

 
log_message_n() # (POSIX) message() to stdout and $logFile owned by $user (like echo -e -n)
{ log_mn_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  message_n "$*"
  # filter the message through strip_ansi before logging
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_mn_ret
}
# @usage log_message_n "msg string"
# @args $* the message to log
# @vars logFile
# @deps timestamp message_n _translate_escapes strip_ansi
# @rule suppresses newline in both stdout and $logFile
# @note protects the right_status collision zone for subsequent right_status calls
# @note useful for logging status start-points before a process completes
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%b' (expand backslash) to interpret e.g. \n in message (like echo -e)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

                                                           [ Ok ]
log_message_n() # (POSIX) message() to stdout and $logFile owned by $user (like echo -e -n)
{ log_mn_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  message_n "$*"
  # filter the message through strip_ansi before logging
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_mn_ret
}
# @usage log_message_n "msg string"
# @args $* the message to log
# @vars logFile
# @deps timestamp message_n _translate_escapes strip_ansi
# @rule suppresses newline in both stdout and $logFile
# @note protects the right_status collision zone for subsequent right_status calls
# @note useful for logging status start-points before a process completes
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%b' (expand backslash) to interpret e.g. \n in message (like echo -e)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

d_message_n()   # (POSIX) IAW verbosity, display text debugging message $@ (no CR)
{ d_do message_n "$@" >&2 ; }
# @usage d_message_n "message string" <level>

dE_message_n()   # (POSIX) IAW verbosity, display text debugging error message $@ (w/o CR)
{ d_do E_message_n "$@" >&2 ; }
# @usage dE_message_n "message string" <level>


d_log_message_n()     # (POSIX) display and log message IAW verbosity (w/o CR)
{ d_do log_message_n "$@" >&2 ; }
# @usage d_log_message_n "message string" <level>



d_log_E_message_n() # (POSIX) display and log error message IAW verbosity (w/o CR)
{ d_do log_E_message_n "$@" >&2 ; }
# @usage d_log_E_message_n "message string" <level>

d_echo_n() # (POSIX) IAW verbosity, display text debugging message $@ (like echo -n)
{ d_do echo -n "$@" >&2 ; }
# @usage d_echo_n "message string" <level>

de_echo_n()   # (POSIX) IAW verbosity, display text debugging message $@ (like echo -en)
{ d_do echo -e -n "$@" >&2 ; }
# @usage d_echo_n "message string" <level>

#~~~~~[ debuggimg w logging ]~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

d_log_echo_n()      # (POSIX) display and log simple message IAW verbosity (like echo -n)
{ d_do log_echo_n "$@" >&2 ; }
# @usage d_log_echo_n "message string" <level>

d_log_echo_e_n()    # (POSIX) display and log simple message IAW verbosity (like echo -en)
{ d_do log_echo_e_n "$@" >&2 ; }
# @usage d_log_echo_e_n "message string" <level>

log_echo_n() # (POSIX) echo -n "$1" to stdout and $logFile owned by $user (like echo -n)
{ log_en_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  printf "%s" "$*"
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_en_ret
}
# @usage log_echo_n "msg string"
# @args $* the message string
# @deps timestamp _translate_escapes strip_ansi
# @rule outputs string without newline; sanitizes for log file storage
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%s' (no expand backslash) to interpret e.g. \n in message (like echo)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

log_echo_e_n() # (POSIX) echo -e -n "$1" to stdout and $logFile owned by $user (like echo -e -n)
{ log_een_ret=0
  # guard - ensure log is writable by current user
  [ ! -w "$logFile" ] && { E_message "Error: logFile is not writable"; return 1 ; }
  _ts="$(timestamp)"  # set timestamp for log entry
  printf "%b" "$*"
  _clean_msg=$(printf '%s' "$*" | _translate_escapes | strip_ansi)
  printf "%s - %s" "$_ts" "$_clean_msg" >> "$logFile"
  unset -v _ts _clean_msg
  return $log_een_ret
}
# @usage log_echo_e_n "msg string"
# @args $* string with escape sequences
# @deps timestamp _translate_escapes strip_ansi
# @rule interprets escapes via %b and suppresses trailing newline in both outputs
# @note use "$*" to bind message as a single string (no word-split)
# @note for stdout, message() uses '%b' (expand backslash) to interpret e.g. \n in message (like echo -e)
# @note for logFile, use '%s' since piping through | _translate_escapes | strip_ansi to _clean_msg
# @note use '%s' for timestamp

