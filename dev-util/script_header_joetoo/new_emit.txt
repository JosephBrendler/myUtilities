# @note =====[ Section 6: Logging/Messaging & UI/Layout Framework ]==================================================================

# @note -----[ Section 6.a.: Logging/Messaging Engine/Protocol ]--------------------------------------------------------------

# @note Messaging/Logging = semantic meaning + severity + destination
# @note joetoo consolidated logging/messaging protocol uses a bitmask
# @cont to enable calling functions to provide all relevant information
# @cont in a single positional parameter $1; after it is injested and
# @cont the bits are extracted, $1 can be discarded, and the remainder
# @cont of $@ is the payload to be emitted
#
# @note single-bit flags for boolean behaviors (orthogonal, expressive, and easy to combine)
# @note bit(s)
# @note [0]      STDOUT        - emit to stdout
# @note [1]      STDERR         - mirror (or redirect?) output to stderr
# @note [2]      LOG          - output to a file
# @note [3]      INTERPRET      - use '%b' to INTERPRET backslash escape codes
# @note [4]      NEWLINE        - append a newline at the end of the message
# @note [5]      TIMESTAMP      - prepend a timestamp (on log messages)
# @note [6]      CONDITIONAL    - respect verbosity IAW severity
# @note [7]      FORCE          - force print regardless of verbosity
# @note [8]      SILENCE        - suppress output, regardless of severity, and even if force is set
# @note NOTE: FORCE and SILENCE ara part of a POLICY layer,
# @note  ( not part of the severyity/verbosity [CONDITIONAL] system;
# @note    FORCE overrides severity/verbosity [CONDITIONAL] rules,
# @note    as does SILENCE, which also overrides even FORCE)
# @note  ( Override priority: SILENCE > FORCE > CONDITIONAL > unconditional )
# @note [6-8] 8:SILENCE; 7:FORCE; 6:CONDITIONAL
# @note   000       unconditional print (no verbosity logic)
# @note   100       conditional print (respect verbosity)
# @note   010       forced print (ignore verbosity)
# @note   110       severity labeling + forced print
# @note   *01       always suppress (even if FORCE is set)
# @note [9-14]   RESERVED (future)
# @note [15]     PREFIX         - single-bit flag to turn on prefix
# @note [16]     PREFIX_BOLD    - intensity
# @note [17-19]  PREFIX_COLOR   - (3 bit RGB)(11:R, 10:G, 9:B)
# @note   000 (0)   black is the normal definition, but here this means severity-implied color will be applied
# @note   001 (1)   blue
# @note   010 (2)   green
# @note   011 (3)   cyan
# @note   100 (4)   red
# @note   101 (5)   magenta
# @note   110 (6)   yellow
# @note   111 (7)   white
# @note [20-23]  RESERVED (future)
# @note [24-26]  SEVERITY (3 bits)
# @note   000 (0)   emerg
# @note   001 (1)   alert
# @note   010 (2)   crit
# @note   011 (3)   err
# @note   100 (4)   warning
# @note   101 (5)   notice
# @note   110 (6)   info
# @note   111 (7)   debug
# @note [26-30]  RESERVED (future)
# @note [31]     DO NOT USE (sign bit)
#
# @note Define global constants to facilitate bitmask setting by calling functions
# @note STDOUT=1 ............... 1 << 0 (no shift required)
# @note STDERR=2 ............... 1 << 1
# @note LOG=4 .................. 1 << 2 (shift a "1" bit 2 positions left (more significant)
# @note INTERPRET=8 ............ 1 << 3
# @note NEWLINE=16 ............. 1 << 4
# @note TIMESTAMP=32 ........... 1 << 5
# @note CONDITIONAL=64 ......... 1 << 6
# @note FORCE=128 .............. 1 << 7
# @note SILENCE=256 ............ 1 << 8
# @note PREFIX=32768 ........... 1 << 15
# @note PREFIX_BOLD=65536 ...... 1 << 16
# @note PREFIX_COLOR_SHIFT=17 .. 3-bit field starts at bit 17
# @note SEVERITY_SHIFT=24 ...... 3-bit field starts at bit 24
#
STDOUT=1
STDERR=2
LOG=4
INTERPRET=8
NEWLINE=16
TIMESTAMP=32
CONDITIONAL=64
FORCE=128
SILENCE=256
PREFIX=32768
PREFIX_BOLD=65536
PREFIX_COLOR_SHIFT=17
SEVERITY_SHIFT=24
#
# These global constant values are used to facilitate setting of the bitmask by calling functions.  This essentially
# makes the api "self documenting" while this is integer math, it is usefull to think of each of these as a single-bit
# binary number, 1 or 0, shifted into its bit-position to attain the value above.
# Note that the assignment SILENCE=0; SILENCE=256 is equivalent to SILENCE=0; SILENCE$(( SILENCE | ( 1 << 8 ) ))
#
# to avoid confusion, the names applied inside the function are prefixed with '_' to inidcate their local scope
# THESE local-scoped variables *ARE *ACTUAL* BOOLEAN values, in which 1=true; 0=false, and as such they cannot be
# directly tested --> [ "$CONDITIONAL" ] does NOT work , it MUST be done like this [ "$CONDITIONAL" -eq 1 ]
#
#DO NOT CONFUSE these with joetoo's pseudo-boolean type only ever assigned one of TRUE=0, FALSE=""
# so that they CAN be directly tested like FLAGGED=$TRUE; [ $FLAGGED ] will always behave as expected

emit() # (POSIX) consolidated messaging engine in a subshell to isolates positional parameters
( emit_ret=0; mask=$1; shift  # first positiona parameter is the bitmask
  _PRINT_OK="$TRUE"; _LOG_OK="$TRUE"  # default actions
  # extract boolean flags using bitwise shift, AND to read the nth most significant bit
  # this is the value extracted from the bit location(s) pointed to by the glogals of similar name above
  _STDOUT=$((          mask         & 1 ))
  _STDERR=$((        ( mask >> 1 )  & 1 ))
  _LOG=$((           ( mask >> 2 )  & 1 ))
  _INTERPRET=$((     ( mask >> 3 )  & 1 ))
  _NEWLINE=$((       ( mask >> 4 )  & 1 ))
  _TIMESTAMP=$((     ( mask >> 5 )  & 1 ))
  _CONDITIONAL=$((   ( mask >> 6 )  & 1 ))
  _FORCE=$((         ( mask >> 7 )  & 1 ))
  _SILENCE=$((       ( mask >> 8 )  & 1 ))
  _PREFIX=$((        ( mask >> 15 ) & 1 ))
  _PREFIX_BOLD=$((   ( mask >> 16 ) & 1 ))
  _PREFIX_COLOR=$((  ( mask >> 17 ) & 7 ))       # 3-bit field 7 = 0b111 but 0b format is not POSIX
  _SEVERITY=$((      ( mask >> 24 ) & 7 ))       # 3-bit field 7 = 0b111 but 0b format is not POSIX
#  d_do '
#    echo "_STDOUT: $_STDOUT"
#    echo "_STDERR: $_STDERR"
#    echo "_LOG: $_LOG"
#    echo "_INTERPRET: $_INTERPRET"
#    echo "_NEWLINE: $_NEWLINE"
#    echo "_TIMESTAMP: $_TIMESTAMP"
#    echo "_CONDITIONAL: $_CONDITIONAL"
#    echo "_FORCE: $_FORCE"
#    echo "_SILENCE: $_SILENCE"
#    echo "_PREFIX: $_PREFIX"
#    echo "_PREFIX_BOLD: $_PREFIX_BOLD"
#    echo "_PREFIX_COLOR: $_PREFIX_COLOR"
#    echo "_SEVERITY: $_SEVERITY"
#  ' "$debug"

  # explicitly disable logging if _LOG bit is not set
  if [ "$_LOG" -eq 0 ]; then _LOG_OK="$FALSE"; fi

  # if _SILENCE bit was set (QUIET is true) and not overridden by INTERACTIVE, then turn off printing (but not logging)
  if [ "$_SILENCE" -eq 1 ] && [ ! "$INTERACTIVE" ]; then _PRINT_OK="$FALSE"; fi

  # apply verbosity and loglevel rules according to policy
  if [ "$_CONDITIONAL" -eq 1 ]; then
    # compare global verbosity to this message's severity (lower severity number = more important)
    if [ "$_FORCE" -eq 0 ] && [ "$verbosity" -lt "$_SEVERITY" ]; then _PRINT_OK="$FALSE"; fi
    # compare global loglevel to this message'sseverity (lower severity number = more important)
    if [ "$loglevel" -lt "$_SEVERITY" ]; then _LOG_OK="$FALSE"; fi
  fi

  # early exit if _LOG is requested but logFile is not writable
  if [ "$_LOG" -eq 1 ] && [ ! -w "$logFile" ]; then error_msg  "Error: logFile is not writable"; exit 1 ; fi

  # non-zero bold/color value means prefix, yes
  # determine prefix color (severity-implied or user override)
  if [ "$_PREFIX_COLOR" -eq 0 ]; then
    # no explicit color provided by caller; so derive it from severity
    case "$_SEVERITY" in
      0|1|2|3) prefix_color="${BRon}"  ;;   # emerg/alert/crit/err .. (red bold)
      4)       prefix_color="${BYon}"  ;;   # warning ............... (yellow bold)
#      5|6)     prefix_color="${Won}"   ;;   # notice/info ........... (white)
      5)       prefix_color="${Gon}"   ;;   # notice ................ (green - joetoo std good to know, normal ops)
      6)       prefix_color="${BGon}"  ;;   # info .................. (green bold - joetoo std need to know, normal ops)
#      7)       prefix_color="${Con}"   ;;   # debug ................. (cyan)
      7)       prefix_color="${BMon}"  ;;   # debug ................. (magenta bold - joetoo std debug)
    esac
  else
    # caller-specified prefix color
    case "$_PREFIX_COLOR" in
      1) prefix_color="${Bon}"  ;; # blue
      2) prefix_color="${Gon}"  ;; # green
      3) prefix_color="${Con}"  ;; # cyan
      4) prefix_color="${Ron}"  ;; # red
      5) prefix_color="${Mon}"  ;; # magenta
      6) prefix_color="${Yon}"  ;; # yellow
      7) prefix_color="${Won}"  ;; # white
      *) prefix_color=""        ;; # invalid explicit color (no prefix color)
    esac
  fi
  # If _PREFIX=1, keep prefix_color and optionally add bold; if _PREFIX=0, disable prefix_color entirely
  if [ "$_PREFIX" -eq 1 ]; then
    if [ "$_PREFIX_BOLD" -eq 1 ]; then
      prefix_color="${prefix_color%?};${BOLD}m"
    fi
  else
    prefix_color=""
  fi
  # build timestamp (if enabled)
  if [ "$_TIMESTAMP" -eq 1 ]; then ts="$(timestamp)"; else ts=""; fi
  # build prefix symbol (note that space on right is separation from msg
  # (also note that each is precisely 3 char - for predictable spacing)
  case "$_SEVERITY" in
    0|1|2|3) prefix_symbol="!! " ;; # high severity
    4)       prefix_symbol=" ! " ;;
    5|6)     prefix_symbol=" * " ;; # "normal"
    7)       prefix_symbol=" - " ;; # debug
  esac
#    d_do '
#        echo "Prior to _PREFIX - _LOG - _SEVERITY block"
#        echo "_PREFIX......: [$_PREFIX]"
#        echo "_LOG.........: [$_LOG]"
#        echo "_SEVERITY....: [$_SEVERITY]"
#        severity_mark=$(get_severity "$_SEVERITY")
#        echo "severity_mark: $severity_mark"
#        echo "log_prefix...: $log_prefix"
#    ' "$debug"
    # build prefix symbol (null prefix if color=black) (for logging, append severity marking)
  if [ "$_PREFIX" -eq 1 ]; then
    prefix="${prefix_color}${prefix_symbol}${Boff}"
    if [ "$_LOG" -eq 1 ]; then
      # trim spaces and append severity mark only for clean version of prefix to be used for logging
      #   remove leading spaces
      junk="${prefix_symbol%%[! ]*}"; log_prefix="${prefix_symbol#"$junk"}"
      #   remove trailing spaces
      junk="${log_prefix##*[! ]}"; log_prefix="${log_prefix%"$junk"}"
      #   get severity mark
      severity_mark=$(get_severity "$_SEVERITY")
      #   assemble ansi-free clean prefix for logging
      log_prefix="[${log_prefix}] (${severity_mark})"
    fi
  else
    prefix=""; log_prefix=""
  fi
#    d_do '
#        echo "After _PREFIX - _LOG - _SEVERITY block"
#        echo "_PREFIX......: [$_PREFIX]"
#        echo "_LOG.........: [$_LOG]"
#        echo "_SEVERITY....: [$_SEVERITY]"
#        severity_mark=$(get_severity "$_SEVERITY")
#        echo "severity_mark: $severity_mark"
#        echo "log_prefix...: $log_prefix"
#    ' "$debug"
  # prepend timestamp (for LOG only) and space only if there actaully is content in ts
  if [ ! -z "$ts" ]; then log_prefix="${ts} ${log_prefix}"; fi
  # build the message body
  msg="$*"  # all remaining positional parameters, after bitmask was shifted
  # build the full output string
  out="${prefix}${msg}"
  log_out=$(printf '%s' "${log_prefix} ${msg}" | strip_ansi | _translate_escapes)
  # choose printf format based on _INTERPRET
  if [ "$_INTERPRET" -eq 1 ]; then fmt='%b'; else fmt='%s'; fi

  # emit to stdout (if _STDOUT), with _NEWLINE, if selected and enabled
  if [ "$_PRINT_OK" ] && [ "$_STDOUT" -eq 1 ]; then
    if [ "$_NEWLINE" -eq 1 ]; then out_fmt="$fmt\n"; else out_fmt="$fmt"; fi
    printf "$out_fmt" "$out"
  fi

  # mirror to stderr (if _STDERR) if enabled
  if [ "$_PRINT_OK" ] && [ "$_STDERR" -eq 1 ]; then
    if [ "$_NEWLINE" -eq 1 ]; then out_fmt="$fmt\n"; else out_fmt="$fmt"; fi
    printf "$out_fmt" "$out" >&2
  fi

  # log to file (if _LOG)
  if [ "$_LOG_OK" ] && [ "$_LOG" -eq 1 ]; then
    if [ "$_NEWLINE" -eq 1 ]; then out_fmt='%s\n'; else out_fmt='%s'; fi
    printf "$out_fmt" "$log_out" >> "$logFile"
  fi

  # emit() body is a subshell, so not doing unset -v (all will be discarded on exit)
)
# @usage emit <bitmask> "message text"
# @args  $1: bitmask selecting stdout/stderr/log, prefix, severity, policy bits
# @args  $*: message string (all remaining args)
# @vars  logFile, verbosity, loglevel, INTERACTIVE; bitmask constants STDOUT..SEVERITY_SHIFT
# @ret   prints and/or logs formatted message; honors severity and policy bits
# @ret   always returns 0 on successful print or suppression (design contract)
# @deps  timestamp(), strip_ansi(), _translate_escapes(), get_severity()
# @rule  PRINT and LOG decisions are made independently:
# @rule    _PRINT_OK defaults to $TRUE; suppressed by _SILENCE or verbosity rules
# @rule    _LOG_OK defaults to $TRUE; suppressed by missing LOG bit or loglevel rules
# @rule  POLICY OVERRIDE ORDER (highest->lowest):
# @rule    _SILENCE  suppresses PRINT regardless of FORCE or severity
# @rule    _FORCE    bypasses PRINT verbosity checks (but not loglevel)
# @rule    _CONDITIONAL â   enables severity filtering for PRINT and LOG
# @rule    (unconditional) âalways prints/logs (severity ignored)
# @rule  $QUIET sets _SILENCE in caller; $INTERACTIVE overrides $QUIET (_SILENCE) for PRINT only
# @rule  $DEBUG sets _FORCE in caller; _FORCE affects PRINT only (not $loglevel)
# @rule  $verbosity controls PRINT suppression for _CONDITIONAL messages
# @rule  loglevel   controls LOG   suppression for _CONDITIONAL messages
# @rule  unconditional messages (e.g. echo_mdg) bypass both $verbosity and $loglevel checks
# @rule  _STDOUT/_STDERR select output streams; _NEWLINE appends '\n'
# @rule  _LOG writes ANSI-stripped, escape-normalized text to logFile
# @rule  _TIMESTAMP applies only to log output
# @rule  _PREFIX enables prefix_symbol with severity-implied or caller-specified color
# @rule  _PREFIX_COLOR=0 uses severity color; nonzero overrides; _PREFIX_BOLD adds intensity
# @rule  _SEVERITY (3 bits) controls prefix symbol, color, and filtering behavior
# @note  emit() runs in a subshell to isolate positional parameters and avoid
# @cont  polluting caller scope; all local _FLAG vars are true booleans (1/0)
# @note  PRINT and LOG suppression are independent; suppression is not an error
# @note  callers must construct bitmask correctly; emit() does not validate it
# @note  $QUIET (_SILENSE) suppresses PRINT only; logging remains active unless $loglevel blocks it
# @note  $DEBUG (_FORCE) bypasses PRINT $verbosity but never bypasses loglevel
# @note  unconditional messages (no _CONDITIONAL bit) always print/log unless SILENCE
# @ex    emit "$((STDOUT|NEWLINE|PREFIX|CONDITIONAL|(info<<SEVERITY_SHIFT)))" "$_msg"
