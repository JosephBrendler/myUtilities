#!/bin/bash
source /usr/sbin/script_header_joetoo
VERBOSE=$TRUE
verbosity=3
PRETEND=$TRUE
FLAGGED=$FALSE

varlist="PN BPN BUILD"
varlist+=" BREAK configfile target_folder target_line_text insert_file before_after BREAK lv.target_file_list"
varlist+=" BREAK user group BREAK bool.VERBOSE verbosity bool.PRETEND"

#-----[ functions ]-----------------------------------------------------
initialize_variables() {
    d_message "initializing variables" 2
    myverbosity=$verbosity; myPRETEND=$PRETEND
    initialize_vars ${varlist}

    #reinitialize VERBOSE and verbosity as above
    FLAGGED=$FALSE
    message_n "re-initializing verbosity ... [ ${myverbosity} ]"
    export verbosity=$myverbosity ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "re-initializing VERBOSE ..."
    [ ${verbosity} -gt 0 ] && export VERBOSE=$TRUE || export VERBOSE=$FALSE
    right_status $?
    debug_do 'echo -en " $(status_color ${VERBOSE})$(TrueFalse ${VERBOSE})${Boff}"' 3

    message_n "re-initializing PRETEND ..."
    export PRETEND=$myPRETEND ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result
    debug_do 'echo -en " $(status_color ${PRETEND})$(TrueFalse ${PRETEND})${Boff}"' 3

    message_n "assigning configfile ..."
    export configfile="/etc/${PN}/${PN}.conf ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "initializing bash array for output ..."
    export output=() ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    [ $FLAGGED ] && return 1 || return 0
}

read_config() {
    echo
    message_n "Reading config ..."
    if [ -e ${configfile} ] ; then
        echo -n " [ ${configfile} ]"
        source ${configfile} || die "failed to source ${configfile}"
        right_status $TRUE
    else
        echo -en " (${BRon}not found${Boff})"
        right_status 1
        usage
    fi
    return 0
}

display_config() {
  echo
  message "${BYon}Current Configuration --${Boff}"
  longest=$(get_longest ${varlist})
  display_vars ${longest} ${varlist}
  echo
  return 0
}

do_insert() {
    d_message " running do_insert with input from [ ${insert_file} ]" 4
    insert_file="${1}"
    while read linein
    do
#      if [ ! -z "${linein}" ] ; then
        d_message "  inserting [ ${linein} ]" 4
        output+=("${linein}")
#      fi
    done < ${insert_file}
    return 0
}

read_input_and_edit_output() {
    # read input from file specified in arg1
    in_file="$1"
    while read line
    do
        # if line is not null and it matches tartet text, then insert before/after
        if [ ! -z "${line}" ] && [ "${line}" == "${target_line_text}" ] ; then
            d_message "this is target target line; inserting ${before_after}" 4
            case ${before_after} in
                "before" )
                    d_message "adding insert to output array" 4
                    do_insert "${insert_file}"
                    d_message "adding original line [ ${line} ] to output array" 4
                    output+=("$(echo "${line}")")
                  ;;
                "after"  )
                    d_message "adding original line [ ${line} ] to output array" 4
                    output+=("$(echo "${line}")")
                    d_message "adding insert to output array" 4
                    do_insert "${insert_file}"
                  ;;
                *        ) E_message "invalid before_after [ ${before_after}]"; usage;;
            esac
        else
            # this is not the target line, so just add it back into the output array
            d_message "adding line [ ${line} ] to output array" 4
            output+=("$(echo "${line}")")
        fi
    done < ${in_file}
    return 0
}

sanity_check() {
    # sanity check explanations
    [ $# -gt 1 ] && E_message "too many arguments [$#]" && usage
    [ ${#user} -eq 0 ] && E_message "user: [ ${user} ] null" && usage
    [ ${#group} -eq 0 ] && E_message "group: [ ${group} ] null" && usage
    [ ${#user} -gt 0 ] && [[ ! $(grep ${user} /etc/shadow) ]] && E_message "user: [ ${user} ] not found" && usage
    [ ${#group} -gt 0 ] && [[ ! $(grep ${group} /etc/gshadow) ]] && E_message "group: [ ${group} ] not found" && usage
    [ ! -e ${target_folder} ] && E_message "target_folder [ ${target_folder} ] does not exist" && usage
    [ ! -e ${insert_file} ] && E_message "insert_file [ ${insert_file} ] does not exist" && usage
    [ ${#target_file_list} -eq 0 ] && E_message "target_file_list [ ${target_file_list} ] null" && usage
    [ ${#target_line_text} -eq 0 ] && E_message "target_line_text [ ${target_line_text} ] null" && usage
    return 0
}

dump_output() {
    for ((i=0; i<${#output[@]}; i++)) ; do
        echo "$i: ${output[$i]}"
    done
    return 0
}

write_output() {
    out_file="${1}"
    message_n "writing output to ${out_file} ..."
    echo "" > ${out_file}
    for ((i=0; i<=${#output[@]}; i++))
    do
        echo "${output[i]}" >> ${out_file}
    done ; right_status $?
    message_n "setting ownership with chown ${user}:${group} ${out_file} ..."
    chown ${user}:${group} ${out_file} ; right_status $?
}

#-----[ main script ]--------------------------------------------------
echo
separator "${PN}-${BUILD}" $(hostname)
checkroot
initialize_variables || die "failed initialize_variables"
read_config || die "failed read_config"

#process command line to override config
process_cmdline $@

sanity_check || die "failed sanity_check"
display_config || die "failed display_config"

for filename in ${target_folder%/}/${target_file_list}
do
    # reinitialize output array
    output=()
    separator ${filename} ${PN}
    target_file="${filename}"
    d_message "target_file: [ ${target_file} ]" 2
    read_input_and_edit_output "${target_file}"
    d_do dump_output 3
    if [ ! ${PRETEND} ] ; then
        # do it for real
        write_output "${target_file}"
        # if the first line is now blank, remove it
        while [ -z "$(head -n 1 $target_file)" ]; do sed -i '1{/^$/d}' $target_file ; done
        # if the last line is now blank, remove it
        while [ -z "$(tail -n 1 $filename)" ]; do sed -i '${/^[[:space:]]*$/d;}' $filename ; done
    else
        message "PRETEND -- did not write output"
    fi
done
