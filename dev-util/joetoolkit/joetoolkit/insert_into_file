#!/bin/bash
source /usr/sbin/script_header_joetoo
VERBOSE=$TRUE
verbosity=3
PRETEND=$TRUE
FLAGGED=$FALSE

varlist="PN BPN BUILD starting_step stopping_step cmdseq_statusfile bool.VERBOSE verbosity bool.INTERACTIVE bool.PRETEND"
varlist+=" BREAK configfile target_folder target_line_text insert_file before_after BREAK lv.target_file_list"
varlist+=" BREAK user group"

command_sequence=(
'batch_edit_target_files'
)

msg1_sequence=(
'batch edit target files'
)

#-----[ functions ]-----------------------------------------------------
initialize_variables() {
    d_message "initializing variables" 2
    myverbosity=$verbosity; myPRETEND=$PRETEND
    initialize_vars ${varlist}

    #reinitialize VERBOSE and verbosity as above
    FLAGGED=$FALSE
    message_n "assigning PN = $(basename $0) "
    export PN=$(basename $0) ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "sourcing BUILD"
    source /etc/${PN}/BUILD ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "sourcing BPN"
    source /etc/${PN}/BPN ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "sourcing script_header_joetoo_extended"
    source /usr/sbin/script_header_joetoo_extended ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "re-initializing verbosity ... [ ${myverbosity} ]"
    export verbosity=$myverbosity ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "re-initializing VERBOSE ..."
    [ ${verbosity} -gt 0 ] && export VERBOSE=$TRUE || export VERBOSE=$FALSE
    right_status $?
    debug_do 'echo -en " $(status_color ${VERBOSE})$(TrueFalse ${VERBOSE})${Boff}"' 3

    message_n "re-initializing PRETEND ..."
    export PRETEND=$myPRETEND ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result
    debug_do 'echo -en " $(status_color ${PRETEND})$(TrueFalse ${PRETEND})${Boff}"' 3

    message_n "re-initializing INTERACTIVE ..."
    export INTERACTIVE=$FALSE ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result
    debug_do 'echo -en " $(status_color ${INTERACTIVE})$(TrueFalse ${INTERACTIVE})${Boff}"' 3

    message_n "re-initializing starting_step = 0 ..."
    export starting_step=0 ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "re-initializing stopping_step = $((${#command_sequence[@]} - 1)) ..."
    export stopping_step=$((${#command_sequence[@]} - 1)) ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "assigning configfile ..."
    export configfile="/etc/${PN}/${PN}.conf" ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "assigning cmdseq_statusfile = ${PN}_statusfile ..."
    export cmdseq_statusfile="${PN}_statusfile" ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    message_n "initializing bash array for output ..."
    export output=() ; result=$?
    [ ! $result -eq 0 ] && FLAGGED=$TRUE
    right_status $result

    [ $FLAGGED ] && return 1 || return 0
}

read_config() {
    echo
    d_message "configfile: $configfile" 3
    message_n "Reading config ..."
    if [ -e ${configfile} ] ; then
        echo -n " [ ${configfile} ]"
        source ${configfile} || die "failed to source ${configfile}"
        right_status $TRUE
    else
        echo -en " (${BRon}not found${Boff})"
        right_status 1
        usage
    fi
    return 0
}

display_config() {
  echo
  message "${BYon}Current Configuration --${Boff}"
  longest=$(get_longest ${varlist})
  display_vars ${longest} ${varlist}
  echo
  separator "${BYon}Content of insert_file [${insert_file}]" "(below)"
  cat ${insert_file}
  separator "${BYon}Content of insert_file [${insert_file}]" "(above)"
  echo
  return 0
}

do_insert() {
    d_message " running do_insert with input from [ ${insert_file} ]" 4
    insert_file="${1}"
    while read linein
    do
#      if [ ! -z "${linein}" ] ; then
        d_message "  inserting [ ${linein} ]" 4
        output+=("${linein}")
#      fi
    done < ${insert_file}
    return 0
}

read_input_and_edit_output() {
    # read input from file specified in arg1
    in_file="$1"
    while read line
    do
        # if line is not null and it matches tartet text, then insert before/after
        if [ ! -z "${line}" ] && [ "${line}" == "${target_line_text}" ] ; then
            d_message "this is target target line; inserting ${before_after}" 4
            case ${before_after} in
                "before" )
                    d_message "adding insert to output array" 4
                    do_insert "${insert_file}"
                    d_message "adding original line [ ${line} ] to output array" 4
                    output+=("$(echo "${line}")")
                  ;;
                "after"  )
                    d_message "adding original line [ ${line} ] to output array" 4
                    output+=("$(echo "${line}")")
                    d_message "adding insert to output array" 4
                    do_insert "${insert_file}"
                  ;;
                *        ) E_message "invalid before_after [ ${before_after}]"; usage;;
            esac
        else
            # this is not the target line, so just add it back into the output array
            d_message "adding line [ ${line} ] to output array" 4
            output+=("$(echo "${line}")")
        fi
    done < ${in_file}
    return 0
}

sanity_check() {
    # sanity check explanations
    [ $# -gt 1 ] && E_message "too many arguments [$#]" && usage
    [ ${#user} -eq 0 ] && E_message "user: [ ${user} ] null" && usage
    [ ${#group} -eq 0 ] && E_message "group: [ ${group} ] null" && usage
    [ ${#user} -gt 0 ] && [[ ! $(grep ${user} /etc/shadow) ]] && E_message "user: [ ${user} ] not found" && usage
    [ ${#group} -gt 0 ] && [[ ! $(grep ${group} /etc/gshadow) ]] && E_message "group: [ ${group} ] not found" && usage
    [ ! -e ${target_folder} ] && E_message "target_folder [ ${target_folder} ] does not exist" && usage
    [ ! -e ${insert_file} ] && E_message "insert_file [ ${insert_file} ] does not exist" && usage
    [ ${#target_file_list} -eq 0 ] && E_message "target_file_list [ ${target_file_list} ] null" && usage
    [ ${#target_line_text} -eq 0 ] && E_message "target_line_text [ ${target_line_text} ] null" && usage
    [ ! -L /etc/${PN}/${PN}.conf ] && E_message "${PN}.conf symlink does not exist. Run eselect ${PN} list/set" && usage
    return 0
}

dump_output() {
    for ((i=0; i<${#output[@]}; i++)) ; do
        echo "$i: ${output[$i]}"
    done
    return 0
}

write_output() {
    out_file="${1}"
    message_n "writing output to ${out_file} ..."
    echo "" > ${out_file}
    for ((i=0; i<=${#output[@]}; i++))
    do
        echo "${output[i]}" >> ${out_file}
    done ; right_status $?
    message_n "setting ownership with chown ${user}:${group} ${out_file} ..."
    chown ${user}:${group} ${out_file} ; right_status $?
}

batch_edit_target_files() {
    for filename in $(find ${target_folder%/}/ -name "${target_file_list}") ; do
        # reinitialize output array
        output=()
        separator ${filename} ${PN}
        target_file="${filename}"
        d_message "target_file: [ ${target_file} ]" 2
        read_input_and_edit_output "${target_file}"
        d_do dump_output 3
        if [ ! ${PRETEND} ] ; then
            # do it for real
            write_output "${target_file}"
            # if the first line is now blank, remove it
            while [ -z "$(head -n 1 $target_file)" ]; do sed -i '1{/^$/d}' $target_file ; done
            # if the last line is now blank, remove it
            while [ -z "$(tail -n 1 $filename)" ]; do sed -i '${/^[[:space:]]*$/d;}' $filename ; done
        else
            message "${BRon}PRETEND${Boff} -- ${BYon}did not write output${Boff}"
        fi
    done
}

#-----[ main script ]--------------------------------------------------
echo
separator "${PN}-${BUILD}" $(hostname)
checkroot
initialize_variables || die "failed initialize_variables"
validate_status_file ${cmdseq_statusfile} || die "failed validate_status_file"
read_config || die "failed read_config"

#process command line to override config
process_cmdline $@

sanity_check || die "failed sanity_check"
display_config || die "failed display_config"
confirm_continue_or_exit

# ok - now actually do it
run_sequence ${cmdseq_statusfile} || die "failed run_sequence"
message "${BMon}${PN}${BGon} completed successfully${Boff}"
echo
exit 0
