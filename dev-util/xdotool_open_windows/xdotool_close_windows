#!/bin/bash
# xdotool_close_windows  -- joe brendler (c) 2014-3599
# Notes:
# (1) Use legit bash assignments only. this file will be sourced by the scripts.
# (2) See sections for geometry, filesystem, timing, and ssh sessions.
# (3) A key purpose is to populate the list of ssh sessions to be opened by the script.
# (4) If an ${ssh_session_list[@]} entry begins with the characters "x_" it will be ignored
# (5) The _open_ script will set up to two ssh-terminal windows per desktop
# (6) The -open_ script will determine the number of desktops needed (but always even #)
# (7) The example array assignment below thus has two hostnames per line for readability
#

### to-do:
### (1) enable higher number up to four (quaarter-tiled) windows per desktop
###     (keep the convention of same number on the line of assignment)
### (2) use tigervnc/remina to open vnc/ssh if line has v_<name> (ssh if s_<name>)
###   + example open cmd: vncviewer -Fullcolor -QualityLevel 9 -via joe@${ssh_target} localhost:2

source /usr/sbin/script_header_joetoo

PN=$(basename $0)

#=====[ user variable defaults (override in config_file) ]==============================

#-----[ User ]--------------------------------------------------------------------------
user=joe

#-----[ Geometry ]----------------------------------------------------------------------
# window size and locationfor two terminal windows "L" and "R"
# positioned horizontally at X1, X2 respectively, both vertically at Y1
# (this default leaves 12% visible on the right, for widgets or whatever)
width="43%"      # terminal window width as a percent of screen width
height="85%"     # terminal window height as a percent of screen height
X1="1%"          # left horizontal edge position of left window as a percent of screen width
Y1="5%"          # vertical position of both terminals as a percent of screen height
X2="45%"         # left horizontal edge position of right window as a percent of screen width

#-----[ Filesystem ]--------------------------------------------------------------------
config_dir="/etc/xdotool_open_windows"
config_file="${config_dir%/}/xdotool_open_windows.conf"
build_file=$"${config_dir%/}/BUILD"
#log_dir="/home/${user}"
#old_log_dir="/home/${user}"
log_dir="/var/log"
old_log_dir="/var/log/old_logs"
logFile="${log_dir%/}/xdotool_open_windows.log"

#-----[ Terminal Program ]--------------------------------------------------------------
terminal_program="/usr/bin/konsole"       # default
#terminal_program="/usr/bin/lxterminal"
#terminal_program="/usr/bin/xterm"

#-----[ Timing ]------------------------------------------------------------------------
# customized timing and detailed output (override in config_file)(increase for debugging)
sleepWait=0.5    # help avoid race conditions
longWait=2       # help avoid race conditions
timeout=10       # seconds to wait while trying to close a window or identify a new one

typeWait=1.5

#-----[ Debug Verbosity ]---------------------------------------------------------------
#VERBOSE=$FALSE
VERBOSE=$TRUE
# set verbosity only if not already set (allow calling program to do so)
[ -z $verbosity ] && verbosity=4

message_n "sourcing build_file: ${build_file} ..."
[[ -f ${build_file} ]] || die "${build_file} does not exist"
source ${build_file} || die "failed to source ${build_file}"
right_status $?

message_n "sourcing config_file: ${config_file} ..."
[[ -f ${config_file} ]] || die "${config_file} does not exist"
source ${config_file} || die "failed to source ${config_file}"
right_status $?

# over-ride the open_windows config on this one (for now)
logFile="${log_dir%/}/xdotool_close_windows.log"

# to do: rotate log file like in open_windows
sudo rm $logFile

#-----[ functions ]-------------------------------------------------

kill_pids() {
    # kill processes identified by ${filter}
    pids=($(eval "ps -aef | ${filter} | awk '{print \$2}'"))
    filter_name="$(echo ${filter} | awk '{print $2}')"
    if [[ -z "${pids[@]}" ]] ; then
         message "Found [${#pids[@]}] processes for filter [${filter_name}]"
    else
        elapsed=0
        round=1
        while [[ ! -z "${pids[@]}" && $elapsed -le $timeout ]] ; do
             message "Found [${#pids[@]}] processes for filter [${filter_name}]..."
            for x in ${pids[@]}
            do
                message "(${round}) ${BRon}killing${Boff} process x: [$BMon}${x}${Boff}] for filter [${BYon}${filter_name}${Boff}]"
                kill -9 $x 2>/dev/null
                # To Do: get and handle result (exit/return status)
            done # for
            sleep $longWait
            elapsed=$(( $elapsed + $longWait ))
            round+=1
            pids=($(eval "ps -aef | ${filter} | awk '{print \$2}'"))
        done # while
        x=""
    fi # -z pids
    return 0
}

close_windows() {
    my_window=$(xdotool getactivewindow)
    message "my_window: ${my_window}"
    # identify all terminal windows (use --any but not --onlyvisible to get minimized, too)
    window_list=()
    window_list=($(xdotool search --any lxterminal 2>/dev/null))
    window_list+=($(xdotool search --any Konsole))
    window_list+=($(xdotool search --any xterm 2>/dev/null))
    message "Currently tracking [${#window_list[@]}] terminal windows"
    d_message "Current window list:" 3
    d_echo ${window_list[@]} 3 ; d_echo "" 3
    message "Now closing all terminal windows except my_window [${my_window}] ..."
    # close all these windows
    for win in $(for x in ${window_list[@]}; do echo $x; done | sort -n)
    do
        desktop=$(xdotool get_desktop_for_window $win 2>/dev/null)
        message_n "Examining window [ $win ] on desktop [ $desktop ] ... "
        if [[ $win -ne $my_window ]]
        then
            # use xprop to get the window's type and only close "normal" windows
            # this is to avoid disrupting windowmanager/compositor (e.g. kwin) functionaliy
            if xprop -id $win | grep -q "_NET_WM_WINDOW_TYPE_NORMAL" ; then
                echo -e -n " (${BGon}Normal${Boff})"
 #               xdotool windowclose $win 2>/dev/null
                # gracefully close this window by sending it an exit command
                # (--sync to wait till it actually has focus)
                xdotool windowactivate "$win" --sync && \
                sleep $typeWait
                xdotool type "exit" && sleep $sleepWait && xdotool key Return && \
                   echo " closed" || \
                   echo "tried, but failed to close"
            else
                echo -e " (${BMon}Special, ${BRon}NOT Normal, ${BYon}skipping${Boff})"
                debug_do 'xprop -id "$win" | grep -E "WM_NAME|WM_CLASS|_NET_WM_STATE" | sed "s|^|    |"' 4
           fi
        else
            echo -e " (${BYon}My${Boff} window, ${BYon}skipping${Boff})"
        fi
#        sleep $sleepWait
    done
    return 0
}

#-----[ main script ]-----------------------------------------------

exec 6>&1 2>/dev/null           # Link file descriptor #6 with stdout. Saves stdout.
exec > $logFile  2>/dev/null    # stdout replaced with file.
# ----------------------------------------------------------- #
# All output from commands in this block sent to file $logFile
separator "${PN}-${BUILD}" "(closing)"
message "Exterminating any rogue xdotool_xxx process..."
num_desktops=$(xdotool get_num_desktops)
message "num_desktops: $num_desktops"

# kill any existing xdotoo_xxx processes
filter="grep 'xdotool_' | grep -v 'color=auto' | grep -v $!"
kill_pids || die "failed to kill_pids for filter [${filter}]"

# close all terminal windows except the control_window (that activated this program)
close_windows || die "failed to close_windows"

# now kill any residual ssh sessions
#message "Exterminating any rogue ssh processes ..."
#filter="grep 'ssh' | grep -v 'ssh-agent' | grep -v 'sshd' | grep -v 'grep'"
#kill_pids || die "failed to kill_pids"

# move the active window to desktop 0, if it isn't already there
my_window=$(xdotool getactivewindow)
message "my_window: ${my_window}"
my_desktop=$(xdotool get_desktop_for_window ${my_window})
message "my_desktop: ${my_desktop}"
if [[ ${my_desktop} -eq 0 ]]
then
  message "my_window [${my_window}] is already on desktop 0; no action required"
else
  message "moving my_window [${my_window}] to desktop 0 ..."
  xdotool set_desktop_for_window ${my_window} 0
fi
# now actually go to desktop 0 where we just sent the control window
message_n "re-setting to desktop 0"
xdotool set_desktop 0
[ $? -eq 0 ] && right_status $TRUE || right_status 1

#    log_message_n "activating and re-setting focus to control_window"
#    xdotool windowactivate "${control_window}" --sync
#    log_handle_result "$?" "re-set ctrl success!" "failed to re-activate control_window"
message_n "activating and re-setting focus to control_window"
xdotool windowactivate "${control_window}" --sync
[ $? -eq 0 ] && right_status $TRUE || right_status 1

exec 1>&6 6>&-  2>/dev/null     # Restore stdout and close file descriptor #6.

cat $logFile
