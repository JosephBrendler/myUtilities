#!/bin/bash
# xdotool_close_windows  -- joe brendler (c) 2014-3599
# Notes:
# (1) Use legit bash assignments only. this file will be sourced by the scripts.
# (2) See sections for geometry, filesystem, timing, and ssh sessions.
# (3) A key part of this is to populate the list of ssh sessions to be opened by the script
# (4) If an ${ssh_session_list[@]} entry begins with the characters "x_" it will be ignored
# (5) The _open_ script will set up to two ssh-terminal windows per desktop
# (6) The -open_ script will determine the number of desktops needed (but always even #)
# (7) The example ssh_session_list array assignment below has two hostnames per line for readability
# (8) The -set- (terminal) script will open one terminal window, resize/move it, and then open an ssh sess>
#     [ver 0.2.0 would open the terminal program with " -e ssh ${ssh_target}" in one step, but this
#      delays the opening of the terminal window until the ssh session is established
#      ver 0.2.1 de-couples those (back into two steps as done previously.  The consequence
#      is that the ssh sessions may survive closure of the terminal, and the xdotool_close_windows
#      program may have to resort to finding and killing them directly]
#

### to-do:
### (0) generalize for wayland or x11 using draft detect_graphical_env_and_pick_wm_tool() below
### (1) enable higher number up to four (quaarter-tiled) windows per desktop
###     (keep the convention of same number on the line of assignment)
### (2) use tigervnc/remina to open vnc/ssh if line has v_<name> (ssh if s_<name>)
###   + example open cmd: vncviewer -Fullcolor -QualityLevel 9 -via joe@${ssh_target} localhost:2

source /usr/sbin/script_header_joetoo

PN=${0##*/}

#=====[ user variable defaults (override in config_file) ]==============================

#-----[ User ]--------------------------------------------------------------------------
user=joe

#-----[ Geometry ]----------------------------------------------------------------------
# window size and locationfor two terminal windows "L" and "R"
# positioned horizontally at X1, X2 respectively, both vertically at Y1
# (this default leaves 12% visible on the right, for widgets or whatever)
width="43%"      # terminal window width as a percent of screen width
height="85%"     # terminal window height as a percent of screen height
X1="1%"          # left horizontal edge position of left window as a percent of screen width
Y1="5%"          # vertical position of both terminals as a percent of screen height
X2="45%"         # left horizontal edge position of right window as a percent of screen width

LR="L"           # which window L|R to resize/move

#-----[ Filesystem ]--------------------------------------------------------------------
config_dir="/etc/xdotool_open_windows"
config_file="${config_dir%/}/xdotool_open_windows.conf"
build_file=$"${config_dir%/}/BUILD"
#log_dir="/home/${user}"
#old_log_dir="/home/${user}"
log_dir="/var/log"
old_log_dir="/var/log/old_logs"
logFile="${log_dir%/}/xdotool_open_windows.log"
LOGGING="$TRUE"

#-----[ Terminal Program ]--------------------------------------------------------------
terminal_program="/usr/bin/konsole"       # default
#terminal_program="/usr/bin/lxterminal"
#terminal_program="/usr/bin/xterm"

#-----[ Timing ]------------------------------------------------------------------------
# customized timing and detailed output (override in config_file)(increase for debugging)
sleepWait=0.5    # help avoid race conditions
longWait=2       # help avoid race conditions
timeout=10       # seconds to wait while trying to close a window or identify a new one
typeWait=2       # seconds to wait while trying to identify a newly opened window

#-----[ Debug Verbosity ]---------------------------------------------------------------
#VERBOSE="$FALSE"
VERBOSE="$TRUE"
# set verbosity only if not already set (allow calling program to do so)
[ -z "$verbosity" ] && verbosity=4

#-----[ Session List ]------------------------------------------------------------------
ssh_session_list=( \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 )

#-----[ program variables (do not edit) ]--------------------------------------------

# no_msg is a space overwritten by a backspace, used to send null message with a non-null string
no_msg=" \b"

# get display geometry in pixels
# Using 'xdpyinfo' b/c it is more stable/portable than 'xdotool getdisplaygeometry'
SCREEN_DIMENSIONS=$(xdpyinfo | grep -oP 'dimensions:\s+\K\S+')
SCREEN_WIDTH=$(echo "$SCREEN_DIMENSIONS" | cut -dx -f1)
SCREEN_HEIGHT=$(echo "$SCREEN_DIMENSIONS" | cut -dx -f2)

silent=">/dev/null 2>&1"  # append this to a command to silence it

varlist="PN BUILD config_dir lv.config_file old_log_dir log_dir lv.logFile"
varlist+=" BREAK control_window numdesktops sleepWait longWait typeWait timeout"
varlist+=" bool.VERBOSE verbosity"

# load custom configuration, if it exists
notice_msg_n "sourcing config_file: ${config_file} ..."
[[ -f "${config_file}" ]] || die "${config_file} does not exist"
source "${config_file}" || die "failed to source ${config_file}"
right_status $?

notice_msg_n "sourcing build_file: ${build_file} ..."
[[ -f "${build_file}" ]] || die "${build_file} does not exist"
source "${build_file}" || die "failed to source ${build_file}"
right_status $?

# set these after sourcing config
num_ssh_sessions="${#ssh_session_list[@]}"
xdotool_filter="grep 'xdotool_' | grep -v 'color=auto' | grep -v '$!'"
ssh_filter="grep 'ssh' | grep -v 'ssh-agent' | grep -v 'sshd' | grep -v 'grep'"
current_window=""

#-----[ functions ]-------------------------------------------------

# 20251022 - moved these functions to script_header_joetoo
# timestamp()
# log_message()
# log_echo()
# log_echo_e()
# log_E_message()
# d_log_message()
# log_message_n()
# log_echo_n()
# log_echo_e_n()
# log_right_status()
# log_handle_result()
# validate_logfile()
# log_separator()
# log_show_config()
# show_config()

calculate_pixels() {
    local percentage=$1
    local total_dimension=$2
    local percent_value=$(echo "$percentage" | cut -d'%' -f1)
    echo $((total_dimension * percent_value / 100))
}

set_terminal_window_dimensions() {
    # set terminal dimensions in pixels based on percents from config
    debug_msg "in ${FUNCNAME[0]}"
    ERROR="$FALSE"
    WINDOW_WIDTH=$(calculate_pixels "$width" "$SCREEN_WIDTH") || ERROR="$TRUE"
    WINDOW_HEIGHT=$(calculate_pixels "$height" "$SCREEN_HEIGHT") || ERROR="$TRUE"
    POS_X1=$(calculate_pixels "$X1" "$SCREEN_WIDTH") || ERROR="$TRUE"
    POS_Y1=$(calculate_pixels "$Y1" "$SCREEN_HEIGHT") || ERROR="$TRUE"
    POS_X2=$(calculate_pixels "$X2" "$SCREEN_WIDTH") || ERROR="$TRUE"
    [ ! "$ERROR" ] && return 0 || return 1
}

close_windows() {
    local result=""
    debug_msg "in ${FUNCNAME[0]} with arg(s) [$@]"
    notice_msg "Now closing all terminal windows except control_window [${BMon}${control_window}${Boff}] ..."
    # close all these windows
    for win in $(for x in "${window_list[@]}"; do echo "$x"; done | sort -n)
    do
        # use getwindowname to test for the continued existence of the window before running commands on them
        # if $win exists, the command succeeds and prints its name to stdout
        # if $win has been closed, the command will fail and write an error message to stderr
        notice_msg_n "looking for window: [${BMon}${win}${Boff}]"
        xdotool getwindowname "$win" >/dev/null 2>&1 ; result=$?
        handle_result "$?" "exists" "does not exist"   # don't use || return 1 (drive on)

        [ ! "$result" -eq 0 ] && continue  # skips code below and continues w next iteration of loop
        notice_msg_n "getting desktop for win: [${BMon}$win${Boff}]"
        desktop=$(xdotool get_desktop_for_window "$win" 2>/dev/null)
        handle_result "$?" "${desktop}" "${desktop}"   # don't use || return 1 (drive on)
        notice_msg_n "Examining window [${BMon}$win${Boff}] on desktop [${BMon}$desktop${Boff}]"
        # control_window should be excluded from window_list, and the xprop check should not be
        # necessary since we are using top-level terminal application windows as the search scope
        # see versions prior to 0.1.8 for use of check here for control_window and use of xprop
        echo_e_msg_n " (${BRon}closing${Boff})"
        # wmctrl -ic is equivalent to clicking the red "X" in the upper right corner of a window
        #  (sends the WM_DELETE_WINDOW protocol message, a polite request, which can be intercepted
        #   by the terminal window application (e.g. Konsole), which will generate a confirmation
        #   dialog pop-up window).
        #  xdotool windowkill sends a much stronger request, often the XKillClient
        #   (equivalent to finding the pid and using kill -9 $pid)
#        wmctrl -ic "$win"
        xdotool windowkill "$win"
        poll_for_window_closed "$win"
        handle_result "$?" "closed" "failed to close"
    done
    # move the active window to desktop 0, if it isn't already there
    if [[ "${current_desktop}" -eq 0 ]]
    then
      notice_msg "control_window [${BMon}${control_window}${Boff}] is already on desktop 0; no action required"
    else
      notice_msg_n "moving control_window [${BMon}${control_window}${Boff}] to desktop 0 ..."
      xdotool set_desktop_for_window "${control_window}" 0
      handle_result "$?" "desktop 0 set for ctrl" "failed to set_desktop_for_window 0 for ctrl" || return 1
    fi
    # now actually go to desktop 0 where we just sent the control window
    notice_msg_n "re-setting to desktop 0"
    xdotool set_desktop 0
    handle_result "$?" "desktop 0 set" "failed to setset_desktop 0" || return 1

    notice_msg_n "activating and re-setting focus to control_window"
    xdotool windowactivate --sync "${control_window}"
    handle_result "$?" "activated and re-set ctrl" "failed to re-activate control_window" || return 1
    return 0
}

poll_for_window_closed() {
    # wait until the window manager (wmctl) confirms the window is gone (or timeout)
    local myWin="$1"
    local elapsed=0
    while [[ ! -z $(wmctrl -l | grep -q "$myWin") ]] && [[ "$( echo "$elapsed <= $timeout" | bc -l )" -eq 1 ]] ; do
        sleep "$sleepWait"
        elapsed=$(echo "scale=2; ( ${elasped:-0} + $sleepWait )" | bc -l )
    done
    # return 1 if this timed out
    if [[ ! -z $(wmctrl -l | grep -q "$myWin") ]] ; then
        # myWin still not closed; timed out
        error_msg "timed out waiting for myWin to close"
        return 1
    else
        return 0
    fi
}

kill_pids() {
    # as a last resort, kill processes identified by ${myFilter}
    local myFilter="$1"
    myFilter_name="$(echo ${myFilter} | awk '{print $2}')"
    notice_msg_n "identifying pids matching myFilter for [${BYon}${myFilter_name}${Boff}]"
    pids=($(eval "ps -aef | ${myFilter} | awk '{print \$2}'"))
    handle_result "$?" "${#pids[@]} pids" "failed to id pids!" || return 1

    debug_msg "#pids: ${#pids[@]}"
    notice_msg "Exterminating any rogue [${BYon}${myFilter_name}${Boff}] process..."
    if [[ -z "${pids[@]}" ]] ; then
         notice_msg "Found [${BMon}${#pids[@]}${Boff}] processes for myFilter [${BYon}${myFilter_name}${Boff}]"
    else
        elapsed=0
        round=1
        debug_msg "elapsed: [$elapsed] sleepWait: [$sleepWait] timeout: [$timeout]"
        # floating point math here...
        while [[ ! -z "${pids[@]}" && "$( echo "$elapsed <= $timeout" | bc -l )" -eq 1 ]] ; do
            debug_msg "round: ($round) elapsed: [$elapsed] sleepWait: [$sleepWait] timeout: [$timeout]"
            notice_msg "Found [${BMon}${#pids[@]}${Boff}] processes for myFilter [${BYon}${myFilter_name}${Boff}]"
            for x in "${pids[@]}"
            do
                notice_msg_n "(${round}) ${BRon}killing${Boff} process x: [${BMon}${x}${Boff}]"
                kill -9 "$x" 2>/dev/null
                handle_result "$?" "killed" "kill failed!" || return 1
            done # for
            sleep "$sleepWait"
            # floating point math again here...
            elapsed=$(echo "scale=2; ( ${elapsed:-0} + $sleepWait )" | bc -l );
            round+=1
            pids=($(eval "ps -aef | ${myFilter} | awk '{print \$2}'"))
        done # while
        x=""
    fi # -z pids
    return 0
}

dump_terminal_window_list() {
    local buffer=5  # leave room for padding, etc.
    local ts_buffer=23  # leave room for timestamp, etc.
    local np_chars=26   # discount for non-visible characters in msg
    msg="${BYon}----------[ ${LBon}Current window list ${BYon}]"
    msg+="$( repeat '-' $(( $(termwidth) - ( ${#msg} + $ts_buffer -$np_chars ) )) )${Boff}"
    notice_msg "${msg}"
    win_list_line=""
    for win in "${window_list[@]}"; do
        # print as many window ids on each line as will fit
        debug_msg "#win_list_line: [${#win_list_line}] #win: [${#win}]"
        debug_msg " sum: [$((${#win_list_line} + ${#win}))] termwidth: [$(termwidth)]"
        if [ $((${#win_list_line} + ${#win})) -lt $(( $(termwidth) - buffer )) ] ; then
            # this line is not full; append
            debug_msg "comparison true (room for win)"
            win_list_line+="$win "
        else
            # this line is already full; output this one, and then start a new one
            debug_msg "comparison false (room for win)"
            echo_msg "    ${win_list_line}"
            win_list_line="$win"
        fi
        # output whatever is left in any remaining un-full line
    done
    echo_msg "    ${win_list_line}"
    return 0
}

get_terminal_window_list() {
    # populate window_list array with window ids of activa and minimized terminal windows only
    # versions prior to 0.1.8 used xdotool search --any (too broad scope)
    # xdotool search returns decimal window ids // wmctrl -l returns hex window ids
    # look for all three terminal types using regex, convert hex to decimal and exclude control_window
    re_filter="konsole\.Konsole|lxterminal\.Lxterminal|xterm\.XTerm"
    window_list=($(wmctrl -lx | grep -Ei "${re_filter}" | awk '{print strtonum($1)}' | grep -v "${control_window}"))
    return 0
}

close_windows_wrapper() {
    # run close_windows and repeat until there are no more open windows
    local round=0
    get_terminal_window_list || return 1
    notice_msg "Currently tracking [${BMon}${#window_list[@]}${Boff}] terminal windows"
    d_do 'dump_terminal_window_list' "$debug"
    while [[ ! -z "${window_list[@]}" ]] ; do
        notice_msg "round (${BMon}${round}${Boff}) closing ${#window_list[@]} terminal windows"
        close_windows || return 1
        get_terminal_window_list || return 1
        ((round+=1))
    done
    return 0
}

#-----[ main script ]-----------------------------------------------
debug_msg "now in main script"
notice_msg_n "checking not root ..."
checknotroot && right_status $? || die "failed checknotroot"
validate_logfile || die "failed to validate logfile"

separator "$(hostname)" "${PN}-${BUILD}"
notice_msg "starting script"

# identify the control window (used to activate this program)
notice_msg_n "Getting ID of current (control) window"
control_window=$(xdotool getactivewindow)
handle_result "$?" "${control_window}" "failed to id control_window" || exit 1

# identify the current desktop and notice_msg "starting script"
current_desktop=$(xdotool get_desktop_for_window "${control_window}")
notice_msg "current_desktop: ${current_desktop}"
num_desktops=$(xdotool get_num_desktops)
notice_msg "num_desktops: $num_desktops"

# run sequence
show_config || die "failed show_config"
close_windows_wrapper || die "failed close_windows_wrapper"
kill_pids "${xdotool_filter}"  || die "failed to kill_pids for filter [${BYon}${filter}${Boff}]"
kill_pids "${ssh_filter}" || die "failed to kill_pids for filter [${BYon}${filter}${Boff}]"

notice_msg "${BGon}Done${Boff}"

#debug_msg "${BMon}Debug Marker${Boff}"; exit 1
