#!/bin/bash
source /usr/sbin/script_header_joetoo

#-----[ initialize variables ]-------------------------------------------------

# configure for arbitrary n virtual desktops, each with two terminal windows
width="46%"      # terminal window width as a percent of screen width
height="85%"     # terminal window height as a percent of screen height
X1="1%"          # left horizontal edge position of left window as a percent of screen width
Y1="5%"          # vertical position of both terminals as a percent of screen height
X2="51%"         # left horizontal edge position of right window as a percent of screen width

PN=$(basename $0)

user=joe

config_dir="/etc/xdotool_open_windows"
config_file="${config_dir%/}/xdotool_open_windows.conf"
build_file=$"${config_dir%/}/BUILD"
log_dir="/home/${user}"
old_log_dir="/home/${user}"
logFile="${log_dir%/}/xdotool_open_windows.log"

terminal_program="/usr/bin/konsole"
#terminal_program="/usr/bin/lxterminal"
#terminal_program="/usr/bin/xterm"

# use xdotool_sizemove_this_window (alias mw) l|L|r|R [<width>%] [<height>%]
shopt -s expand_aliases
alias mw='/usr/sbin/xdotool_sizemove_this_window'

# get display geometry in pixels
# Using 'xdpyinfo' b/c it is more stable/portable than 'xdotool getdisplaygeometry'
SCREEN_DIMENSIONS=$(xdpyinfo | grep -oP 'dimensions:\s+\K\S+')
SCREEN_WIDTH=$(echo $SCREEN_DIMENSIONS | cut -dx -f1)
SCREEN_HEIGHT=$(echo $SCREEN_DIMENSIONS | cut -dx -f2)

silent=">/dev/null 2>&1"  # append this to a command to silence it

# customized timing and detailed output (increase for debugging)
#sleepWait=0.5    # default - set in .conf
sleepWait=0.15    # default - set in .conf
#longWait=2       # default - set in .conf
longWait=1.1      # default - set in .conf
timeout=10        # seconds to wait while trying to close a window or identify a new one

new_window_timeout=10 # seconds to wait while trying to identify the newly launched window

VERBOSE=$TRUE
# set verbosity only if not already set (allow calling program to do so)
[ -z $verbosity ] && verbosity=4

ssh_session_list=( \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 )

varlist="PN  BUILD config_dir lv.config_file old_log_dir log_dir lv.logFile"
varlist+=" BREAK width height X1 Y1 X2 SCREEN_WIDTH SCREEN_HEIGHT WINDOW_WIDTH"
varlist+=" WINDOW_HEIGHT POS_X1 POS_Y1 POS_X2"
varlist+=" BREAK numdesktops sleepWait longWait "
varlist+=" control_window BREAK bool.VERBOSE verbosity"

# load custom configuration, if it exists
message_n "sourcing config_file: ${config_file} ..."
[[ -f ${config_file} ]] || die "${config_file} does not exist"
source ${config_file} || die "failed to source ${config_file}"
right_status $?

message_n "sourcing build_file: ${build_file} ..."
[[ -f ${build_file} ]] || die "${build_file} does not exist"
source ${build_file} || die "failed to source ${build_file}"
right_status $?

#-----[ functions ]----------------------------------------------------------

timestamp() {
    echo "$(date '+%Y%m%d-%H:%M:%S')"
}

# Function for logging. This sends messages to both the console and the log file.
log_message() {
    local message="$1"
    message "$(timestamp) - $message" | tee -a "$logFile"
}

log_E_message() {
    local message="$1"
    E_message "$(timestamp) - $message" | tee -a "$logFile"
}

d_log_message() {
    local message="$1"
    local level="$2"
    local msg="$(timestamp) - $message"
    sudo sh -c "echo -e \" ${BGon}*${Boff} ${msg}\" >> $logFile"
    d_message "$msg" $level
}

log_message_n() {
    local message="$1"
    local msg="$(timestamp) - $message"
    sudo sh -c "echo -e \" ${BGon}*${Boff} ${msg}\" >> $logFile"
    message_n "$message"
}

# Function to convert a percentage string (e.g., "46%") to a pixel integer.
calculate_pixels() {
    local percentage=$1
    local total_dimension=$2
    local percent_value=$(echo "$percentage" | cut -d'%' -f1)
    echo $((total_dimension * percent_value / 100))
}

set_terminal_window_dimensions() {
    # set terminal dimensions in pixels based on percents from config
    d_log_message "in ${FUNCNAME[0]}" 5
    ERROR=$FALSE
    WINDOW_WIDTH=$(calculate_pixels "$width" "$SCREEN_WIDTH") || ERROR=$TRUE
    WINDOW_HEIGHT=$(calculate_pixels "$height" "$SCREEN_HEIGHT") || ERROR=$TRUE
    POS_X1=$(calculate_pixels "$X1" "$SCREEN_WIDTH") || ERROR=$TRUE
    POS_Y1=$(calculate_pixels "$Y1" "$SCREEN_HEIGHT") || ERROR=$TRUE
    POS_X2=$(calculate_pixels "$X2" "$SCREEN_WIDTH") || ERROR=$TRUE
    [ ! $ERROR ] && return 0 || return 1
}

dump_ssh_session_list() {
  d_log_message "in ${FUNCNAME[0]}" 5
  # i will count the dsktop, on each of which there are 2 slots for terminals j, k
  # e.g. i=0 (j=0,k=1); i=1 (j=2,k=3); i=2 (j=4,k=5)
  for ((i=0; i<${num_desktops}; i++ ))
  do
    j=$((2*$i))
    k=$(($j+1))
    ssh_target="${ssh_session_list[$j]}"
    d_log_message "j: $[j] ssh_session_list[\$j]: [${ssh_session_list[$j]}] ssh_target: [$ssh_target}" 3
    let k=$(( $j + 1 ))
    ssh_target="${ssh_session_list[$k]}"
    d_log_message "k: $[k] ssh_session_list[\$k]: [${ssh_session_list[$k]}] ssh_target: [$ssh_target}" 3
  done
}


validate_logfile() {
    d_log_message "in ${FUNCNAME[0]}" 5
    log_message_n "looking for logFile [${logFile}]"
    if [ ! -f ${logFile} ] ; then
        echo -e -n " (${BRon}not found${Boff})"
        right_status 1
        msg="logFile [${logFile}] not found\n"
        msg+="${BRon}Please run (as root) ${BGon}touch ${logFile}; chown ${user}:${user} ${logFile}${Boff}"
        log_E_message "${msg}"
        return 1
    else
        echo -e -n " (${BGon}found${Boff})"
        right_status $TRUE
        log_message_n "checking logFile ownership"
        log_owner=$(stat -c '%U' "${logFile}")
        log_group=$(stat -c '%G' "${logFile}")
        if [[ "${log_owner}:${log_group}" == "${user}:${user}" ]] ; then
            echo -e -n " (${BGon}${log_owner}:${log_group}${Boff})"
            right_status $TRUE
        else
            echo -e -n "(${BRon}${log_owner}:${log_group}${Boff})"
            right_status 1
            msg="bad ownership on logFile [${logFile}]\n"
            msg+="${BRon}Please run (as root) ${BGon}chown ${user}:${user} ${logFile}${Boff}"
            log_E_message "${msg}"
            return 1
        fi # ownership
    fi # existence
    return 0
}

rotate_logfile() {
    d_log_message "in ${FUNCNAME[0]}" 5
    ## TODO - rotate logfile
    log_message_n "archiving old logfile ..."
    sudo sh -c "gzip -c ${logFile} > ${old_log_dir%/}/$(basename ${logFile})-$(timestamp).gz" || \
        die "failed to archive logFile"
    right_status $TRUE

    log_message_n "removing old logfile ..."
    sudo rm $logFile || die "failed to remove old logFile"
    right_status $TRUE

    log_message_n "creating new logfile ..."
    sudo touch $logFile && \
    sudo chown ${user}:${user} $logFile || die "failed to create new logFile"
    right_status $TRUE

    return 0
}

setup_desktops() {
    log_message_n "calculating numdesktops needed"
    numdesktops=$(( $(( ${#ssh_session_list[@]} + 1 )) / 2 )) ; result=$?
    if [ $result -eq 0 ] ; then
        echo -e -n " (${BGon}${numdesktops}${Boff})"
        right_status $TRUE
    else
        log_E_message "failed to calculate numdesktops"
        right_status 1
        return 1
    fi

    log_message_n "setting numdesktops ..."
    xdotool set_num_desktops ${numdesktops} ; result=$?
    if [ $result -eq 0 ] ; then
        right_status $TRUE
    else
        log_E_message "failed to set numdesktops"
        right_status 1
        return 1
    fi

    log_message_n "get-confirming numdesktops"
    num_desktops=$(xdotool get_num_desktops) ; result=$?
    if [ $result -eq 0 ] ; then
        echo -e -n " (${BGon}${num_desktops}${Boff})"
        right_status $TRUE
    else
        log_E_message "failed to get numdesktops"
        right_status 1
        return 1
    fi


    d_log_message "need numdesktops .........: [${numdesktops}]" 3
    d_log_message "calculated num_desktops ..: [${num_desktops}]" 3

    return 0
}

show_config() {
    d_log_message "in ${FUNCNAME[0]}" 5
    separator "${PN}" "(configuration)"
    longest=$(get_longest ${varlist})
    display_vars ${longest} ${varlist}
}

open_windows() {
    # size-move the control window; then open terminals for ssh sessions
    d_log_message "in ${FUNCNAME[0]}" 5
    separator "${PN}" "(${FUNCNAME[0]})"
    msg="Openning $(basename ${terminal_program})"
    msg+=" terminals and starting ssh sessions. Please wait..."
    d_log_message "${msg}" 1

    d_log_message "Enumerating ssh session list ..." 1
    dump_ssh_session_list | sudo tee -a $logFile; result=$?

    # identify the control window (used to activate this program)
    log_message_n "Getting ID of current (control) window"
    control_window=$(xdotool getactivewindow) ; result=$?
    if [ $result -eq 0 ] ; then
        echo -e -n " (${BMon}${control_window}${Boff})"
        right_status $TRUE
    else
        log_E_message "failed to id control_window"
        right_status 1
        return 1
    fi

    # move the control_window to desktop zero
    log_message_n "moving control_window to desktop 0 ..."
    xdotool set_desktop_for_window ${control_window} 0 ; result=$?
    if [ $result -eq 0 ] ; then
        right_status $TRUE
    else
        log_E_message "failed to move control_window to desktop 0"
        right_status 1
        return 1
    fi

    # use xdotool_sizemove_this_window (alias mw) l|L|r|R [<width>%] [<height>%]
    log_message_n "resizing control_window"
    eval "mw L $WINDOW_WIDTH $WINDOW_HEIGHT ${silent}"; result=$?
    if [ $result -eq 0 ] ; then
        right_status $TRUE
    else
        log_E_message "failed to resize control_window"
        right_status 1
        return 1
    fi

    # set window name for control_window
    log_message_n "setting window name for control_window"
    # get terminal program name (b/c it might not be the same as what this program calls)
    control_term=$(xprop -id "$WINDOWID" WM_CLASS | awk -F'"' '{print $4}') && \
    windowname="$(hostname)_${control_term}-0.0" && \
    xdotool set_window --name "${windowname}" "${control_window}" ; result=$?
    if [ $result -eq 0 ] ; then
        echo -e -n " (${BMon}${windowname}${Boff})"
        right_status $TRUE
    else
        log_E_message "failed to assign window name"
        right_status 1
        return 1
    fi

    # integer "i" will count the dsktops, on each of which we can put 2 terminals "j", "k"
    # e.g. i=0 (j=0,k=1); i=1 (j=2,k=3); i=2 (j=4,k=5);  i=3 (j=6,k=7)
    for ((i=0; i<${num_desktops}; i++ )); do
        # set desktop
        log_message_n "setting desktop [$i]"
        xdotool set_desktop "$i" ; result=$?
        if [ $result -eq 0 ] ; then
            right_status $TRUE
        else
            log_E_message "failed to set desktop [$i]"
            right_status 1
            return 1
        fi
        j=$((2*$i))  # even (left)
        k=$(($j+1))  # odd (right)
        # the even numbered terminals go on the left
        # terminal 0 is reserved for the control_window (no ssh sessions)
        d_log_message "i: [$i]; j: [$j]; k: [$k]" 5
        if [ ! $j -eq 0 ] ; then
            setup_terminal "$j" ; result=$?
            if [ $result -eq 0 ] ; then
                right_status $TRUE
            else
                log_E_message "failed to setup terminal [$j]"
                right_status 1
                return 1
            fi
        else
            d_log_message "skipping setup for terminal [$j]] (should be 0)" 4
        fi
        sleep $sleepWait
        # the odd numbered terminals go on the right
        d_log_message "calling setup_terminal [$k]" 2
        setup_terminal "$k" ; result=$?
        if [ $result -eq 0 ] ; then
            right_status $TRUE
        else
            log_E_message "failed to setup terminal [$k]"
            right_status 1
            return 1
        fi
        sleep $sleepWait
    done
    # set desktop back to 0
    # set desktop
    log_message_n "re-setting desktop 0"
    xdotool set_desktop "0" ; result=$?
    if [ $result -eq 0 ] ; then
        right_status $TRUE
    else
        log_E_message "failed to re-set desktop 0"
        right_status 1
        return 1
    fi
    return 0
}

setup_terminal() {
    d_log_message "in ${FUNCNAME[0]} with arg(s) [$@]" 5
    local t="$1"  # terminal number
    ssh_target="${ssh_session_list[$t]}"
    # if the ssh_target name begins "x_" we ignore it - it is intended to be blank (no window)
    if [[ ! "${ssh_target}" == "x_"* ]] ; then
        log_message "openning terminal and ssh to [${ssh_target}]"
        # take a baseline for comparison so we can find the new window for certain
        terminal_class="$(basename ${terminal_program})"
        before=($(xdotool search --class "${terminal_class}"))
        # launch a new terminal with an ssh session as needed
        "${terminal_program}" -e ssh "${ssh_target}" &
        sleep $longWait
        # newterm=$(xdotool getactivewindow 2>/dev/null) ## <-- unreliable
        newterm=$(poll_for_new_window)
        if  [ ! -z "$newterm" ] ; then
            xdotool set_window --name "$(hostname) $(basename ${terminal_program})_${i}.${t}" "${newterm}"
            log_message "opened new terminal for ${ssh_target} on desktop [$i]"
            # sizemove this windw
            if [ $(($t % 2)) -eq 0 ] ; then
                # even (Left)
                log_message_n "resizing window [$t]"
                eval "mw L $WINDOW_WIDTH $WINDOW_HEIGHT ${silent}"; result=$?
            else
                # odd (Right)
                log_message_n "resizing window [$t]"
                eval "mw R $WINDOW_WIDTH $WINDOW_HEIGHT ${silent}"; result=$?
            fi # even/odd
            if [ $result -eq 0 ] ; then
                right_status $TRUE
            else
                log_E_message "failed to resize window [$t]"
                right_status 1
                return 1
            fi # 0 result
        else
            log_E_message "failed to get new window ID within time limit"
        fi # nonzero newterm
    else
        log_message "not openning a terminal for (blank) [${ssh_target}]"
    fi # non x_ (blank) ssh_target
    return 0
}

poll_for_new_window() {
    # (rathern than using newterm=$(xdotool getactivewindow 2>/dev/null)
    # which is unreliable due to succeptibility to race condition)
    # USE: run before=($(xdotool search --class ${}terminal_program))
    # then launch a new terminal,
    # then run this function to wait until the new window is accessible
    local -a after
    local new_wid=""
    local timeout="${new_window_timeout}"  # time out after 10 seconds
    local elapsed=0
    while [[ -z "$new_wid" && "$elapsed" < "$timeout" ]]; do
        after=($(xdotool search --class "${terminal_class}" ))
        for wid in "${after[@]}"; do
            is_new=true
            for old_wid in "${before[@]}"; do
                if [[ "$wid" == "$old_wid" ]]; then
                    is_new=false
                    break
                fi
            done
            if [[ "$is_new" == true ]]; then
                new_wid="$wid"
                break 2  # Break out of both inner and outer loops
            fi
        done
        sleep 0.2
        elapsed=$(echo "$elapsed + 0.2" | bc)
    done

    echo "$new_wid"
    [[ -z "$new_wid" ]] && return 1 || return 0
}

#-----[ main script ]-----------------------------------------------------
d_log_message "now in main script" 3
#checknotroot
log_message_n "checking not root ..."
checknotroot && right_status $? || die "failed checknotroot"

separator "$(hostname)" "${PN}-${BUILD}"

validate_logfile || die "failed to validate logfile"
rotate_logfile || die "failed to rotate logfile"
log_message "Starting script execution."
set_terminal_window_dimensions || die "failed to set_terminal_window_dimensions"
setup_desktops || die "failed to setup_desktops"
show_config || die "failed to show_config"

open_windows || die "failed to open_windows"

d_log_message "${BGon}Done${Boff}"

#d_message "${BMon}Debug Marker${Boff}" 3 ; exit 1

