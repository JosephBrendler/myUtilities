#!/bin/bash
# xdotool_open_windows -- joe brendler (c) 2014-3599
# Notes:
# (1) Use legit bash assignments only. this file will be sourced by the scripts.
# (2) See sections for geometry, filesystem, timing, and ssh sessions.
# (3) A key part of this is to populate the list of ssh sessions to be opened by the script
# (4) If an ${ssh_session_list[@]} entry begins with the characters "x_" it will be ignored
# (5) The _open_ script will set up to two ssh-terminal windows per desktop
# (6) The -open_ script will determine the number of desktops needed (but always even #)
# (7) The example ssh_session_list array assignment below has two hostnames per line for readability
# (8) The -set- (terminal) script will open one terminal window, resize/move it, and then open an ssh session in it
#     [ver 0.2.0 would open the terminal program with " -e ssh ${ssh_target}" in one step, but this
#      delays the opening of the terminal window until the ssh session is established
#      ver 0.2.1 de-couples those (back into two steps as done previously.  The consequence
#      is that the ssh sessions may survive closure of the terminal, and the xdotool_close_windows
#      program may have to resort to finding and killing them directly]
#

### to-do:
### (0) generalize for wayland or x11 using draft detect_graphical_env_and_pick_wm_tool() below
### (1) enable higher number up to four (quaarter-tiled) windows per desktop
###     (keep the convention of same number on the line of assignment)
### (2) use tigervnc/remina to open vnc/ssh if line has v_<name> (ssh if s_<name>)
###   + example open cmd: vncviewer -Fullcolor -QualityLevel 9 -via joe@${ssh_target} localhost:2

source /usr/sbin/script_header_joetoo

PN=$(basename $0)

#=====[ user variable defaults (override in config_file) ]==============================

#-----[ User ]--------------------------------------------------------------------------
user=joe

#-----[ Geometry ]----------------------------------------------------------------------
# window size and locationfor two terminal windows "L" and "R"
# positioned horizontally at X1, X2 respectively, both vertically at Y1
# (this default leaves 12% visible on the right, for widgets or whatever)
width="43%"      # terminal window width as a percent of screen width
height="85%"     # terminal window height as a percent of screen height
X1="1%"          # left horizontal edge position of left window as a percent of screen width
Y1="5%"          # vertical position of both terminals as a percent of screen height
X2="45%"         # left horizontal edge position of right window as a percent of screen width

LR="L"           # which window L|R to resize/move

#-----[ Filesystem ]--------------------------------------------------------------------
config_dir="/etc/xdotool_open_windows"
config_file="${config_dir%/}/xdotool_open_windows.conf"
build_file=$"${config_dir%/}/BUILD"
#log_dir="/home/${user}"
#old_log_dir="/home/${user}"
log_dir="/var/log"
old_log_dir="/var/log/old_logs"
logFile="${log_dir%/}/xdotool_open_windows.log"

#-----[ Terminal Program ]--------------------------------------------------------------
terminal_program="/usr/bin/konsole"       # default
#terminal_program="/usr/bin/lxterminal"
#terminal_program="/usr/bin/xterm"

#-----[ Timing ]------------------------------------------------------------------------
# customized timing and detailed output (override in config_file)(increase for debugging)
sleepWait=0.5    # help avoid race conditions
longWait=2       # help avoid race conditions
timeout=10       # seconds to wait while trying to close a window or identify a new one
typeWait=2       # seconds to wait while trying to identify a newly opened window

#-----[ Debug Verbosity ]---------------------------------------------------------------
#VERBOSE=$FALSE
VERBOSE=$TRUE
# set verbosity only if not already set (allow calling program to do so)
[ -z $verbosity ] && verbosity=4

#-----[ Session List ]------------------------------------------------------------------
ssh_session_list=( \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 x_blank x_blank \
 )

#-----[ program variables (do not edit) ]--------------------------------------------

# no_msg is a space overwritten by a backspace, used to send null message with a non-null string
no_msg=" \b"

# get display geometry in pixels
# Using 'xdpyinfo' b/c it is more stable/portable than 'xdotool getdisplaygeometry'
SCREEN_DIMENSIONS=$(xdpyinfo | grep -oP 'dimensions:\s+\K\S+')
SCREEN_WIDTH=$(echo $SCREEN_DIMENSIONS | cut -dx -f1)
SCREEN_HEIGHT=$(echo $SCREEN_DIMENSIONS | cut -dx -f2)

varlist="PN BUILD config_dir lv.config_file old_log_dir log_dir lv.logFile"
varlist+=" BREAK control_window width height X1 Y1 X2 SCREEN_WIDTH SCREEN_HEIGHT"
varlist+=" WINDOW_WIDTH WINDOW_HEIGHT POS_X1 POS_Y1 POS_X2"
varlist+=" BREAK numdesktops sleepWait longWait typeWait timeout"
varlist+=" bool.VERBOSE verbosity"

# load custom configuration, if it exists
message_n "sourcing config_file: ${config_file} ..."
[[ -f ${config_file} ]] || die "${config_file} does not exist"
source ${config_file} || die "failed to source ${config_file}"
right_status $?

message_n "sourcing build_file: ${build_file} ..."
[[ -f ${build_file} ]] || die "${build_file} does not exist"
source ${build_file} || die "failed to source ${build_file}"
right_status $?

# set these after sourcing config
num_ssh_sessions=${#ssh_session_list[@]}
xdotool_filter="grep 'xdotool_' | grep -v 'color=auto' | grep -v $!"
ssh_filter="grep 'ssh' | grep -v 'ssh-agent' | grep -v 'sshd' | grep -v 'grep'"
control_window=""

#-----[ functions ]----------------------------------------------------------

# 20251022 - moved these functions to script_header_joetoo
# timestamp()
# log_message()
# log_echo()
# log_echo_e()
# log_E_message()
# d_log_message()
# log_message_n()
# log_echo_n()
# log_echo_e_n()
# log_right_status()
# log_handle_result()
# validate_logfile()
# log_separator()
# log_show_config()
# show_config()

calculate_pixels() {
    local percentage=$1
    local total_dimension=$2
    local percent_value=$(echo "$percentage" | cut -d'%' -f1)
    echo $((total_dimension * percent_value / 100))
}

set_terminal_window_dimensions() {
    # set terminal dimensions in pixels based on percents from config
    d_log_message "in ${FUNCNAME[0]}" 5
    ERROR=$FALSE
    WINDOW_WIDTH=$(calculate_pixels "$width" "$SCREEN_WIDTH") || ERROR=$TRUE
    WINDOW_HEIGHT=$(calculate_pixels "$height" "$SCREEN_HEIGHT") || ERROR=$TRUE
    POS_X1=$(calculate_pixels "$X1" "$SCREEN_WIDTH") || ERROR=$TRUE
    POS_Y1=$(calculate_pixels "$Y1" "$SCREEN_HEIGHT") || ERROR=$TRUE
    POS_X2=$(calculate_pixels "$X2" "$SCREEN_WIDTH") || ERROR=$TRUE
    [ ! $ERROR ] && return 0 || return 1
}

detect_graphical_env_and_pick_wm_tool() {
    # windowing: x11 or wayland only (ignore Mir, Quartz, SurfaceFlinger, MGR, fbui, W, etc)
    # desktop: plasma or gnome (ignore XFCE, Cinnamon, Mate, Unity, Budgie, E, LXQt, Deepin, Pantheon, etc.)
    windowing_system=""
    # detect windowing system
    log_message_n "detecting windowing system"
    if [ ! -z "$WAYLAND_DISPLAY" ] ; then
        windowing_system="wayland"  # only ! -z if wayland
        log_echo_e_n " (${BMon}${windowing_system}${Boff})"
    elif [ ! -z "$DISPLAY" ] ; then
        windowing_system="x11"      # if not wayland, then only -z if x11
        log_echo_e_n " (${BMon}${windowing_system}${Boff})"
    else
        windowing_system="none"
        log_echo_e_n " (${BRon}${windowing_system}${Boff})"
        right_status 1
        return 1
    fi
    right_status $TRUE
    # now select a window-management automation tool
    log_message_n "selecting window-management automation tool ..."
    case $windowing_system in
        "x11"     )
            # xdotool will work with both plasma and gnome in x11
            wm_tool="xdo"
            log_echo_e_n " (${BMon}${wm_tool}${Boff})"
            # detect desktop environment just to keep track of it
            desktop_env=${XDG_CURRENT_DESKTOP:-unknown}
            # convert to lowercase for referential integrity
            desktop_env=$(echo "$desktop_env" | tr '[:upper:]' '[:lower:]')
             ;;
        "wayland" )
            # xdotool doesn't work in waylandplasma
            # detect the desktop environment with default=unknown
            log_echo_e " (${BYon}for wayland${Boff})"
            log_message_n "detecting desktop environment"
            desktop_env=${XDG_CURRENT_DESKTOP:-unknown}
            # convert to lowercase for referential integrity
            desktop_env=$(echo "$desktop_env" | tr '[:upper:]' '[:lower:]')
            # finish selecting wm_tool
            if [[ "$desktop_env" == *"kde"* ]]; then
                wm_tool="qdbus"
                log_echo_e_n " (${BMon}qdbus${Boff})"
            elif [[ "$desktop_env" == *"gnome"* ]]; then
                wm_tool="gsettings"
                log_echo_e_n " (${BMon}gsettings${Boff})"
            else
                wm_tool="unsupported"
                log_echo_e_n " (${BRon}unsupported${Boff})"
                right_status 1
                log_E_message "unsupported desktop environment[${BMon}$desktop_env${Boff}]"
                return 1
            fi
            right_status $TRUE    # for select desktop env
            ;;
        "none"    ) ;;
        *         ) ;;
    esac
    right_status $TRUE    # for select wm_tool
    return 0
}

dump_ssh_session_list() {
    d_log_message "in ${FUNCNAME[0]}" 5
    # i will count the dsktop, on each of which there are 2 slots for terminals j, k
    # e.g. i=0 (j=0,k=1); i=1 (j=2,k=3); i=2 (j=4,k=5)
    d_log_message "num_desktops: [${num_desktops}]; num_ssh_sessions: [${#ssh_session_list[@]}]" 2
    for ((i=0; i<${num_desktops}; i++ ))
    do
        j=$((2*$i))
        k=$(($j+1))
        if [ $j -le ${#ssh_session_list[@]} ] ; then
            ssh_target="${ssh_session_list[$j]}"
            d_log_message "desktop: [${BMon}${i}${Boff}] j: [${BMon}$j${Boff}] ssh_session_list[\$j]: [${BYon}${ssh_session_list[$j]}${Boff}] ssh_target: [${BYon}$ssh_target${Boff}]" 3
        fi
        if [ $j -le ${#ssh_session_list[@]} ] ; then
            ssh_target="${ssh_session_list[$k]}"
            d_log_message "desktop: [${BMon}${i}${Boff}] k: [${LBon}$k${Boff}] ssh_session_list[\$k]: [${BYon}${ssh_session_list[$k]}${Boff}] ssh_target: [${BYon}$ssh_target${Boff}]" 3
        fi
    done
    return 0
}

setup_desktops() {
    # determine the number of desktops needed
    log_message_n "calculating numdesktops needed"
    numdesktops=$(( ( ${#ssh_session_list[@]} + 1 ) / 2 ))
    log_handle_result "$?" "${numdesktops}" "failed to calculate numdesktops" || return 1
    # if that is an odd number, add one so it's always even
    log_message_n "examining parity (want numdesktops even)"
    if [ ! "$(( $numdesktops % 2 ))" -eq 0 ] ; then
        ((numdesktops+=1))
        log_handle_result "$?" "${numdesktops}" "failed to make numdesktops even" || return 1
    else
        # necessary to complete the log action started by log_message_n which uses (echo -n)
        log_handle_result "0" "even" "error!" || return 1
    fi

    log_message_n "setting numdesktops ..."
    xdotool set_num_desktops "${numdesktops}"
    log_handle_result "$?" "set # success!" "failed to set numdesktops" || return 1
#    sleep $longWait   # give the desktops time to manifest

    # explicitly verify that the number of desktops have been created
    poll_for_num_desktops || return 1

    log_message_n "double-checking confirmation of num_desktops"
    num_desktops=$(xdotool get_num_desktops) && [ ${num_desktops} -eq ${numdesktops} ]
    log_handle_result "$?" "${num_desktops}" "${num_desktops}" || return 1

    d_log_message "need numdesktops .........: [${BMon}${numdesktops}${Boff}]" 3
    d_log_message "calculated num_desktops ..: [${BMon}${num_desktops}${Boff}]" 3

    return 0
}

open_windows() {
    # size-move the control window; then open terminals for ssh sessions
    d_log_message "in ${FUNCNAME[0]}" 5
    local result=""
    log_separator "${PN}" "(${FUNCNAME[0]})"
    msg="Openning $(basename ${terminal_program})"
    msg+=" terminals and starting ssh sessions. Please wait..."
    d_log_message "${msg}" 1

    d_log_message "Enumerating ssh session list ..." 1
    dump_ssh_session_list | sudo tee -a $logFile; result=$?

    # move the control_window to desktop zero
    # ( don't return 1 over this; drive on)
    log_message_n "moving control_window to desktop 0 ..."
    xdotool set_desktop_for_window ${control_window} 0
    log_handle_result "$?" "move ctrl success!" "failed to move control_window to desktop 0"

    # use xdotool_sizemove_this_window l|L|r|R [<width>%] [<height>%]
    # ( don't return 1 over this; drive on)
    log_message_n "sizemoving control_window"
    run_silent xdotool_sizemove_this_window L "$WINDOW_WIDTH" "$WINDOW_HEIGHT"
    log_handle_result "$?" "sizemove ctrl success!" "failed to resize control_window"

    # get terminal program name (b/c it might not be the same as what this program calls)
    # ( don't return 1 over this; drive on)
    log_message_n "getting control_term"
    control_term=$(xprop -id "$WINDOWID" WM_CLASS | awk -F'"' '{print $4}')
    log_handle_result "$?" "${control_term}" "failed to get control_term"

    # assemble windowname
    # ( don't return 1 over this; drive on)
    log_message_n "assembling windowname"
    windowname="$(hostname)_${control_term}-0.0"
    log_handle_result "$?" "${windowname}" "failed to set windowname"

    # set windowname
    # ( don't return 1 over this; drive on)
    log_message_n "setting windowname"
    xdotool set_window --name "${windowname}" "${control_window}"
    log_handle_result "$?" "set" "failed to set windowname"

    # integer "i" will count the dsktops, on each of which we can put 2 terminals "j", "k"
    # e.g. i=0 (j=0,k=1); i=1 (j=2,k=3); i=2 (j=4,k=5);  i=3 (j=6,k=7)
    for ((i=0; i<${num_desktops}; i++ )); do
        # set desktop
        # ( succeed or return 1 over this; cannot drive on)
        log_message_n "setting desktop [${BMon}${i}${Boff}]"
        xdotool set_desktop "$i"
        log_handle_result "$?" "set i success!" "failed to set desktop [${BMon}${i}${Boff}]" || return 1

        # calculate terminal numbers associated with desktop $i
        j=$((2*$i))  # even (left)
        k=$(($j+1))  # odd (right)
        # the even numbered terminals go on the left
        # Note: return values from setup_terminal --
        # 0 = success -----------------------------> drive on
        # 1 = ping failure (unhealthy:100% loss) --> skip to next iteration in loop
        # 2 = ping critical failure (dead) --------> skip to next iteration in loop
        # 3 = ssh scan nmap failure ---------------> skip to next iteration in loop
        # 4 = terminal open failure ---------------> skip to next iteration in loop
        # 5 = set window name failure -------------> drive on
        # 6 = sizemove failure --------------------> drive on
        # 7 = ssh launch failure ------------------> drive on
        # terminal 0 is reserved for the control_window (no ssh sessions)
        d_log_message "i: [${BRon}${i}${Boff}]; j: [${BMon}${j}${Boff}]; k: [${LBon}${k}${Boff}]" 5
        if [ ! "$j" -eq 0 ] && [ "$j" -lt "$num_ssh_sessions" ] ; then
            # set up terminal $j
            # ( don't just return 1 over this - use returned exit status to figure out what to do
            #   skip to next terminal if no ping/ssh; drive on if no name/sizemove )
            log_message "setting up terminal j: [${BMon}${j}${Boff}] for ssh_target: [${BYon}${ssh_session_list[$j]}${Boff}]"
            setup_terminal "$j" ; result=$?
            log_message_n "resolving setup outcome"
            log_handle_result "$result" "setup j success!" "failed to setup terminal j: [${BMon}${j}${BRon}]"
            result=$?
            if [ ! $result -eq 0 ] ; then
                case $result in
                    1|2|3|4) continue ;;  # skip to next iteration in loop (next terminal/ssh_target)
                    5|6|7  ) log_message "note non-fatal error above. driving on" ;;
                    *      ) log_E_message "invalid exit status returned from setup_terminal for j: [${BMon}${j}${Boff}]"
                esac
            fi
        else
            d_log_message "skipping setup for terminal [${BMon}${j}${Boff}]] (should be 0)" 4
        fi
        sleep $sleepWait
        # the odd numbered terminals go on the right
        if [ ! "$k" -eq 0 ] && [ "$k" -lt "$num_ssh_sessions" ] ; then
            # set up terminal $k
            # ( don't just return 1 over this - use returned exit status to figure out what to do
            #   skip to next terminal if no ping/ssh; drive on if no name/sizemove )
            log_message "setting up terminal k: [${LBon}${k}${Boff}] for ssh_target: [${BYon}${ssh_session_list[$k]}${Boff}]"
            setup_terminal "$k" ; result=$?
            log_message_n "resolving setup outcome"
            log_handle_result "$result" "setup k success!" "failed to setup terminal k: [${LBon}${k}${BRon}]"
            result=$?
            if [ ! $result -eq 0 ] ; then
                case $result in
                    1|2|3|4) continue ;;  # skip to next iteration in loop (next terminal/ssh_target)
                    5|6    ) log_message "note non-fatal error above. driving on" ;;
                    *      ) log_E_message "invalid exit status returned from setup_terminal for k: [${LBon}${k}${Boff}]"
                esac
            fi
        else
            d_log_message "skipping setup for terminal k: [${LBon}${k}${Boff}]] (should be 0)" 4
        fi
        sleep $sleepWait
    done
    # set desktop back to 0
    log_message_n "re-setting desktop 0"
    xdotool set_desktop "0"
    log_handle_result "$?" "re-set 0 success!" "failed to re-set desktop 0"
    log_message_n "activating and re-setting focus to control_window"
    xdotool windowactivate --sync "${control_window}"
    log_handle_result "$?" "re-set ctrl success!" "failed to re-activate control_window"
    return 0
}

is_ready_for_ssh() {
    # man ping(8) EXIT STATUS - If ping does not receive any reply packets at all it will exit with
    # code 1. If a packet count and deadline are both specified, and fewer than count packets are
    # received by the time the deadline has arrived, it will also exit with code 1. On other error
    # it exits with code 2. Otherwise it exits with code 0. This makes it possible to use the exit
    # code to see if a host is alive or not.
    #
    # return 0 if ready, 1 or 2 if no ping, 3 if no ssh
    local target="$1"
    # use ping to see if target is on the network
    # (3 packets; 0.1s interval; wait up to 2s for each)
    log_message_n "${BGon}pinging${Boff} target [${BYon}${target}${Boff}]"
    run_silent ping -c3 -i0.1 -W2 "${target}"
    log_handle_result "$?" "ping!" "failed to ping!" || return $?
    # use nmap to see if target is running ssh server
    #  -n/R (never/always do reverse (rDNS) lookup of hostname -- don't need this)
    #  -T<0-5>: Set timing template (higher is faster) (sets optimized timeouts and parallelism)
    #    but overriding manual settings --host-timeout/--max-rtt-timeout
    #    ok for local, reliable networks; but don't use if that is in question
    #  -Pn (no ping [already did that])
    #  -sV (service version detection - look for "OpenSSH" to be in this)
    #  -p22 (port 22 for ssh)
    #  --host-timeout N (max time (s) to discover/scan a target host; else discard the host and move on)
    #  --max-rtt-timeout Ns max time to wait for response to probe packet; else retransmit the probe
    #    or mark the port as unresponsive; often necessary for stability on slow or lossy networks
    log_message_n "${BGon}nmap${Boff} scanning [${BYon}${target}${Boff}] for ssh service"
#    nmap_output=$(nmap -Pn -sV -p22 "${target}" --host-timeout 10 --max-rtt-timeout 2s)
    nmap_output=$(nmap -n -Pn -sV -p22 "${target}" --host-timeout 2 --max-rtt-timeout 0.25s)
    if [[ "$nmap_output" == *"22/tcp open"* ]] && [[ "$nmap_output" == *"ssh"* ]]; then
        log_handle_result "0" "ssh!" ""
        return 0
    else
        log_handle_result "3" "" "nmap failed to find ssh!"
        return 3
    fi
}

setup_terminal() {
    # conditionally set up a terminal window and ssh session for
    # the ${1}th member of ${ssh_session_list[@]}
    d_log_message "in ${FUNCNAME[0]} with arg(s) [$@]" 5
    # return values:
    # 0 = success
    # 1 = ping failure (not healthy: name resolved but all packets lost)
    # 2 = ping critical failure (not alive: Name or service not known//Network is unreachable)
    # 3 = ssh scan nmap failure
    # 4 = terminal launch failure
    # 5 = set window name failure
    # 6 = sizemove failure
    # 7 = ssh launch failure
    local result=""
    local t="$1"  # terminal number
    ssh_target="${ssh_session_list[$t]}"
    # if the ssh_target name begins "x_" we ignore it,
    # (that desktop area is intended to be blank - no window)
    if [[ ! "${ssh_target}" == "x_"* ]] ; then
        # check if the remote ssh target is available before bothering to open this window
        is_ready_for_ssh "${ssh_target}" ; result=$?
        [ ! $result -eq 0 ] && return $result

        # take a baseline for comparison so we can find the new window for certain
        terminal_class="$(basename ${terminal_program})"
        before=($(xdotool search --class "${terminal_class}"))
#        # launch a new terminal with an ssh session as needed
#        log_message_n "openning terminal t: [${BMon}${t}${Boff}] and ssh to [${BYon}${ssh_target}${Boff}]"
#        run_silent "${terminal_program}" -e ssh "${ssh_target}" &
#        log_handle_result "$?" "launched" "failed to launch ssh" || return 4
        # launch a new terminal (for ssh ssh session to be openned below)
        log_message_n "openning terminal t: [${BMon}${t}${Boff}]"
        run_silent "${terminal_program}" &
        log_handle_result "$?" "opened" "failed to open ${terminal_program}" || return 4
        sleep $sleepWait
        newterm=$(poll_for_new_window)
        if  [ ! -z "$newterm" ] ; then
            log_message_n "setting window name for [${BYon}${ssh_target}${Boff}]"
            windowname="${ssh_target}_$(basename ${terminal_program})-${i}.${t}" && \
            xdotool set_window --name "$(hostname) $(basename ${terminal_program})_${i}.${t}" "${newterm}"
            log_handle_result "$?" "${windowname}" "failed to set windowname" || return 5
            log_message "opened new terminal for ${BYon}${ssh_target}${Boff} on desktop [${BMon}${i}${Boff}]"
            # sizemove this windw
            log_message_n "resizing window [${BMon}${t}${Boff}]"
            if [ $(($t % 2)) -eq 0 ] ; then
                # even (Left)
                run_silent xdotool_sizemove_this_window L "$WINDOW_WIDTH" "$WINDOW_HEIGHT"; result=$?
            else
                # odd (Right)
                run_silent xdotool_sizemove_this_window R "$WINDOW_WIDTH" "$WINDOW_HEIGHT" ; result=$?
            fi # even/odd
            log_handle_result "$result" "sizemove t success!" "failed to resize window t: [${BMon}${t}${BRon}]" || return 6
            sleep $sleepWait
        else
            log_E_message "failed to get new window ID within time limit"
        fi # nonzero newterm
        # now open an ssh session
        log_message_n "now openning ssh session to [${ssh_target}]"
        run_silent xdotool type "ssh ${ssh_target}" && \
            run_silent xdotool key Return
        log_handle_result "$?" "launched" "failed to launch ssh for target [${ssh_target}]" || return 7
    else
        log_message "${BRon}not${Boff} openning a terminal for (${BMon}blank${Boff}) [${BYon}${ssh_target}${Boff}]"
    fi # non x_ (blank) ssh_target
    return 0
}

poll_for_new_window() {
    # (rathern than using newterm=$(xdotool getactivewindow 2>/dev/null)
    # which is unreliable due to succeptibility to race condition)
    # USE: run before=($(xdotool search --class ${}terminal_program))
    # then launch a new terminal,
    # then run this function to wait until the new window is accessible
    local -a after
    local new_wid=""
    local elapsed=0
    while [[ -z "$new_wid" && "$elapsed" < "$timeout" ]]; do
        after=($(xdotool search --class "${terminal_class}" ))
        for wid in "${after[@]}"; do
            is_new=true
            for old_wid in "${before[@]}"; do
                if [[ "$wid" == "$old_wid" ]]; then
                    is_new=false
                    break
                fi
            done
            if [[ "$is_new" == true ]]; then
                new_wid="$wid"
                break 2  # Break out of both inner and outer loops
            fi
        done
        sleep 0.2
        elapsed=$(echo "$elapsed + 0.2" | bc)
    done

    echo "$new_wid"
    [[ -z "$new_wid" ]] && return 1 || return 0
}

poll_for_num_desktops() {
    # to give a prior set_num_desktops command to complete,
    # but rather than relying on an arbitarary sleep delay,
    # this is to an explicit check to verify its completion
    # Note: using bc -l for floating point math, and ${elapsed:-0}
    # just in case it gets unset
    local elapsed=0
    while [[ ! $num_desktops -eq $numdesktops && "$( echo "$elapsed <= $timeout" | bc -l )" -eq 1 ]] ; do
        d_log_message "elapsed: [${LBon}$elapsed${Boff}] num_desktops: [${BMon}$num_desktops${Boff}] numdesktops: [${BGon}$numdesktops${Boff}]" 2
        sleep $sleepWait
        elapsed=$(echo "scale=2; ( ${elasped:-0} + $sleepWait )" | bc -l )
        d_log_message_n "checking num_desktops" 2
        num_desktops=$(xdotool get_num_desktops)
        log_handle_result "$?" "${num_desktops}" "${num_desktops}"  # don't return 1 for failure
    done
    # return 1 if this timed out
    if [ $num_desktops -eq $numdesktops ] ; then
        return 0
    else
        log_E_message "timed out while waiting for num_desktops to match numdesktops"
        return 1
    fi
}

run_silent() {
    # facilitate dynamic redirection in silencing output
    local _result=""
#    local old_verbosity=$verbosity
    # The "$@" safely passes all arguments to the command
#    verbosity=0 "$@" >/dev/null 2>&1
    "$@" >/dev/null 2>&1
    _result=$?
#    verbosity=$old_verbosity
    return $_result
}

#-----[ main script ]-----------------------------------------------------
d_message "now in main script" 3
message_n "checking not root ..."
checknotroot && right_status $? || die "failed checknotroot"
validate_logfile || die "failed to validate logfile"

log_separator "$(hostname)" "${PN}-${BUILD}"
log_message "starting script"

# identify the control window (used to activate this program)
log_message_n "Getting ID of current (control) window"
control_window=$(xdotool getactivewindow)
log_handle_result "$?" "${control_window}" "failed to id control_window" || exit 1

# identify the current desktop and log_message "starting script"
current_desktop=$(xdotool get_desktop_for_window "${control_window}")
log_message "current_desktop: ${current_desktop}"
num_desktops=$(xdotool get_num_desktops)
log_message "num_desktops: $num_desktops"

# run sequence
set_terminal_window_dimensions || die "failed to set_terminal_window_dimensions"
setup_desktops || die "failed to setup_desktops"
show_config || die "failed to show_config"
open_windows || die "failed to open_windows"

d_log_message "${BGon}Done${Boff}" 1

#d_message "${BMon}Debug Marker${Boff}" 3 ; exit 1
