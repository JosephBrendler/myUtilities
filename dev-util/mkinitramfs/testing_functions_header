#!/bin/ash

### -----[ duplicated functions ]--------------------------------------------------------------
### These scripts exist in both "validated_" and "testing_" headers but have been modified in each
### In the live init script, source the "testing_" header first and "validated_" header second
### In the testing script, source "validated_" header first and the "testing_" header second
### The later-sourced will override, and this avoid having the "testing" script mess with
###    non-testing luks devices on a testing host system
assign_volume() {
    ret=0
    # given string volume name (root_ usr_volume), scan lvs and make volume pathname assignment
    _av_volume_name=$1
#    _av_prefix="${_av_volume_name/_volume}"     # e.g. assign root, from root_volume (bash substitution)
    _av_prefix="${_av_volume_name%_volume}"     # e.g. assign root, from root_volume (POSIX strip from end)
    eval "_av_volume=\"\$${_av_volume_name}\""
    if [ -z "${_av_volume}" ] ; then
#        notice_msg "about to evaluate ${_av_prefix}_volume=/dev/mapper/$(lvs | grep ${_av_prefix} | awk '{print $2"-"$1}')"
#        notice_msg_n "${_av_prefix} _av_volume_name not assigned, scanning ..."
#        _av_volume="/dev/mapper/$(lvs | grep ${_av_prefix} | awk '{print $2"-"$1}')"
### substitute for testing only (ver 10.0+ changed from deselecting gmki91 to SELECTING test device)
        notice_msg "about to evaluate ${_av_prefix}_volume=/dev/mapper/$(lvs | grep 'rock5bplus6401' | grep ${_av_prefix} | awk '{print $2"-"$1}')"
        notice_msg_n "${_av_prefix} _av_volume_name not assigned, scanning ..."
        _av_volume="/dev/mapper/$(lvs | grep 'rock5bplus6401' | grep $_av_prefix | awk '{print $2"-"$1}')"
        eval "${_av_prefix}_volume=$_av_volume"
        ret=$?
        handle_result $ret "$_av_volume" "failed to assign _av_volume"
    else
        notice_msg "No action. ${_av_prefix} volume already assigned [$_av_volume]"
    fi
    unset -v _av_prefix _av_volume_name _av_volume
    return $ret
}

### ----[ end duplicated functions ]--------------------------------------------------------------------------------------------------------------

mount_and_test_new_root() {
    ret=0
    separator "${PN}-${BUILD}" "(Mounting new root for testing ...)"
    # previous version re-scanned here, but that now occurs after unlock
    # note: script_header_joetoo v0.2.0+ changed arg sequence for color()
    # color() - $1: FG code (30-37, 39); $2: Bold (0/1); $3: BG code (40-47, 49
    notice_msg "$(color ${RED} ${BOLD} ${BBACK})running fsck.${root_fs} on $root_volume${Boff}"
    "fsck.${root_fs}" -p "$root_volume"
    notice_msg "$(color ${RED} ${BOLD} ${BBACK})running fsck.${usr_fs} on $usr_volume${Boff}"
    "fsck.${usr_fs}" -p "$usr_volume"
    # give more time to read display if debugging
    [ ! "$QUIET" ] && d_do verbosity=7 sh_countdown '$init_wait' "$debug"
    # mount root - drop to shell if not locked down
    notice_msg_n "Mounting new root volume ..."
    mount -r -t "${root_fs}" "${root_volume}" "${init_ROOT%/}/newroot" 2>/dev/null ; _mnr_result=$?
    handle_result "$_mnr_result" '' "failed to mount root volume"
    notice_msg_n "Mounting new usr volume ..."
    mount -t "${usr_fs}" -o defaults,noatime "$usr_volume" "${init_ROOT%/}/newroot/usr" ; _mnr_result=$?
    handle_result "$_mnr_result" '' "failed to mount usr volume"

    separator "${PN}-${BUILD}" "(Mounts)"
    mount | sed 's|^|    |'

    unset -v _mnr_result
    return $ret
}

teststringlength() {
    str="$1"
    echo_msg "str: ${str}"
    echo_msg_n "1: "; [ ! -z $str ] && echo_msg "non-zero" || echo_msg "zero"
    echo_msg_n "2: "; [ ${#str} -gt 0 ] && echo_msg "-gt zero" || echo_msg "zero"
    echo_msg_n "3: "; [[ ! -z $str ]] && echo_msg "non-zero" || echo_msg "zero"
    echo_msg_n "4: "; [[ ${#str} -gt 0 ]] && echo_msg "-gt zero" || echo_msg "zero"
    echo_msg_n "5: "; [[ ${#str} -ne 0 ]] && echo_msg "-ne zero" || echo_msg "zero"
    echo_msg_n "6: "; [[ ${#str} -eq 0 ]]  && echo_msg "-eq zero" || echo_msg "not -eq zero"
    echo_msg_n "7: "; [[ ! ${#str} -eq 0 ]]  && echo_msg "not -eq zero" || echo_msg "-eq zero"
    echo_msg_n "8: "; [[ -n ${str} ]]  && echo_msg "-n zero" || echo_msg "zero"
}

