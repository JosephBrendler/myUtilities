#!/bin/sh

#  From dev-util/mkinitramfs/scratch run: ./init.test (as root)
# ---[ end of test procedure ]--------------------------------------------------------

# make my usual functions and formatting utilities available
#init_ROOT="/"   # real system
init_ROOT="/home/joe/myUtilities/dev-util/mkinitramfs/scratch/initramfs/"   # substitute for testing only

printf '%s' "sourcing /script_header_joetoo ..."
. "${init_ROOT%/}/script_header_joetoo"
handle_result $? || die "failed to source /script_header_joetoo"
sleep .5

# source the BUILD number generated by the make_sources.sh script,
d_message_n "sourcing /BUILD ..." 1
. "${init_ROOT%/}/BUILD"
d_handle_result $? 1 || die "failed to source /BUILD"
sleep .5

PN="initramfs: $(basename "$0")"

#----[ initialize additional global variables ]--------------------------------------------------
separator "${PN}-${BUILD}" "(initializing)"

# initialize these variables to '' to establish them as globals
#   remember '' evaluates as $FALSE in logical test
varlist="
  init_mdev_wait
  init_wait
  init_keyfile
  unlock_method
  lv.init_passdevice_list
  init_passdevice_mount_point
  bool.init_lock_down
  root_volume
  root_fs
  usr_volume
  usr_fs
  lv.CMDLINE
  verbosity
  init_config_title
"
# PATH -- display, don't initialize

initialize_vars
# set default verbosity if it is not externally set
#  just in case neither in init.conf nor cmdline does it
[ -z "$verbosity" ] && verbosity=2

#----[ reassign variables with values from config files ]----------------------------------

# source variables assigned in init.conf. Note cmdline may override root=, usr=, verbosity=
d_message_n "sourcing /init.conf ..." 1
. "${init_ROOT%/}/init.conf"
d_handle_result $? 1 || die "failed to source /init.conf"
sleep .5
[ ! -z "${init_root_volume}" ] && root_volume="${init_root_volume}"
[ ! -z "${init_usr_volume}" ]  && usr_volume="${init_usr_volume}"
! isint "${init_wait}" && init_wait=1  # hard code default 1 second
! isint "${init_mdev_wait}" && init_wait=3  # hard code default 3 seconds
printf "\n"

#----[ display separator to mark start of script ]-----------------------------------------------
separator "${PN}-${BUILD}" "(Running /init)"

#----[ source functions local to initramfs ]-----------------------------------------------------

# note: in the real init script, we MUST source validated_functions_header second, in order to
#   override testing-only-modified functions also present in testing_functions_header
#   (in the testing init script (ash.temp) it is the other way around)
d_message_n "sourcing /validated_functions_header ..." 1
. "${init_ROOT%/}/validated_functions_header"
d_handle_result $? 1 || die "failed to source /validated_functions_header"

### *** for testing, when ready, move still-testing functions to validated_functions_header **---
d_message_n "sourcing /testing_functions_header ..." 1
. "${init_ROOT%/}/testing_functions_header"
d_handle_result $? 1 || die "failed to source /testing_functions_header"

# construct a wrappable string to represent PATH (translate : to ' ')
PATH_str=$(printf '%s' "$PATH" | tr ':' ' ')
# display initial config of variables available
# (must source display_config function first)
varlist="
  BUILD
  init_mdev_wait
  init_wait
  init_keyfile
  init_passdevice_mount_point
  bool.init_lock_down
  root_volume
  usr_volume
  verbosity
  lv.init_passdevice_list
  lv.PATH_str
"
# these below are not available yet
#unlock_method \
#root_fs \
#usr_fs \
#CMDLINE \
# PATH -- display, don't initialize
message "Initial Configuration follows ..."
show_config

#----[ Define functions local to initramfs ]-----------------------------------------------------

rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    printf "\n"
    separator "${PN}-${BUILD}" "(${1} - Dropping to a shell...)"
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
    exec "$(which sh)";
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # external variables: init_wait
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    # the kernel needs these virtual file systems to report hardware status
    message_n "mounting /proc"
    mount -t proc proc /proc
    handle_result $? || die "failed to mount /proc"

    message_n "mounting devtmpfs"
    mount -t devtmpfs none /dev
    handle_result $? || die "failed to mount devtmpfs"

    message_n "mounting sysfs"
    mount -t sysfs sysfs /sys
    handle_result $? || die "failed to mount sysfs"

    # with mounts above in place, immediately instruct kernel to execute mdev
    #   whenever a device is added or removed --
    #     $(which mdev): Finds the full path to the mdev binary
    #     kernel.hotplug: tells the system which program to run whenever a hardware event occurs
    #     sysctl -w: writes the path of mdev into the kernel's configuration at /proc/sys/kernel/hotplug
    #   note: which is built into this initramfs' busybox
    sysctl -w kernel.hotplug=$(which mdev)

    # seed /dev/ with all the device nodes that were created --
    #   mdev -s is called a "coldplug" scan (handles devices discovered via past events),
    #   whereas the "kernel.hotplug" line above is instructions for future events
    mdev -s

    # I used to just pause so kernel could finish identifying devices
    message "\n${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}"
    # sh_countdown $(( ${init_wait} * 3 ))
    # instead of sleeping for "magic" amount of time, use a
    # system-agnostic wait for block device population to settle down
    _min_count=2   # there are 2 header lines in /proc/partitions
    _last_count=0
    _curr_count=$(wc -l < /proc/partitions)
    _retry=0; _max_retry=10 # prevent hardware fault from bricking the boot sequence

    # while [nothing yet] OR [still counting]; do
    while [ "$_curr_count" -lt "$_min_count" ] || [ "$_curr_count" -ne "$_last_count" ]; do
        _last_count=$_curr_count
        sleep ${init_wait}
        mdev -s  # Refresh nodes
        _curr_count=$(wc -l < /proc/partitions)
        _retry=$((_retry + 1))
        [ "$_retry" -gt "$_max_retry" ] && break # Safety timeout
    done

    # note, some complex devices (like LVM) might need a second scan after modules are loaded
    #   (we will do that later)

    # secondary mounts occur after main dev population
    message_n "looking for /dev/pts"
    if [ ! -d /dev/pts ]; then
        mkdir /dev/pts || die "failed to mkdir /dev/pts"
        printf '%s' " (${Gon}created${Boff})"
    else
        printf '%s' " (${Gon}found${Boff})"
    fi
    handle_result $? || die "failed to find/create /dev/pts"
    message_n "mounting /dev/pts"
    mount -t devpts devpts /dev/pts
    handle_result $? || die "failed to mount devpts"

    unset -v _min_count _last_count _curr_count _retry _max_retry
    return 0

}

maybe_redirect_output() # if /dev/console is writable, deliberately redirect output there
{
  # (1) /dev/console is created by mksources ( mknod -m 600 console c 5 1 ), and even if not,
  # then now that /dev is populated by mini_udev, the device node should exist [ -c test ].
  # However - that doesn't guarantee that the kernel will have loaded drivers capable of using it
  # (serial/VGA for example), so we need to check the devices "writability" [ -w test ], to be sure
  # implement a bounded wait here, incase it hasn't happened "yet"
  # note: -w implies -c so don't need to check both
  ret=0
  _init_shortwait="0.1"
  _init_console_retry=0; _init_max_retry=20    # max wait 2 seconds total
  while [ ! -w /dev/console ] && [ "$_init_console_retry" -lt "$_init_max_retry" ]; do
    sleep "$_init_shortwait"
    _init_console_retry=$((_init_console_retry + 1))
  done
  if [ -w /dev/console ]; then
    exec > /dev/console 2>&1
    # Subsequent messages now appear on the actual boot console
    message "Standard and Error output redirected to /dev/console"
  else
    # if -c passes but -w fails, the node exists but the device is not ready for output
    echo "Warning: /dev/console exists but is not writable. Redirection skipped." >&2
  fi
  unset -v _init_console_retry _init_shortwait _init_max_retry
  return $ret
}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
#message "Waiting for normal trailing kernel output ..."
#sh_countdown $((${init_wait} * 5))
# above should no longer be needed, with agnositc wait in mini_udev function

# start mini-udev (mdev) and wait long enough for devices to be recognized
message "(not) Starting mini udev ..."
#mini_udev   #### commented out for testing purposes only
result=$?
message_n "mini_udev result: "
handle_result "$result" "mini_udev hotplug and coldplug started" "mdev failed to start" || die "mini_udev failed"

# if /dev/console is writable, deliberately redirect output there
#maybe_redirect_output    #### commented out for testing purposes only

# now converting this dumb wait to a targeted wait (if needed) when getting keying dev
#&& sh_countdown $(($init_mdev_wait))

# safely assing CMDLINE
if [ -f /proc/cmdline ]; then
#    CMDLINE="$(cat /proc/cmdline)"
# substitute below for testing only
    CMDLINE="BOOT_IMAGE=/vmlinuz-6.12.63-gentoo-dist-hardened-joetoo"
    CMDLINE+=" root=/dev/mapper/vg_rock5bplus6401-root ro verbosity=5"
    CMDLINE+=" usr=/dev/mapper/vg_rock5bplus6401-usr net.ifnames=0"
else
    CMDLINE=""     # Fallback or error for non-Linux systems (BSD, macOS, etc.)
fi

process_cmdline

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

# call get_keyfile_and_unlock_method to assign unlock_method and keyfile
get_keyfile_and_unlock_method || die "failed to get_keyfile_and_unlock_method"

# echo to console to confirm attempt to unlock HDs
separator "${PN}-${BUILD}" "(Unlocking encrypted Drive(s))"
# call function to unlock HD(s)
d_message "calling unlock_devices \"${unlock_method}\"" 3
unlock_devices "${unlock_method}" || die "failed to unlock_devices"

# done with all luks devices; ok to un-mount keying device now
if [ -b "${init_passdevice_mount_point}" ]; then
    message_n "Un-mounting keying device ..."
    umount "${init_passdevice_mount_point}" 2>/dev/null
    handle_result $?
fi

# make lvm logical volumes available
vgscan
vgchange -a y

# assign root and usr volume names (if not already done)
# (build in safe wait-loop to ensure lvm device mapper
#  populates the nodes and mdev has time to recognize
#  and create the rest of the /dev/ structure needed)
separator "${PN}-${BUILD}" "(assign/validate root, usr vols)"
TIMEOUT=20 # Max wait of 10 seconds total (20 * 0.5s checks)
while [ "$TIMEOUT" -gt 0 ]; do
    # Try to assign the volume name - redirect output for cleaner waiting dots
#    if assign_volume "root_volume" >/dev/null ; then
    if assign_volume "root_volume" ; then
      # if assignment succeeded, and it is a real blockdev, we are done!
      if [ -b "$root_volume" ]; then break; fi
    fi
#    printf '%s' "."
    sleep 0.5
    TIMEOUT=$((TIMEOUT - 1))
done
printf '\n' # add newline to the line of dots
# check if it completed or timed out
if [ ! -b "$root_volume" ]; then
    die "timed out waiting for LVM root_volume [$root_volume]; cannot proceed"
fi
assign_volume "usr_volume"

# assign root and usr volume names (if not already done)
separator "${PN}-${BUILD}" "(assign/validate root, usr vols)"
assign_volume "root_volume"
assign_volume "usr_volume"

# validate root and usr device and assign fs
#  cannot do this until after the volume is unlocked and the volume is assigned
#  need to pass string name arg so function can make fs assignment
validate_volume_and_assign_fs "root_volume"
validate_volume_and_assign_fs "usr_volume"

# display config - after volumes uinlocked and root/usr fs obtained
varlist="
  BUILD
  init_mdev_wait
  init_wait
  unlock_method
  init_keyfile
  init_passdevice_mount_point
  init_lock_down
  luks_partition_device
  root_volume
  root_fs
  usr_volume
  usr_fs
  verbosity
  lv.init_passdevice_list
  lv.CMDLINE
  lv.PATH
"
# PATH -- display, don't initialize
message "Mature Configuration follows ..."
show_config

d_do sh_countdown $(( $init_wait * 3 )) 4

# access the root and usr logical volumes (among others), and show what we unlocke
display_logical_volumes || E_message "error running display_logical_volumes"

# mount_new_root_and_prepare_to_switch_root
#mount_new_root_and_prepare_to_switch_root || die "failed to mount_new_root_and_prepare_to_switch_root"
# substitute below for testing only
mount_and_test_new_root || die "failed to mount_and_test_new_root"

separator "${PN}-${BUILD}" "(NOT Switching to /newroot, mounted on encrypted volume [${root_volume}])"
d_message "  -  Will (not) continue with /sbin/init" 1
[ ! -z "${CMDLINE}" ] && d_message "  - (not) using cmdline: ${CMDLINE}" 1
echo

# all below commented out for testing purposes only
## boot the real thing or exit to rescue shell if not locked down
#exec $(which busybox) switch_root /newroot /sbin/init ${CMDLINE} || \
#    { E_message "failed to mount root volume" ; [ ! ${init_lock_down} ] && rescue_shell "Failed to pivot root" ; }
#
#message "General failure, shutting down for security reasons"
#sh_countdown $(($init_wait * 3))
#shutdown -hP now
