#!/bin/bash

create_links()
{ local _cl_ret=0
  local _cl_x="" _cl_old_pwd="$PWD"
  local i _cl_link _cl_bin _cl_target _cl_target_dir _cl_msg _cl_fileline
  local _cl_element _cl_type _cl_depth _cl_tgtname _cl_temp

  # create busybox symlinks
  notice_msg "Creating busybox links ..."
  # find w -print -quit to output 1st find to stdout and stop after first match (for performance)
  info_msg_n "looking for busybox"
  _cl_target=$(find "${SOURCES_DIR}" -name 'busybox' -print -quit)
  info_handle_result $? "found" "not found" || die "busybox not found"
  _cl_target_dir="${_cl_target%/*}"     # dirname
  info_msg_n "moving to $_cl_target_dir"
  cd "$_cl_target_dir"
  info_handle_result $? "ok" "failed" 1 || die "failed to cd $_cl_target_dir"
  # 20260126 - swtchec from string word list to bash array
  for _cl_link in "${busybox_link_list[@]}"; do
     info_msg_n "Linking:   ${LBon}${_cl_link}${Boff} --> ${BGon}busybox${Boff} ..."
     # symlink (-s) and force (-f) so any restart wont error out on things already done
     ln -snf busybox "$_cl_link" 2>/dev/null
     info_right_status $? || _cl_ret=$(( _cl_ret | ( 1 << 0 ) ))
  done
  notice_msg_n "Done creating busybox links"
  handle_result $_cl_ret "" "failed with bitmask status [$(( _cl_ret ^ 1 ))]" # bit 1

  # create lvm2 symlinks
  notice_msg "Creating lvm2 links ..."
  # filter out /etc/lvm to find the actual binary (take only the first)
  info_msg_n "looking for lvm"
  _cl_target=$(find "${SOURCES_DIR}" -name 'lvm' | grep -v '/etc'| head -n 1)
  info_handle_result $? "found" "not found" || die "lvm not found"
  _cl_target_dir=$(dirname "$_cl_target")
  info_msg_n "moving to $_cl_target_dir"
  cd "$_cl_target_dir"
  info_handle_result $? "ok" "failed" 1 || die "failed to cd $_cl_target_dir"
  for _cl_link in "${lvm_link_list[@]}"; do
    info_msg_n "Linking:   ${LBon}$_cl_link${Boff} --> ${BGon}lvm${Boff} ..."
    ln -snf lvm "$_cl_link" 2>/dev/null; info_right_status $? || \
       _cl_ret=$(( _cl_ret | ( 1 << 1 ) ))
  done
  notice_msg_n "Done creating lvm2 links"
  handle_result $_cl_ret "" "failed with bitmask status [$(( _cl_ret ^ 2 ))]" # bit 2

  # create links to other executables in associated dirs, using array set
  # and standard for loop to maintain index alignment
  notice_msg "Creating [${#other_link_name[@]}] additional links ..."
  for ((i=0; i<${#other_link_name[@]}; i++)); do
    info_msg_n "moving to ${SOURCES_DIR%/}/${other_link_dir[i]#/}"
    cd "${SOURCES_DIR%/}/${other_link_dir[i]#/}"
    info_handle_result $? "ok" "failed" || die "failed to cd ${SOURCES_DIR%/}/${other_link_dir[i]#/}"
    _cl_msg+="Linking:   ${BBon}[${other_link_dir[i]}] ${LBon}${other_link_name[i]}${Boff}"
    _cl_msg+=" --> ${BGon}${other_link_target[i]}${Boff} ..."
    info_msg_n "$_cl_msg"
    ln -snf "${other_link_target[i]}"  "${other_link_name[i]}"
    info_handle_result $? "ok" "failed" || die "failed to ln -sf ${other_link_target[i]} ${other_link_name[i]}" 
  done
  info_msg_n "moving to $_cl_old_pwd"
  cd "$_cl_old_pwd"
  info_handle_result $? "ok" "failed" || die "failed to cd $_cl_old_pwd"
  # create links for init in each bin directory (that is actually a directory)
  set -- $bins
  for _cl_bin; do
    # use file. e.g. file /usr/sbin might return "/usr/sbin: symbolic link to bin"
    _cl_fileline=$(file "$_cl_bin")
#    _cl_element=$(echo $_cl_fileline | awk '{print $1}' | sed 's|:$||')
#    _cl_type=$(echo $_cl_fileline | awk '{print $2}')
    # extract _cl_element (like /usr/bin) and _cl_type (like "symbolic"); _ is junk var for the rest of the line
    read -r _cl_element _cl_type _ <<< "$_cl_fileline"
    _cl_element="${_cl_element%:}" # remove the trailing colon
    # figure out where the _cl_element is relative to the taarget and formulate the link target name
    #   since init is located at / of ${SOURCES_DIR/, _cl_depth is the number of "/" chars in _cl_element
    # grep -o '/' only returns the part matching / and | grep -c . counts them
    # this determines how many '..' to put in front of / for the relative path to /init
#    _cl_depth=$(grep -o '/' <<< "$_cl_element" | grep -c .)
    # this also counts the slashes, but w/o leaving the shell w grep;
    # bash: in ${var//pattern/string}, // is global substitution (repl patt w str); ^ means "not"
    # so it replaces everything that is not / with nothing; the second cmd counts the / chars left
    _cl_temp="${_cl_element//[^\/]/}"; _cl_depth="${#_cl_temp}"
#    for ((i=0; i<$_cl_depth; i++)); do _cl_tgtname="${_cl_tgtname}../"; done
    # use full_repeat() to create the relative path
    _cl_tgtname=$(full_repeat '../' "$_cl_depth")
    _cl_tgtname="${_cl_tgtname}init"
    # we only need to create a link in the location that is actually a directory
    # other bin dirs that are symlinked to the dir pick it up automatically
    case "$_cl_type" in
      "directory" )
        _cl_msg="in directory ${BBon}$_cl_element${Boff}, creating link"
        _cl_msg+=" ${BCon}$_cl_tgtname${Boff} --> ${BGon}/init${Boff} ..."
        cd "${SOURCES_DIR%/}/${_cl_element#/}"
        info_msg_n "$_cl_msg"
        ln -s  "${_cl_tgtname}" init 2>/dev/null
        info_right_status $? || _cl_ret=$(( _cl_ret | ( 1 << 2 ) ))
        ;;
      * )
        debug_msg "init link not needed for ${_cl_element}, which is itself a ${_cl_type} link"
        # this is not an error
        ;;
    esac
  done
  cd "$_cl_old_pwd"
  notice_msg_n "Done creating [${#other_link_name[@]}] additional links"
  handle_result $_cl_ret "" "failed with exit code [$_cl_ret]"
  debug_msg "bit 0 (busybox) .... status: [$(( ( _cl_ret >> 0 ) & 1 ))]"
  debug_msg "bit 1 (lvm) ........ status: [$(( ( _cl_ret >> 1 ) & 1 ))]"
  debug_msg "bit 2 (init bins) .. status: [$(( ( _cl_ret >> 2 ) & 1 ))]"
  return $_cl_ret
}
# @usage create_links
# @vars
# @note create symlinks in initramfs structure for busybox, lvm2, and others as needed
# @note bitmask result status bit 0: busybox, 1: lvm, 2: bins

copy_other_parts()
{ 
  local _cops_ret=0
  notice_msg "Copying other parts ..."
  info_msg "Copying init ..."
  copy_one_part "${MAKE_DIR%/}/init" "${SOURCES_DIR%/}/"
  [[ $? -eq 0 ]] || _cops_ret=$(( _cops_ret | ( 1 << 0 ) ))

  # copy config file
  info_msg "Copying init.conf ..."
  copy_one_part "${config_file}" "${SOURCES_DIR%/}/"
  [[ $? -eq 0 ]] || _cops_ret=$(( _cops_ret | ( 1 << 1 ) ))

  # copy admin files
  info_msg "Copying necessary admin files..."
#  for i in $admin_files
  for ((i=0; i<${#admin_files[@]}; i++))
  do copy_one_part "${MAKE_DIR%/}/${admin_files[i]#/}" "${SOURCES_DIR%/}/"; done
  [[ $? -eq 0 ]] || _cops_ret=$(( _cops_ret | ( 1 << 2 ) ))

  # copy function_header content
  info_msg "Copying function headers content ..."
  for ((i=0; i<${#function_headers_src[@]}; i++))
  do copy_one_part "${function_headers_src[i]}" "${function_headers_dest[i]}"; done
  [[ $? -eq 0 ]] || _cops_ret=$(( _cops_ret | ( 1 << 3 ) ))
  # copy other required content
  info_msg "Copying other required content ..."
  for ((i=0; i<${#other_content_src[@]}; i++))
  do copy_one_part "${other_content_src[i]}" "${other_content_dest[i]}"; done
  [[ $? -eq 0 ]] ||  _cops_ret=$(( _cops_ret | ( 1 << 4 ) ))
  notice_msg_n "Done Copying other parts"
  handle_result $_cops_ret "" "failed with exit code [$_cops_ret]"
  debug_msg "bit 0 (init) .............. status: [$(( ( _cops_ret >> 0 ) & 1 ))]"
  debug_msg "bit 1 (init.conf) ......... status: [$(( ( _cops_ret >> 1 ) & 1 ))]"
  debug_msg "bit 2 (admin_files) ....... status: [$(( ( _cops_ret >> 2 ) & 1 ))]"
  debug_msg "bit 3 (function_headers) .. status: [$(( ( _cops_ret >> 3 ) & 1 ))]"
  debug_msg "bit 4 (other_content) ..... status: [$(( ( _cops_ret >> 4 ) & 1 ))]"
  return $_cops_ret
}
# @usage copy_other_parts
# @args none
# @note copies init, init.conf, admin files, headers, and other content
# @note bitmask result status bit 0: init, 1: init.conf, 2: admin_files, 3: function_headers, 4: other_content

copy_dependencies()
{
  notice_msg "Copying dependencies ..."
  local _cd_msg _cd_x _cd_selector _cd_searched_file _cd_missing_file _cd_target_name _cd_dir_name
  local _cd_ret=0
  # use the --copy-to-tree feature of lddtree to copy all dependent files to ${SOURCES_DIR%/}/
  # use the --copy-non-elfs feature of lddtree tp copy non-ELF files (e.g. fsadm, lvmdump scripts)
  for _cd_x in "${executables[@]}"; do
    if [ "$verbosity" -ge "$info" ]; then
      lddtree -v "${_cd_x}" --copy-to-tree "${SOURCES_DIR%/}/" --copy-non-elfs
    else
      info_msg "using lddtree to copy dependencies directly to initramfs tree"
      lddtree -v "${_cd_x}" --copy-to-tree "${SOURCES_DIR%/}/" --copy-non-elfs >/dev/null 2>&1
      case $? in
        0 ) info_handle_result 0 ;;
        * ) info_handle_result $? "" "lddtree failed "
            _cd_ret=$(( _cd_ret | ( 1 << 0 ) )) ;;
      esac
    fi
  done

  # address rare issue with error "libgcc_s.so.1 must be installed for pthread_cancel to work"
  # occurs when cryptsetup tries to open LUKS volume - see references (similar but different) --
  #   https://bugs.gentoo.org/760249 (resolved by fix to dracut)
  #   https://forums.gentoo.org/viewtopic-t-1096804-start-0.html (zfs problem. fix: copy file to initramfs)
  #   https://forums.gentoo.org/viewtopic-t-1049468-start-0.html (also zfs problem. same fix)
  # at least for now, I'm using the same fix here --

  # ( if needed, find and copy the missing file to /lib64/libgcc_s.so.1
  #   - then copy it to ${SOURCES_DIR}. Note: in this initramfs, /lib64 is a symlink to /lib )
  if [[ ! -e /lib64/libgcc_s.so.1 ]]
  then
    _cd_selector=$(gcc -v 2>&1 | grep Target | cut -d' ' -f2)
    # ensure we don't accidentally grab a 32-bit compatibility library for your 64-bit initramfs
    _cd_searched_file="$( find /usr/ -iname libgcc_s.so.1 2>/dev/null | grep -v 32 | grep ${_cd_selector})"
    cp -v "${_cd_searched_file}" /lib64/libgcc_s.so.1 || _cd_ret=$(( _cd_ret | ( 1 << 1 ) ))
  fi
  _cd_missing_file=/lib64/libgcc_s.so.1
  _cd_target_name="${_cd_missing_file##*/}"  # basename
  _cd_dir_name="${_cd_missing_file%/*}"      # dirname

  _cd_msg="  about to copy missing file [ ${_cd_missing_file} ]"
  _cd_msg+=" to ${SOURCES_DIR%/}/${_cd_dir_name#/}/$_cd_target_name "
  info_msg "$_cd_msg"
  if [[ ! -e "${SOURCES_DIR%/}/${_cd_dir_name#/}/${_cd_target_name}" ]]; then
    copy_one_part "${_cd_dir_name}/${_cd_target_name}" "${SOURCES_DIR%/}/${_cd_dir_name#/}/"
    info_msg_n "setting permission with chmod 755"
    chmod 755 "${SOURCES_DIR%/}/${_cd_dir_name#/}/${_cd_target_name}"
    info_handle_result $?  || _cd_ret=$(( _cd_ret | ( 1 << 2 ) ))
  else
    info_msg "missing file: ${_cd_missing_file} already exists in ${SOURCES_DIR}"
  fi
  notice_msg_n "Done copying dependencies"
  handle_result $_cd_ret "" "failed with exit code [$_cd_ret]"
  debug_msg "bit 0 (lddtree) ....... status: [$(( ( _cd_ret >> 0 ) & 1 ))]"
  debug_msg "bit 1 (missing file) .. status: [$(( ( _cd_ret >> 1 ) & 1 ))]"
  debug_msg "bit 2 (mode error) .... status: [$(( ( _cd_ret >> 2 ) & 1 ))]"
  return $_cd_ret
}
# @usage copy_dependencies
# @args none
# @note uses lddtree to identify and copy to tree the libraries depended on by executables
# @note bitmask result status bit 0: lddtree, 1: missing file, 2: mode error

copy_one_part()
{ # copy one item ofr calling function; let calling function report results
  # if the system verbosity excedes or equals INFO severity,
  # then info_msg, act, info_right_status  (else act quietly)
  local _cop_ret=0; _cop_src="$1"; _cop_dest="$2"
  local _cop_short_dest="${_cop_dest/${SOURCES_DIR%/*}/}"
  info_msg_n "Copying [ $_cop_src ] to [ ...$_cop_short_dest ] ..."
  cp -a "$_cop_src" "$_cop_dest" >/dev/null 2>&1 || _cop_ret=1
  info_right_status $?
  return $_cop_ret
}
# @usate copy_one_part "SOURCE" "DEST"
# @ret [info_]right_status returns the same status it displays, so that is also returned here
# @note use of cp -a (archive mode) is critical - preserves symlinks, permissions, and timestamps

copy_executables()
{ local _ce_result=0
  local _ce_i _ce_longest
  notice_msg "Copying executables ..."
  for (( _ce_i=0; _ce_i<${#executables[@]}; _ce_i++  )); do
    # use the path-safe concatenation pattern
    copy_one_part "${executables[_ce_i]}" "${SOURCES_DIR%/}/${executables[_ce_i]#/}" || _ce_result$(( _ce_result | ( 1 << _ce_i ) ))
  done
  notice_msg_n "Done copying executables"
  handle_result $_ce_result
  d_do '
    _ce_longest=$(get_longest "${executables[@]}")
    for (( _ce_i=0; _ce_i<${#executables[@]}; _ce_i++  )); do
      debug_msg "bit $_ce_i (${executables[_ce_i]}) "                   # identify the executable at this index
      repeat "." $(( _ce_longest - ${#executables[_ce_i]} + 7 + 2  ))   # pad for alignment, incl "bit nn "
      echo_msg ": [$(( ( _ce_result >> _ce_i ) & 1 ))]"                 # report the status at that bit in the bitmask
    done
  ' "$debug"
  return $_ce_result
}
# @usage copy_executables
# @note copies all resolved executables to their corresponding paths in SOURCES_DIR
# @note uses a bitmask bit for each executable, to track specifically which worked or did not

build_other_devices()
{ bod_ret=0
  notice_msg "Building other devices ..."
  local _bod_old_pwd="$PWD"
  local _bod_result
  local _bod_console_chardev_EXISTS="$FALSE"
  info_msg_n "Moving to SOURCES_DIR/dev: ${SOURCES_DIR%/}/dev/"
  cd "${SOURCES_DIR%/}/dev/" 2>/dev/null
  info_handle_result $?  || bod_ret=$(( bod_ret | ( 1 << 0 ) ))
  # build console character device
  # -f (force) isn't a flag for mknod, so we check existence first to prevent error on re-run
  info_msg_n "looking for console in ${SOURCES_DIR%/}/dev/"
  if [[ -e console ]]; then
    info_echo_e_msg_n " (${BGon}exists${Boff})"; info_right_status 0
    info_msg_n "chcking if console is a character device"
    if [[ -c console ]]; then
      info_echo_e_msg_n " (${BGon}it is${Boff})"; info_right_status 0
      _bod_console_chardev_EXISTS="$TRUE"
    else
      info_echo_msg " (${BYon}it is not${Boff})"
      info_msg_n "removing non-charcater-device console"
      rm -f console
      info_handle_result $? "removed" "" || bod_ret=$(( bod_ret | ( 1 << 1 ) ))
    fi
  else
    info_echo_msg " (${BYon}does not exist${Boff})"
  fi
   # now create a console character device unless it already exists
  if [ ! "$_bod_console_chardev_EXISTS" ] ; then
    # now create the proper character device
    info_msg_n "creating new character-device console"
    mknod -m 600 console c 5 1
    info_handle_result $? "created" "failed!" || bod_ret=$(( bod_ret | ( 1 << 2 ) ))
  fi
  cd "${_bod_old_pwd}"
  info_msg "Returned to: ${_bod_old_pwd}"
  notice_msg_n "Done building other devices"
  handle_result $bod_ret "" "failed with exit code [$bod_ret]"
  debug_msg "bit 0 (cd) ..... status: [$(( ( _bod_ret >> 0 ) & 1 ))]"
  debug_msg "bit 1 (rm) ..... status: [$(( ( _bod_ret >> 1 ) & 1 ))]"
  debug_msg "bit 2 (mknod) .. status: [$(( ( _bod_ret >> 2 ) & 1 ))]"
  return $bod_ret
}
# @usage build_other_devices
# @note mdev handles block devices; this creates the essential static console node
# @note bitmask result status bit 1: cd, 2: rm, 3: mknod


build_structure()
{ local bs_ret=0
  local _bs_x _bs_fileline _bs_element _bs_type _bs_target _bs_dir_name
  notice_msg "Building initramfs structure ..."
  if [[ ! -d "${SOURCES_DIR}" ]]; then
    info_msg_n "creating ${SOURCES_DIR} ..."
    mkdir -p "${SOURCES_DIR}"
    info_right_status $? || bs_ret=$(( bs_ret | ( 1 << 0 ) ))
  else
    error_msg "Error: ${SOURCES_DIR} exists; should have been rotated out"
    bs_ret=1
  fi
  # iterate directly over the arguments passed to the function ("${structure[@]}")
  for _bs_x; do
    # Skip empty entries or comments
    [[ -z "$_bs_x" || "$_bs_x" == '#'* ]] && continue
    _bs_fileline=$(file "$_bs_x")
    # Use read to split the 'file' output. e.g. "/usr/bin: symbolic link to..."
    # _ is junk variable for the rest of the line
    read -r _bs_element _bs_type _ <<< "$_bs_fileline"
    _bs_element="${_bs_element%:}" # strip trailing colon
    # handle according to type
    # (building the tree - only interested in directories or symlinks to directories)
    case "$_bs_type" in
      "directory"|"cannot")
        info_msg_n "creating directory ${_bs_element}"
        mkdir -p "${SOURCES_DIR%/}/${_bs_element#/}"
        info_handle_result $? "created" "failed!"
        if [[ ! $? -eq 0 ]]; then
          error_msg "failed to mkdir -p ${SOURCES_DIR%/}/${_bs_element#/}"
          bs_ret=$(( bs_ret | ( 1 << 1 ) ))
        fi
        ;;
      "symbolic")
        # Extract the last word (the target) from the file line
        _bs_target="${_bs_fileline##* }"
        _bs_dir_name=$(dirname "$_bs_element")

        info_msg_n "creating link ${_bs_element} --> ${_bs_target} in ${SOURCES_DIR%/}/${_bs_dir_name#/}"
        # -f to overwrite if it already exists (idempotency)
        ln -snf "${_bs_target}" "${SOURCES_DIR%/}/${_bs_element#/}"
        info_handle_result $? "linked" "failed!"
        if [[ ! $? -eq 0 ]]; then
          error_msg "failed to ln -snf ${_bs_target} ${SOURCES_DIR%/}/${_bs_element#/}"
          bs_ret=$(( bs_ret | ( 1 << 2 ) ))
        fi
        ;;
      *)
        error_msg "error - unexpected type [$_bs_type] for [$_bs_x]"; bs_ret=5
        ;;
    esac
  done
  notice_msg_n "Done building initramfs structure"
  handle_result $bs_ret "" "failed with exit code [$bs_ret]"
  debug_msg "bit 0 (mkdir SOURCES) .. status: [$(( ( _bs_ret >> 0 ) & 1 ))]"
  debug_msg "bit 1 (mkdir element) .. status: [$(( ( _bs_ret >> 1 ) & 1 ))]"
  debug_msg "bit 2 (symlink) ........ status: [$(( ( _bs_ret >> 2 ) & 1 ))]"
  return $bs_ret
}
# @usage build_structure "${structure[@]}"
# @note replicates host directory structure and symlinks into SOURCES_DIR
# @note bitmask result status bit 1: mkdir SOURCES, 2: mkdir element, 3: symlink
