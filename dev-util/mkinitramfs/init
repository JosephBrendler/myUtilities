#!/bin/sh
#
# /usr/src/initramfs/init
# Joe Brendler   28 Feb 2008 (most reacently revised 02 January 2024)
#
#  for version history and "credits", see accompanying file "historical_notes"
#

# make my usual functions and formatting utilities available
init_ROOT="/"   # real system
### ***** substitute below for testing only ***** ---
#init_ROOT="/home/joe/myUtilities/dev-util/mkinitramfs/scratch/initramfs/"

# 20260216 - moved header here in init_structure (along with script_header_joetoo_compat)
script_header_installed_dir="/usr/sbin"
# properly slash the path
script_header_installed_path_fixed="${init_ROOT%/}/${script_header_installed_dir#/}"
printf '%s' "sourcing /script_header_joetoo ..."
# again, properly slash the path
. "${script_header_installed_path_fixed%/}/script_header_joetoo"
printf '%s' "Checking for header commands (toc, run_sequence) to confirm sourcing"
if command -v toc >/dev/null 2>&1 && command -v run_sequence >/dev/null 2>&1 ; then
handle_result $? ; else printf '%s\n' "Failed; header not sourced; cannot continue"; exit 1; fi
sleep .5

# source the BUILD number generated by the make_sources.sh script,
notice_msg "sourcing /BUILD ..."
. "${init_ROOT%/}/BUILD"
handle_result $? || die "failed to source /BUILD"
sleep .5

PN="initramfs: $(basename "$0")"

#----[ initialize additional global variables ]--------------------------------------------------
separator "${PN}-${BUILD}" "(initializing)"

# initialize these variables to '' to establish them as globals
#   remember '' evaluates as $FALSE in logical test
varlist="
  init_mdev_wait
  init_wait
  init_keyfile
  unlock_method
  lv.init_passdevice_list
  init_passdevice_mount_point
  bool.init_lock_down
  root_volume
  root_fs
  usr_volume
  usr_fs
  lv.CMDLINE
  verbosity
  init_config_title
"
# PATH -- display, don't initialize

initialize_vars
# set default verbosity if it is not externally set
#  just in case neither in init.conf nor cmdline does it
[ -z "$verbosity" ] && verbosity="$notice"

#----[ reassign variables with values from config files ]----------------------------------

# source variables assigned in init.conf. Note cmdline may override root=, usr=, verbosity=
notice_msg "sourcing /init.conf ..."
. "${init_ROOT%/}/init.conf"
right_status $? || die "failed to source /init.conf"
sleep .5
[ ! -z "${init_root_volume}" ] && root_volume="${init_root_volume}"
[ ! -z "${init_usr_volume}" ]  && usr_volume="${init_usr_volume}"
! isint "${init_wait}" && init_wait=1  # hard code default 1 second
! isint "${init_mdev_wait}" && init_wait=3  # hard code default 3 seconds
echo_msg   # newline

#----[ display separator to mark start of script ]-----------------------------------------------
separator "${PN}-${BUILD}" "(Running /init)"

#----[ source functions local to initramfs ]-----------------------------------------------------

### ***** for testing source this second ***** ---
notice_msg "sourcing /testing_functions_header ..."
. "${init_ROOT%/}/testing_functions_header"
right_status $? || die "failed to source /testing_functions_header"

### ***** for testing -- change oder of these two sourcing blocks ***** ---
# note: in the real init script, we MUST source validated_functions_header second, in order to
#   override testing-only-modified functions also present in testing_functions_header
#   (in the testing init script (ash.temp) it is the other way around)
notice_msg "sourcing /validated_functions_header ..."
. "${init_ROOT%/}/validated_functions_header"
right_status $? || die "failed to source /validated_functions_header"

# construct a wrappable string to represent PATH (translate : to ' ')
PATH_str=$(printf '%s' "$PATH" | tr ':' ' ')
# display initial config of variables available
# (must source display_config function first)
varlist="
  BUILD
  init_mdev_wait
  init_wait
  init_keyfile
  init_passdevice_mount_point
  bool.init_lock_down
  root_volume
  usr_volume
  verbosity
  lv.init_passdevice_list
  lv.PATH_str
"
# these below are not available yet
#unlock_method \
#root_fs \
#usr_fs \
#CMDLINE \
# PATH -- display, don't initialize
notice_msg "Initial Configuration follows ..."
show_config

#----[ Define functions local to initramfs ]-----------------------------------------------------

rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    echo_msg
    separator "${PN}-${BUILD}" "(${1} - Dropping to a shell...)"
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
#    exec "$(which sh)";
    exec "$(command -v sh)";
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # return 0: success; 1: kernel.hotplug failed; 2: mdev -s failed
    # external variables: init_wait
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    mu_ret=0

    # the kernel needs these virtual file systems to report hardware status
    notice_msg_n "mounting /proc"
    mount -t proc proc /proc
    right_status $? || die "failed to mount /proc"

    notice_msg_n "mounting devtmpfs"
    mount -t devtmpfs none /dev
    right_status $? || die "failed to mount devtmpfs"

    notice_msg_n "mounting sysfs"
    mount -t sysfs sysfs /sys
    right_status $? || die "failed to mount sysfs"

    # with mounts above in place, immediately instruct kernel to execute mdev
    #   whenever a device is added or removed --
    #     $(which mdev): Finds the full path to the mdev binary
    #     kernel.hotplug: tells the system which program to run whenever a hardware event occurs
    #     sysctl -w: writes the path of mdev into the kernel's configuration at /proc/sys/kernel/hotplug
    #   note: which is built into this initramfs' busybox
    #
    # kernel.hotplug has evidently been deprecated for a while -- if keeping the code, write to gracefully
    # move on to other options (and not hard fail) if id doesn't return a clean exit status
    #
    notice_msg "checking if hotplug is supported"
    if [ -w /proc/sys/kernel/hotplug ]; then
      echo "$(which mdev)" > /proc/sys/kernel/hotplug
      handle_result $? "" "" || mu_ret=1
    else
      notice_msg "kernel.hotplug not available; relying on netlink uevents"
    fi

    # seed /dev/ with all the device nodes that were created --
    #   mdev -s is called a "coldplug" scan (handles devices discovered via past events),
    #   whereas the "kernel.hotplug" line above is instructions for future events
    notice_msg "starting coldplug (mdev -s)"
    mdev -s ; _mu_result=$?
    notice_msg_n "result:"; handle_result $_mu_result "" "" || mu_ret=2

    # I used to just pause so kernel could finish identifying devices
    echo_msg  # newline
    notice_msg "${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}"
    # sh_countdown $(( ${init_wait} * 3 ))
    # instead of sleeping for "magic" amount of time, use a
    # system-agnostic wait for block device population to settle down
    _mu_min_count=2   # there are 2 header lines in /proc/partitions
    _mu_last_count=0
    _mu_curr_count=$(wc -l < /proc/partitions)
    _mu_retry=0; _mu_max_retry=10 # prevent hardware fault from bricking the boot sequence

    # while [nothing yet] OR [still counting]; do
    while [ "$_mu_curr_count" -lt "$_mu_min_count" ] || [ "$_mu_curr_count" -ne "$_mu_last_count" ]; do
        _mu_last_count=$_mu_curr_count
        sleep ${init_wait}
        mdev -s  # Refresh nodes
        _mu_curr_count=$(wc -l < /proc/partitions)
        _mu_retry=$((_mu_retry + 1))
        [ "$_mu_retry" -gt "$_mu_max_retry" ] && break # Safety timeout
    done

    # note, some complex devices (like LVM) might need a second scan after modules are loaded
    #   (we will do that later)

    # secondary mounts occur after main dev population
    notice_msg_n "looking for /dev/pts"
    [ -d /dev/pts ]; _mu_result=$?
    if [ ! "$_mu_result" -eq 0 ]; then
        notice_echo_msg " (${BYon}not found${Boff})"
        notice_msg_n "making /dev/pts"
        mkdir /dev/pts
        handle_result $? "created" "failed" || die "failed to mkdir /dev/pts"
    else
        notice_echo_msg " (${BGon}found${Boff})"
    fi
    notice_msg_n "mounting /dev/pts"
    mount -t devpts devpts /dev/pts
    handle_result $? "mounted" "failed" || die "failed to mount devpts"

    unset -v _mu_min_count _mu_last_count _mu_curr_count _mu_retry _mu_max_retry _mu_result
    return $mu_ret
}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
#notice_msg "Waiting for normal trailing kernel output ..."
#sh_countdown $((${init_wait} * 5))
# above should no longer be needed, with agnositc wait in mini_udev function

# start mini-udev (mdev) and wait long enough for devices to be recognized
notice_msg "Starting mini udev ..."
### ***** for testing comment out the line below ***** ---
mini_udev
result=$?
notice_msg_n "mini_udev result: "
handle_result "$result" "complete" "mdev failed with exit status [$result]" || die "mini_udev failed"

# now converting this dumb wait to a targeted wait (if needed) when getting keying dev
#&& sh_countdown $(($init_mdev_wait))

# safely assing CMDLINE
if [ -f /proc/cmdline ]; then
    CMDLINE="$(cat /proc/cmdline)"
### ***** for testing substitute the CMDLINE assignment below ***** ---
#    CMDLINE="BOOT_IMAGE=/vmlinuz-6.12.63-gentoo-dist-hardened-joetoo"
#    CMDLINE+=" root=/dev/mapper/vg_rock5bplus6401-root ro verbosity=5"
#    CMDLINE+=" usr=/dev/mapper/vg_rock5bplus6401-usr net.ifnames=0"
else
    CMDLINE=""     # Fallback or error for non-Linux systems (BSD, macOS, etc.)
fi

notice_msg "Calling process_cmdline"
process_cmdline ; result=$?
notice_msg_n "Done calling process_cmdline; result:"
handle_result $result "assigned CMDLINE below" "" || die "failed to assign CMDLINE"
notice_msg_n "${BWon}CMDLINE:${Boff} ${CMDLINE}"   # can smart-wrap if long
notice_echo_msg   # newline

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

# 20260217 - moved all luks device management suite to script_header_joetoo

# translate from init.conf to script_header_joetoo luks management suite
crypt_keydev_list="$init_passdevice_list"
notice_msg "Translated init.conf init_passdevice_list -> crypt_keydev_list: $crypt_keydev_list"
crypt_keydev_mountpoint="$init_passdevice_mount_point"
notice_msg "Translated init.conf init_passdevice_mount_point -> crypt_keydev_mountpoint: $crypt_keydev_mountpoint"
crypt_keyfile="$init_keyfile"
notice_msg "Translated init.conf init_keyfile -> crypt_keyfile: $crypt_keyfile"

luks_partition_device_list=$( blkid | grep -i luks | cut -d':' -f1 )
### ***** substitute below for testing only ***** --- ***** ALSO CHANGE HERE in init not init.test for qemu test ***** ---
#luks_partition_device_list=$(blkid | grep -i luks | grep 'UUID="b3c2b95f-1477-4433-b653-310e03dbffc2"' |cut -d':' -f1 )

notice_msg "Calling unlock_devices $luks_partition_device_list"
unlock_luks_devices $luks_partition_device_list ; result=$?
notice_msg_n "Done calling unlock_devices; result:"
handle_result $result "complete" "failed" || die "failed to unlock_devices"

# done with all luks devices; ok to un-mount keying device now
if [ -b "${init_passdevice_mount_point}" ]; then
    notice_msg_n "Un-mounting keying device (no longre needed) ..."
    umount "${init_passdevice_mount_point}" 2>/dev/null
    handle_result $? "unmounted" "failed" || warn_msg "Warning: keying passdevice is still mounted"
fi

# make lvm logical volumes available
notice_msg "running vgscan"
vgscan
notice_msg "running vgchange -a y"
vgchange -a y

# assign root and usr volume names (if not already done)
# (build in safe wait-loop to ensure lvm device mapper
#  populates the nodes and mdev has time to recognize
#  and create the rest of the /dev/ structure needed)
separator "${PN}-${BUILD}" "(assign/validate root, usr vols)"
TIMEOUT=20 # Max wait of 10 seconds total (20 * 0.5s checks)
notice_msg "Trying to confirm lvm has started and assign root volume"
while [ "$TIMEOUT" -gt 0 ]; do
    # Try to assign the volume name - redirect output for cleaner waiting dots
    if assign_volume "root_volume" ; then
      # if assignment succeeded, and it is a real blockdev, we are done!
      if [ -b "$root_volume" ]; then break; fi
    fi
    sleep 0.5
    TIMEOUT=$((TIMEOUT - 1))
done
# check if it completed or timed out
notice_msg_n "checking status"
[ -b "$root_volume" ]
handle_result $? "complete. root: $root_volume" "failed" || \
    die "timed out waiting for LVM root_volume [$root_volume]; cannot proceed"
notice_msg "Assigning usr volume"
assign_volume "usr_volume"
notice_msg_n "checking status"
[ -b "$usr_volume" ]
handle_result $? "complete. usr: $usr_volume" "failed" || \
    warn_msg "Failed to assign usr volume. Proceeding without it"

# validate root and usr device and assign fs
#  cannot do this until after the volume is unlocked and the volume is assigned
#  need to pass string name arg so function can make fs assignment
notice_msg "Calling validate_volume_and_assign_fs for root_volume"
validate_volume_and_assign_fs "root_volume"
notice_msg_n "root_fs:" ; handle_result $? "$root_fs" ""

notice_msg "Calling validate_volume_and_assign_fs for usr_volume"
validate_volume_and_assign_fs "usr_volume"
notice_msg_n "usr_fs:" ; handle_result $? "$usr_fs" ""

# display config - after volumes uinlocked and root/usr fs obtained
varlist="
  BUILD
  init_mdev_wait
  init_wait
  unlock_method
  init_keyfile
  init_passdevice_mount_point
  init_lock_down
  luks_partition_device
  root_volume
  root_fs
  usr_volume
  usr_fs
  verbosity
  lv.init_passdevice_list
  CMDLINE
  lv.PATH_str
"
# PATH -- display, don't initialize
notice_msg "Mature Configuration follows ..."
show_config

if [ ! "$QUIET" ] && [ "$verbosity" -ge "$debug" ]; then sh_countdown $(( $init_wait * 3 )); fi

# access the root and usr logical volumes (among others), and show what we unlocke
display_logical_volumes || error_msg "error running display_logical_volumes"

# mount new_root and prepareto switch_root
mount_new_root_and_prepare_to_switch_root || die "failed to mount_new_root_and_prepare_to_switch_root"
# substitute below for testing only### *****
#mount_and_test_new_root || die "failed to mount_and_test_new_root"

separator "${PN}-${BUILD}" "(Switching to /newroot, mounted on encrypted volume [${root_volume}])"
notice_msg "  -  Will continue with /sbin/init"
[ ! -z "${CMDLINE}" ] && notice_msg "  -  using cmdline: ${CMDLINE}"
echo

### ***** for testing comment out EVERYTHING below ***** ---

# boot the real thing or exit to rescue shell if not locked down
exec $(which busybox) switch_root /newroot /sbin/init ${CMDLINE} || \
    { error_msg "failed to mount root volume" ; [ ! "${init_lock_down}" ] && rescue_shell "Failed to pivot root" ; }

notice_msg "General failure, shutting down for security reasons"
sh_countdown $(($init_wait * 3))
shutdown -hP now
