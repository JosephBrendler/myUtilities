#!/bin/sh
#
# /usr/src/initramfs/init
# Joe Brendler   28 Feb 2008 (most reacently revised 02 January 2024)
#
#  for version history and "credits", see accompanying file "historical_notes"
#

#### ***** for testing, when ready, move still-testing functions to validated_functions_header ***** ---------
# and remove the sourcing of testing_functions_header (below)
###----******************************************************************************************************

# make my usual functions and formatting utilities available
printf '%s' "sourcing /script_header_joetoo ..."
source /script_header_joetoo
handle_result $? || die "failed to source /script_header_joetoo"
sleep .5

# source the BUILD number generated by the make_sources.sh script,
d_message_n "sourcing /BUILD ..." 1
source /BUILD
d_handle_result $? 1 || die "failed to source /BUILD"
sleep .5

PN="initramfs: $(basename "$0")"

#----[ initialize additional global variables ]--------------------------------------------------
separator "${PN}-${BUILD}" "(initializing)"

# initialize these variables to '' to establish them as globals
#   remember '' evaluates as $FALSE in logical test
varlist="
  init_mdev_wait
  init_wait
  init_keyfile
  unlock_method
  lv.init_passdevice_list
  init_passdevice_mount_point
  init_passdevice_volume
  init_passdevice_fs
  bool.init_lock_down
  root_volume
  root_fs
  usr_volume
  usr_fs
  lv.CMDLINE
  bool.VERBOSE
  verbosity
  init_config_title
"
# PATH -- display, don't initialize

initialize_vars
# set defai;t verbosity - b/c we must have these assigned,
#  just in case neither in init.conf nor cmdline does it
VERBOSE=$TRUE; verbosity=2

#----[ reassign variables with values from config files ]----------------------------------

# source variables assigned in init.conf. Note cmdline may override root=, usr=, verbosity=
d_message_n "sourcing /init.conf ..." 1
source /init.conf
d_handle_result $? 1 || die "failed to source /init.conf"
sleep .5
if [ "$verbosity" -gt 0 ]; then VERBOSE=$TRUE; else VERBOSE=$FALSE; fi
[ ! -z "${init_root_volume}" ] && root_volume="${init_root_volume}"
[ ! -z "${init_usr_volume}" ]  && usr_volume="${init_usr_volume}"
if ! isint "${init_wait}" && init_wait=1  # hard code default 1 second
if ! isint "${init_mdev_wait}" && init_wait=3  # hard code default 3 seconds 
printf "\n"

#----[ display separator to mark start of script ]-----------------------------------------------
separator "${PN}-${BUILD}" "(Running /init)"

#----[ source functions local to initramfs ]-----------------------------------------------------
# common ash functions used by several scripts (display_config, echo_long_string)
d_message_n "sourcing /common_ash_functions_header ..." 1
source /common_ash_functions_header
d_handle_result $? 1 || die "failed to source /common_ash_functions_header"

### *** for testing, when ready, move still-testing functions to validated_functions_header **---
d_message_n "sourcing /testing_functions_header ..." 1
source /testing_functions_header
d_handle_result $? 1 || die "failed to source /testing_functions_header"

# note: in the real init script, we MUST source validated_functions_header second, in order to
#   override testing-only-modified functions also present in testing_functions_header
#   (in the testing init script (ash.temp) it is the other way around)
d_message_n "sourcing /validated_functions_header ..." 1
source /validated_functions_header
d_handle_result $? 1 || die "failed to source /validated_functions_header"

# display initial config of variables available
# (must source display_config function first)
varlist="
  BUILD
  init_mdev_wait
  init_wait
  init_keyfile
  init_passdevice_mount_point
  bool.init_lock_down
  root_volume
  usr_volume
  bool.VERBOSE
  verbosity
  lv.init_passdevice_list
  lv.PATH
"
# these below are not available yet
#unlock_method \
#init_passdevice_volume \
#init_passdevice_fs \
#root_fs \
#usr_fs \
#CMDLINE \
# PATH -- display, don't initialize
message "Initial Configuration follows ..."
show_config

#----[ Define functions local to initramfs ]-----------------------------------------------------

rescue_shell() {
    # echo a simply formatted message explaining the source of our problem
    #   and drop to a shell
    # arguments: string message to explain source of error
    #
    printf "\n"
    separator "${PN}-${BUILD}" "(${1} - Dropping to a shell...)"
    # pause for time to read message
    sh_countdown $(($init_wait * 3));
    busybox --install -s;
    exec "$(which sh)";
}

mini_udev() {
    # start mdev to identify devices, building nodes for them in /dev
    # arguments: none
    # external variables: init_wait
    # Notes: initramfs must include the following directories
    #    /proc/sys/kernel
    #    /proc/partitions
    #    /sys/class
    #    /sbin  - with binary udevadm and link to busybox for mdev

    # The simple explanation here is that you need to [1] make sure /dev is
    # a tmpfs filesystem.  Then you want to [2] create the /dev/pts mount point
    # and [3] mount the devpts filesystem on it. Then [4] you want to have /sys
    # mounted before executing mdev. (these steps handled before call to mini_udev)
    # Then you [5] instruct the kernel to execute /sbin/mdev whenever
    # a device is added or removed so that the device node can be created or
    # destroyed.  Then you [6] seed /dev with all the device nodes that were created
    # while the system was booting.

    # the kernel needs these virtual file systems to report hardware status
    message_n "mounting /proc"
    mount -t proc proc /proc
    handle_result $? || die "failed to mount /proc"

    message_n "mounting devtmpfs"
    mount -t devtmpfs none /dev
    handle_result $? || die "failed to mount devtmpfs"

    message_n "mounting sysfs"
    mount -t sysfs sysfs /sys
    handle_result $? || die "failed to mount sysfs"

    # with mounts above in place, immediately instruct kernel to execute mdev
    #   whenever a device is added or removed --
    #     $(which mdev): Finds the full path to the mdev binary
    #     kernel.hotplug: tells the system which program to run whenever a hardware event occurs
    #     sysctl -w: writes the path of mdev into the kernel's configuration at /proc/sys/kernel/hotplug
    #   note: which is built into this initramfs' busybox
    sysctl -w kernel.hotplug=$(which mdev)

    # seed /dev/ with all the device nodes that were created --
    #   mdev -s is called a "coldplug" scan (handles devices discovered via past events),
    #   whereas the "kernel.hotplug" line above is instructions for future events
    mdev -s

    # I used to just pause so kernel could finish identifying devices
    message "\n${BYon}NOTE: ${BRon}if using removable keying device, ensure it is inserted and active...${Boff}"
    # sh_countdown $(( ${init_wait} * 3 ))
    # instead of sleeping for "magic" amount of time, use a
    # system-agnostic wait for block device population to settle down
    _min_count=2   # there are 2 header lines in /proc/partitions
    _last_count=0
    _curr_count=$(wc -l < /proc/partitions)
    _retry=0; _max_retry=10 # prevent hardware fault from bricking the boot sequence

    # while [nothing yet] OR [still counting]; do
    while [ "$_curr_count" -lt "$_min_count" ] || [ "$_curr_count" -ne "$_last_count" ]; do
        _last_count=$_curr_count
        sleep ${init_wait}
        mdev -s  # Refresh nodes
        _curr_count=$(wc -l < /proc/partitions)
        _retry=$((_retry + 1))
        [ "$_retry" -gt "$_max_retry" ] && break # Safety timeout
    done

    # note, some complex devices (like LVM) might need a second scan after modules are loaded
    #   (we will do that later)

    # secondary mounts occur after main dev population
    message_n "looking for /dev/pts"
    if [ ! -d /dev/pts ]; then
        mkdir /dev/pts || die "failed to mkdir /dev/pts"
        printf '%s' " (${Gon}created${Boff})"
    else
        printf '%s' " (${Gon}found${Boff})"
    fi
    handle_result $? || die "failed to find/create /dev/pts"
    message_n "mounting /dev/pts"
    mount -t devpts devpts /dev/pts
    handle_result $? || die "failed to mount devpts"

    unset -v _min_count _last_count _curr_count _retry _max_retry
    return 0

}

#---[ Main script ]----------------------------------------------------------------------------------------

# wait for normal trailing kernel output
#message "Waiting for normal trailing kernel output ..."
#sh_countdown $((${init_wait} * 5))
# above should no longer be needed, with agnositc wait in mini_udev function

# start mini-udev (mdev) and wait long enough for devices to be recognized
message "Starting mini udev ..."
mini_udev
result=$?
message_n "mini_udev result: "
handle_result "$result" "mdev started" "mdev failed to start"

# now converting this dumb wait to a targeted wait (if needed) when getting keying dev
#&& sh_countdown $(($init_mdev_wait))

# safely assing CMDLINE
if [ -f /proc/cmdline ]; then
    CMDLINE="$(cat /proc/cmdline)"
else
    CMDLINE=""     # Fallback or error for non-Linux systems (BSD, macOS, etc.)
fi

process_cmdline
# override VERBOSE if user set verbosity=0 on cmdline
if [ "$verbosity" -gt 0 ]; then VERBOSE=$TRUE; else VERBOSE=$FALSE; fi

# if init.conf indicates there is a non-zero-lenght keyfile name to be looked for on a non-empty list of
# devices, then see if we can select one that will work, otherwise use passphrase method

# call select_keying_device_and_unlock_method to assign unlock_method and init_passdevice_volume
select_keying_device_and_unlock_method || die "failed to select_keying_device_and_unlock_method"

# echo to console to confirm attempt to unlock HDs
separator "${PN}-${BUILD}" "(Unlocking encrypted Drive(s))"
# call function to unlock HD(s)
unlock_devices "${unlock_method}" || die "failed to unlock_devices"

# done with all luks devices; ok to un-mount keying device now
if [ -b "${init_passdevice_mount_point}" ]; then
    message_n "Un-mounting keying device ..."
    umount "${init_passdevice_mount_point}" 2>/dev/null
    handle_result $?
fi

# make lvm logical volumes available
vgscan
vgchange -a y
sh_countdown $(( $init_wait * 3 ))

# assign root and usr volume names (if not already done)
separator "${PN}-${BUILD}" "(assign/validate root, usr vols)"
assign_volume "root_volume"
assign_volume "usr_volume"

# validate root and usr device and assign fs
#  cannot do this until after the volume is unlocked and the volume is assigned
#  need to pass string name arg so function can make fs assignment
validate_volume_and_assign_fs "root_volume"
validate_volume_and_assign_fs "usr_volume"

# display config - after volumes uinlocked and root/usr fs obtained
varlist="
  BUILD
  init_mdev_wait
  init_wait
  init_passdevice_volume
  init_passdevice_fs
  unlock_method
  init_keyfile
  init_passdevice_mount_point
  init_lock_down
  root_volume
  root_fs
  usr_volume
  usr_fs
  bool.VERBOSE
  verbosity
  lv.init_passdevice_list
  lv.CMDLINE
  lv.PATH
"
# PATH -- display, don't initialize
message "Mature Configuration follows ..."
show_config

d_do sh_countdown $(( $init_wait * 3 )) 4

# access the root and usr logical volumes (among others), and show what we unlocke
display_logical_volumes || E_message "error running display_logical_volumes"

# mount_new_root_and_prepare_to_switch_root
mount_new_root_and_prepare_to_switch_root || die "failed to mount_new_root_and_prepare_to_switch_root"

separator "${PN}-${BUILD}" "(Switching to /newroot, mounted on encrypted volume [${root_volume}])"
d_message "  -  Will continue with /sbin/init" 1
[ ! -z "${CMDLINE}" ] && d_message "  -  using cmdline: ${CMDLINE}" 1
echo

# boot the real thing or exit to rescue shell if not locked down
exec $(which busybox) switch_root /newroot /sbin/init ${CMDLINE} || \
    { E_message "failed to mount root volume" ; [ ! ${init_lock_down} ] && rescue_shell "Failed to pivot root" ; }

message "General failure, shutting down for security reasons"
sh_countdown $(($init_wait * 3))
shutdown -hP now
