#!/bin/sh
#
#  20260126 - changed from #!/bin/ash after revising all contained functions to be fully POSIX compliant

### -----[ duplicated functions ]--------------------------------------------------------------
### These scripts exist in both "validated_" and "testing_" headers but have been modified in each
### In the live init script, source the "testing_" header first and "validated_" header second
### In the testing script, source "validated_" header first and the "testing_" header second
### The later-sourced will override, and this avoid having the "testing" script mess with
###    non-testing luks devices on a testing host system
assign_volume() {
    ret=0
    # given string volume name (root_ usr_volume), scan lvs and make volume pathname assignment
    _av_volume_name=$1
#    _av_prefix="${_av_volume_name/_volume}"     # e.g. assign root, from root_volume (bash substitution)
    _av_prefix="${_av_volume_name%_volume}"     # e.g. assign root, from root_volume (POSIX strip from end)
    eval "_av_volume=\"\$${_av_volume_name}\""
    if [ -z "${_av_volume}" ] ; then
        info_msg "about to evaluate ${_av_prefix}_volume=/dev/mapper/$(lvs | grep ${_av_prefix} | awk '{print $2"-"$1}')"
        info_msg_n "${_av_prefix} _av_volume_name not assigned, scanning ..."
        _av_volume="/dev/mapper/$(lvs | grep ${_av_prefix} | awk '{print $2"-"$1}')"
### substitute for testing only (ver 10.0+ changed from deselecting gmki91 to SELECTING test device)
#        info_msg "about to evaluate ${_av_prefix}_volume=/dev/mapper/$(lvs | grep 'rock5bplus6401' | grep ${_av_prefix} | awk '{print $2"-"$1}')"
#        info_msg_n "${_av_prefix} _av_volume_name not assigned, scanning ..."
#        _av_volume="/dev/mapper/$(lvs | grep 'rock5bplus6401' | grep $_av_prefix | awk '{print $2"-"$1}')"
        eval "${_av_prefix}_volume=$_av_volume"
        ret=$?
        info_handle_result $ret "$_av_volume" "failed to assign _av_volume"
    else
        info_msg "No action. ${_av_prefix} volume already assigned [$_av_volume]"
    fi
    unset -v _av_prefix _av_volume_name _av_volume
    return $ret
}

### ----[ end duplicated functions ]--------------------------------------------------------------------------------------------------------------

display_logical_volumes() {
    ret=0
    # show what we've found...
    separator "${PN}-${BUILD}" "(available volume groups)"
    vgs || ret=1
    separator "${PN}-${BUILD}" "(available logical volumes)"
    lvs || ret=1
    [ ! "$QUIET" ] && d_do verbosity=7 sh_countdown '$init_wait' "$debug"
    return $ret
}

mount_new_root_and_prepare_to_switch_root() {
    ret=0
    separator "${PN}-${BUILD}" "(Attempting to mount new root ...)"
    # previous version re-scanned here, but that now occurs after unlock
    # note: script_header_joetoo v0.2.0+ changed arg sequence for color()
    # color() - $1: FG code (30-37, 39); $2: Bold (0/1); $3: BG code (40-47, 49
    info_msg "$(color ${RED} ${BOLD} ${BBACK})running fsck -t ${root_fs} on $root_volume${Boff}"
    fsck -t "${root_fs}" -p "$root_volume" 2>/dev/null
    result=$?
    info_handle_result $result '' "failed with exit code [$result]"
    [ $result -ge 4 ] && die "fsck failure ($result); cannot continue"
    info_msg "$(color ${RED} ${BOLD} ${BBACK})running fsck -t ${usr_fs} on $usr_volume${Boff}"
    fsck -t "${usr_fs}" -p "$usr_volume" 2>/dev/null
    result=$?
    info_handle_result $result '' "failed with exit code [$result]"
    [ $result -ge 4 ] && die "fsck failure ($result); cannot continue"
    # give more time to read display if debugging
    [ ! "$QUIET" ] && d_do verbosity=7 sh_countdown '$init_wait' "$debug"
    [ ! "$QUIET" ] && d_do verbosity=7 'tree -d' "$debug"
    # mount root - drop to shell if not locked down
    info_msg_n "Mounting new root volume ..."
    mount -r -t "${root_fs}" "${root_volume}" /newroot 2>/dev/null ; _mnr_result=$?
    info_handle_result "$_mnr_result" '' "failed to mount root volume"
    if  [ ! "$_mnr_result" -eq 0 ] && [ "$init_lock_down" = "no" ]; then
        ret=1
        rescue_shell "Failed to mount root volume"
    fi
    info_msg_n "Mounting new usr volume ..."
    mount -t "${usr_fs}" -o defaults,noatime "$usr_volume" /newroot/usr ; _mnr_result=$?
    info_handle_result "$_mnr_result" '' "failed to mount usr volume"
    if  [ ! "$_mnr_result" -eq 0 ] && [ "$init_lock_down" = "no" ]; then
        ret=1
        rescue_shell "Failed to mount usr volume"
    fi

    separator "${PN}-${BUILD}" "(Mounts)"
    mount | sed 's|^|    |'

    # clean up in preparation to actually switch root - with retry if needed
    for _mnr_fs in /dev/pts /dev /sys /proc; do
        info_msg_n "umount ${_mnr_fs} ..."
        # Try standard unmount
        umount "${_mnr_fs}"
        _mnr_result=$?
        # if standard umount fails, try a "lazy" unmount (-l)
        # This is often necessary if a process has a lingering handle
        if [ $_mnr_result -ne 0 ]; then
            info_msg " (retrying lazy umount...)"
            umount -l "${_mnr_fs}"
            _mnr_result=$?
        fi
        info_handle_result "$_mnr_result" '' "Critical error: Could not unmount ${_mnr_fs}"

        # fatal exit -- if it's still mounted, switch_root WILL fail.
        if [ $_mnr_result -ne 0 ]; then
            if [ "$init_lock_down" = "no" ]; then
                rescue_shell "Manual intervention required: ${_mnr_fs} is busy."
            else
                die "Panic: Critical filesystem ${_mnr_fs} busy during lockdown."
            fi
        fi
    done

    # give more time to read display if debugging
    [ ! "$QUIET" ] && d_do verbosity=7 sh_countdown "$init_wait" "$debug"
    unset -v _mnr_result _mnr_fs
    return $ret
}


validate_volume_and_assign_fs() {
    ret=0
    # given the string name of the volume, validate its existence and assign fs type
    # sets select_keying_device() _vva_EXISTS ("global" here) and
    # assigns global variable named by $_vva_fs_name (e.g. root_fs, by indirect reference
    _vva_volume_name=$1
    # guard - reject invalid variable names, which either
    #   (1) include chars other than members of [:alnum:] or _, OR
    #   (2) begins with a numeral are invalid variable names in a POSIX shell
    case "$_vva_volume_name" in
        *[![:alnum:]_]* | [0-9]*)
            error_msg "volume_name [$_vva_volume_name] is not a valid POSIX variable name"
            unset -v _vva_volume_name ; return 1 ;;
    esac
    # POSIX indirect variable assignment
    eval "_vva_volume=\"\$${_vva_volume_name}\""
    info_msg "validating volume ${_vva_volume_name} [${_vva_volume}]"

    # caution - an unassigned volume_name (null $my_volume) will evaluate true for [ -b ${my_volume} ]
    if [ -b "${_vva_volume}" ]; then
        _vva_EXISTS=$TRUE
        # use eval to assign the fs type; identify the variable name from the volume name
        # e.g. if _vva_volume_name = root_volume then _vva_fs_name = root_fs
        _vva_fs_name=$( printf '%s' "$_vva_volume_name" | sed 's|volume|fs|')
        # get only the filesystem type and assign it directly to a variable
        info_msg_n "looking up fs type for ${_vva_volume}"
        # capture raw blkid output (since BusyBox -o value may fail)
        _vva_raw_info=$(blkid "${_vva_volume}")
        # use awk to find the field starting with TYPE= and strip the quotes
        _vva_fs_type=$(printf '%s' "$_vva_raw_info" | awk -F'TYPE="' '{print $2}' | awk -F'"' '{print $1}')
        info_handle_result $? "$_vva_fs_type" "failed"
        # now assign the type to the fs name e.g. root_fs=ext4
        info_msg_n "performing indirect assignment ${_vva_fs_name}=\"${_vva_fs_type}\""
        eval "${_vva_fs_name}=\"${_vva_fs_type}\""
        info_handle_result $? '' ''
    else
        _vva_EXISTS=$FALSE
        printf '%s' " (${BRon}not a blockdev${Boff})"
        right_status 1
    fi
    # keep this check/message outside the if-then-else above, so it can return clean status on the same line
    if [ $_vva_EXISTS ];    then
        info_msg "    ${BGon}Valid device${Boff} [${_vva_volume}] type [${TYPE}] ${BGon}Exists${Boff}"
    else
        error_msg "    ${BRon}invalid device [${_vva_volume}]${Boff}"
        _vva_volcase="$(printf '%s' ${_vva_volume_name} | sed 's|_volume||')"
        case "${_vva_volcase}" in
            "root"|"usr" ) info_msg "     -- will scan for ${_vva_volcase} volume later, in unlocked volumes" ;;
            * ) info_msg "    -- invalid case [$_vva_volcase]" ;;
        esac
    fi
    unset -v _vva_volume_name _vva_fs_name _vva_volume _vva_fs_type _vva_answer _vva_EXISTS
    unset -v  _vva_volcase
    return $ret
}

process_cmdline() {
  ret=0
  notice_msg "Processing cmdline ..."
  _pc_line_out=""
  set -- ${CMDLINE}
  while [ $# -gt 0 ]; do
    _pc_entry=$1
    # strip the longest match for =* from the end; i.e. evrything from the first = onward
    #  (e.g. keep only 'root' in root=UUID=8234baac-f344-42ac-b08a-5e256d89fd07)
    _pc_var="${_pc_entry%%=*}"  # equiv $(echo ${_pc_entry} | cut -d'=' -f1) but more efficient
    # strip the shortest match for *= from front; i.e. from first = and to the left
    #  (e.g. keep 'UUID=8234baac-...' in root=UUID=8234baac-f344-42ac-b08a-5e256d89fd07)
    _pc_val="${_pc_entry#*=}"  # equiv $(echo ${_pc_entry} | cut -d'=' -f2-) but more efficient
    case "$_pc_var" in
      "verbosity" )
        export "${_pc_entry}" || die "failed to export verbosity"
        info_msg "cmdline override: [${_pc_entry}]]"
      ;;
      "root" )
        export root_volume="${_pc_val}" || die "failed to export root_volume"
        info_msg "cmdline override: [root_volume=${_pc_val}]"
        _pc_line_out="${_pc_line_out} ${_pc_entry}"
      ;;
      "usr" )
        export usr_volume="${_pc_val}" || die "failed to export usr_volume"
        info_msg "cmdline override: [usr_volume=${_pc_val}]"
      ;;
      * )
        info_msg "cmdline entry [${_pc_entry}] ignored by initramfs"
        _pc_line_out="${_pc_line_out} ${_pc_entry}"
      ;;
    esac
    shift  # get next entry from CMDLINE
  done
  # reset the CMDLINE without the initramfs-peculiar entries
  export CMDLINE="${_pc_line_out}"
  # if not dead from a die command above, then success
  notice_msg_n "Done processing cmdline; result:"
  handle_result 0 "exported \$CMDLINE" ""
  unset -v _pc_line_out _pc_entry _pc_var _pc_val
  return $ret
}

