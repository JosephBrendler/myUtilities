#!/bin/bash
#   script header with basic functions
# Author: brendlefly 26 Jan 2017
#
# NOTE: to use this header, you must first source the basic script_header_brendlefly
#

myBOX()         # draw an esc-seq single-line box w/ u/l corner at row $1, col $2, width $3, height $4
{
  local i
  ULrow=$1; ULcol=$2; WT=$3; HT=$4; myBOX=""
  myBOX=${myBOX}${ESCon}
  myBOX=${myBOX}$(repeat " " ${ULcol})${UL_wall}$(repeat ${H_wall} ${WT})${UR_wall}"\n"
  for ((i=1;i<${HT};i++)); do myBOX=${myBOX}$(repeat " " ${ULcol})${V_wall}$(repeat " " ${WT})${V_wall}"\n"; done
  myBOX=${myBOX}$(repeat " " ${ULcol})${LL_wall}$(repeat ${H_wall} ${WT})${LR_wall}"\n"
  myBOX=${myBOX}${ESCoff}
  CLR; CUP ${ULrow} 1
  printf "${myBOX}"
  return 0
}

my_u_BOX()      # draw a unicode single-line box with u/l corner at row $1, col $2, width $3, height $4
{
  local i
  ULrow=$1; ULcol=$2; WT=$3; HT=$4; myBOX=""
  myBOX=${myBOX}$(repeat " " ${ULcol})${uUL_wall}$(repeat ${uH_wall} ${WT})${uUR_wall}"\n"
  for ((i=1;i<${HT};i++)); do myBOX=${myBOX}$(repeat " " ${ULcol})${uV_wall}$(repeat " " ${WT})${uV_wall}"\n"; done
  myBOX=${myBOX}$(repeat " " ${ULcol})${uLL_wall}$(repeat ${uH_wall} ${WT})${uLR_wall}"\n"
  CLR; CUP ${ULrow} 1
  printf "${myBOX}"
  return 0
}

my_uD_BOX()     # draw a unicode double-line box with u/l corner at row $1, col $2, width $3, height $4
{
  local i
  ULrow=$1; ULcol=$2; WT=$3; HT=$4; myBOX=""
  myBOX=${myBOX}$(repeat " " ${ULcol})${uD_UL_wall}$(repeat ${uD_H_wall} ${WT})${uD_UR_wall}"\n"
  for ((i=1;i<${HT};i++)); do myBOX=${myBOX}$(repeat " " ${ULcol})${uD_V_wall}$(repeat " " ${WT})${uD_V_wall}"\n"; done
  myBOX=${myBOX}$(repeat " " ${ULcol})${uD_LL_wall}$(repeat ${uD_H_wall} ${WT})${uD_LR_wall}"\n"
  CLR; CUP ${ULrow} 1
  printf "${myBOX}"
  return 0
}

vercomp()       # compare two version numbers (e.g. 2.0.1-r4), returns =:0, >:1, <:2
{
    VERBOSE="false"
    # process arguments
    local optioncount=0 operandcount=0
    while [ ! -z $1 ]
    do
        # accept one option indicated by leading "-" 
        # accept two operands indicated by no leading "-"
        # error if there's more on the command line than that
        if [ "${1:0:1}" == "-" ]
        then
            if (($optioncount < 1)) && [[ "$1" == "-v" ]]
            then
                VERBOSE="true"
                let "optioncount++"
            else
                echo "Error: only one option (-v) allowed" && exit 1
            fi
        else
            if (($operandcount < 2))
            then
                (($operandcount < 1)) && OP1=$1 || OP2=$1
                let "operandcount++"
            else
                echo "Error: only two operands (version numbers) allowed" && exit 1
            fi
        fi
        shift
    done
    #---[ additional local definitions ]--------------

    if [[ $OP1 == $OP2 ]]
    then
        [ "$VERBOSE" == "true" ] && echo "$OP1 == $OP2; return 0"
        return 0
    fi

    local IFS=.
    local i ver1=($OP1) ver2=($OP2)
    if [ "$VERBOSE" == "true" ]
    then
      echo '$OP1:'" $OP1"
      echo '$OP2:'" $OP2"
      echo '${ver1}:'" ${ver1}"
      echo '${ver2|:'" ${ver2}"
      echo '${#ver1[@]}:'" ${#ver1[@]}"
      echo '${#ver2[@]}:'" ${#ver2[@]}"
      echo "To zero empty fields in ver1, i will range from = ${#ver1[@]} to < ${#ver2[@]}"
    fi
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
        [ "$VERBOSE" == "true" ] && echo "setting to zero for i=$i, ver1[$i]=${ver1[i]}"
    done
    [ "$VERBOSE" == "true" ] && \
      echo "compare ith fields from most to least significant; return immediately if they differ"
    [ "$VERBOSE" == "true" ] && echo "( i will range from = 0 to < ${#ver1[@]} )"
    for ((i=0; i<${#ver1[@]}; i++))
    do
        [ "$VERBOSE" == "true" ] && echo "i=$i; ver1[$i]=${ver1[i]}; ver2[$i]=${ver2[i]}"
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
            [ "$VERBOSE" == "true" ] && echo "  setting to zero for i=$i, ver2[$i]=${ver2[i]}"
        else
            [ "$VERBOSE" == "true" ] && echo "  for i = $i, ${ver2[i]} is not empty, nothing to do"
        fi

        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            [ "$VERBOSE" == "true" ] && echo "  i=$i; 10#${ver1[i]} > 10#${ver2[i]}; return 1"
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            [ "$VERBOSE" == "true" ] && echo "  i=$i; 10#${ver1[i]} < 10#${ver2[i]}; return 2"
            return 2
        fi
    done

    [ "$VERBOSE" == "true" ] && echo "testing final field for revision numbers"
    i=$(($i -1))    # back to index of final field
    tst1=$(expr index "${ver1[i]}" "-")
    tst2=$(expr index "${ver2[i]}" "-")
    [ "$VERBOSE" == "true" ] && echo "i=$i, tst1=[$tst1], tst2=[$tst2]"
    if [ $tst1 -gt 0 ]
    then
        [ "$VERBOSE" == "true" ] && echo "ver1 HAS a rev #"
        v1=$(echo ${ver1[i]} | cut -d- -f1)
        r1=$(echo ${ver1[i]} | cut -d- -f2 | sed 's/^r//')
        [ "$VERBOSE" == "true" ] && echo "v1=[$v1], r1=[$r1]"
    else
        [ "$VERBOSE" == "true" ] && echo "ver1 has NO rev #"
        v1=${ver1[i]}; r1=""
        [ "$VERBOSE" == "true" ] && echo "v1=[$v1], r1=[$r1]"
    fi
     if [ $tst2 -gt 0 ]
    then
        [ "$VERBOSE" == "true" ] && echo "ver2 HAS a rev #"
        v2=$(echo ${ver2[i]} | cut -d- -f1)
        r2=$(echo ${ver2[i]} | cut -d- -f2 | sed 's/^r//')
        [ "$VERBOSE" == "true" ] && echo "v2=[$v2], r2=[$r2]"
    else
        [ "$VERBOSE" == "true" ] && echo "ver2 has NO rev #"
        v2=${ver2[i]}; r2=""
        [ "$VERBOSE" == "true" ] && echo "v2=[$v2], r2=[$r2]"
    fi
    [ "$VERBOSE" == "true" ] && echo "v1=[$v1], r1=[$r1], v2=[$v2], r2=[$r2]"
    if [ -z $r1 ] && [ -z $r2 ]
    then
        [ "$VERBOSE" == "true" ] && echo "no rev numbers, and we already determined that" && \
          echo "10#${ver1[i]} is neither < nor > 10#${ver2[i]}; return 0"
        return 0
    else
        [ "$VERBOSE" == "true" ] && echo "either or both have a rev #; compare"
        if ((10#${v1} > 10#${v2}))
        then
            [ "$VERBOSE" == "true" ] && echo "Final field, i=$i; 10#${v1} > 10#${v2}; return 1"
            return 1
        fi
        if ((10#${v1} < 10#${v2}))
        then
            [ "$VERBOSE" == "true" ] && echo "Final field, i=$i; 10#${v1} < 10#${v2}; return 2"
            return 2
        fi
         # at this point only the rev #s might differ, compare. note: blank is less
        [ "$VERBOSE" == "true" ] && echo "r1=$r1, r2=$r2"
        if [ -z $r2 ] && [ ! -z $r1 ]
        then
            [ "$VERBOSE" == "true" ] && echo "Rev # [$r1] > [$r2]; return 1"
            return 1
        fi
        if [ -z $r1 ] && [ ! -z $r2 ]
        then
            [ "$VERBOSE" == "true" ] && echo "Rev # [$r1] < [$r2]; return 2"
            return 2
        fi
        if ((10#$r1 > 10#$r2))
        then
            [ "$VERBOSE" == "true" ] && echo "Rev # [$r1] > [$r2]; return 1"
            return 1
        fi
        if ((10#$r1 < 10#$r2))
        then
            [ "$VERBOSE" == "true" ] && echo "Rev # [$r1] < [$r2]; return 2"
            return 2
        fi
    fi

    [ "$VERBOSE" == "true" ] && echo "Fell through everything, must be equal; return 0"
    return 0
}

show_result()   # show the result of vercomp comparison, in english
{ case $1 in 1) echo Greater;; 2) echo Lesser;; 0) echo Equal;; *) echo "*** Error ***";; esac }

summarize_my_extension()  # list contents of this script header (employ me with "source" or ".")
{
  CLR; myBOX 5 5 70 8
  CUP 6 24; echo -e "${BWon}script_header_brendlefly_extended${Boff}"
  CUP 8 9; echo -e "${BYon}After sourcing ${BGon}script_header_brendlefly${Boff}, ${BWon}this script ${Boff} may be "
  CUP 9 9; echo -e "sourced, in order to extend the former's definition of ${BMon}useful${Boff}"
  CUP 10 9; echo -e "${BMon}functions${Boff} to be subsequently available for use in various"
  CUP 11 9; echo -e "scripts, as described below.\n"
  CUD 5
  grep "()" /usr/local/sbin/script_header_brendlefly_extended | grep -v "grep"; echo
  message "${BYon}About to run ${BBon}message_n ${Boff}"'"${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  "'" ${BYon}and${Boff}"
  message_n "             ${BBon}vercomp ${Boff}3.4 3.4-r2${BGon}; ${BBon}echo ${BGon}-e ${Boff}"
  echo -en '"${BGon}>> "'
  echo -en "${BGon}"
  echo -en '$('
  echo -en "${BBon}show_result ${BRon}"
  echo -en '$?'
  echo -en "${BGon})${Boff}"
  echo -en '" <<${Boff}"'
  echo
  echo
  message_n "${BYon}Compare version number ${BWon}3.4 ${BYon}to${BWon} 3.4-r2${Boff}  "
  vercomp 3.4 3.4-r2; echo -e "${BGon}>> "$(show_result $?)" <<${Boff}"
  echo
  return 0
}
