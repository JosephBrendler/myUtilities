#!/bin/bash
#
# mkcrossbuildenv   joe brendler 17 April 2025
#
# interactive sequence to create a crossbuild environment (which qemu chroot)
#    for ${TARGET} system
#

# Note: as of build 0.1.4, these additional functions were moved to cb-common-functions:
#    sanity_check() display_configuration(), process_cmdline(),
#    process_argument(), process_compound_arg(), and run_sequence()
# These were already in cb-common-functions:
#    linear_search(), new_prompt(), TARGET-emerge-world(), TARGET-emerge-system(),
#    validate_target(), and validate_status_file()
# Most of these functions and most "cb-<name>" crossbuild-tools employ only one argument
#    (BOARD, status_file) or simply subsist off the environment of whichever abstract automated
#    workflow script called them or sourced cb-common-functions (cb-mkenv or cb-complete-image)
# However, usage() and initialize_variables() as well as the command_ and messageN_sequence
#    array variables will be defined somewhat differently in both of the abstract automated
#    workflow scripts (cb-mkenv and cb-complete-image)

# 20251218/19 - consolidated functions from cb-mkenv, cb-mkimg, and cb-mkupd to cb-common-functions --
# buildtarget-qemu()
# emerge-host-world()
# configure-make-conf-for-crossbuilding()
# configure-make-conf-for-chroot()
# emerge-cross-rust-std()
# rebuild-rust-and-llvm()
# prepare-cross-rust()
# run-dispatch-conf()
# edit-make-conf()
# edit-package-use-platform()
# edit-package-use-common()
# edit-package-accept-keywords()
# create-new-cross-compiler()

# 20260107 - switched from rust-std (legacy Gentoo Crossbuild-Environment wiki)
#    to rust-bin as cross-compiler for rust, with RUST_CROSS_TARGETS array
#    defined at /etc/portage/env/dev-lang/rust
#    (updated prepare-cross-rust() and deprecated emerge-cross-rust-std in cb-common-functions)
# also moved remove-default-draft-make-conf() to cb-common-functions, updated to call it from
#  configure-make-conf-for-crossbuilding() and configure-make-conf-for-chroot()
#  hence removed as separate call from cb-mkenv

source /usr/sbin/script_header_joetoo
message_n "sourcing BUILD ..."
source /etc/crossbuild-tools/BUILD ; right_status $?
message_n "sourcing BPN ..."
source /etc/crossbuild-tools/BPN ; right_status $?
source /usr/sbin/script_header_joetoo_extended

#-----[ variagles ]-----------------------------------------------------

VERBOSE=$TRUE
# set verbosity > 1 for debug incl initialization
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

PN=$(basename $0)
response=""

varlist="PN BPN BUILD BREAK BOARD TARGET TARGET_ARCH QEMU_ARCH STAGE3_SELECTOR"
varlist+=" default_profile LLVM_TARGET"
varlist+=" BREAK starting_step stopping_step mkenvstatusfile user STOCKPILE"
varlist+=" bool.RESUME bool.INTERACTIVE"
varlist+=" bool.CREATE bool.DESTROY"
varlist+=" BREAK bool.VERBOSE verbosity old_dir"

command_sequence=(
'cb-umount ${BOARD}'
'cb-cleanup ${BOARD}'
'cb-setup ${BOARD}'
'cb-mount ${BOARD}'
'wget-stage3'
'verify-stage3-hashes'
'untar-stage3'
'create-new-cross-compiler'
'eselect-profile'
'cb-populate-env ${BOARD}'
'quickpkg-toolchain'
'symlink-repos'
'TARGET-emerge-joetoo-platform-meta'
'configure-make-conf-for-crossbuilding'
'edit-make-conf'
'edit-package-use-platform'
'edit-package-use-common'
'edit-package-accept-keywords'
'prepare-cross-rust'
'rebuild-rust-and-llvm'
'TARGET-emerge-system'
'TARGET-emerge-perl-fix'
'TARGET-emerge-world'
'buildtarget-qemu'
'emerge-host-world'
'configure-make-conf-for-chroot'
'edit-make-conf'
'cb-chroot-env ${BOARD}'
'cb-umount ${BOARD}'
'stockpile-env'
)

msg1_sequence=(
'detach loop_dev and un-mount ${BOARD}.img, ${TARGET}'
'clean up crossdev environment'
'set up BOARD image'
'mount BOARD image on TARGET'
'download stage3'
'verify stage3 hashes'
'extract stage3 from tar.xz archive'
'create new cross compiler'
'eselect a profile'
'populate configs in crossbuild target environment'
'run quickpkg-toolchain'
'symlink repositories'
'${TARGET}-emerge platform-specific configs'
'configure make.conf for crossbuilding'
'edit make.conf'
'edit package.use/joetoo_platform'
'edit package.use/joetoo_common'
'edit package.accept_keywords/joetoo'
'prepare to build cross-${TARGET}/rust-bin'
'rebuild rust and llvm with new configuration if changed'
'${TARGET}-emerge @system set'
'use cb-perl-wrapper to ${TARGET}-emerge perl modules'
'${TARGET}-emerge @world set'
'build qemu binary for ${TARGET}'
'restore host with emerge -uavDNgk @world'
'configure make.conf for chroot'
'edit make.conf'
'chroot into new ${TARGET} environment'
'un-mount BOARD image'
'add image to crossbuild environment STOCKPILE'
)

#-----[ functions ]-----------------------------------------------------

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?

# usage() ... moved to script_header_joetoo_extended, suplemented by /etc/${BPN}/local.usage

initialize_variables() {
    [ $verbosity -lt 2 ] && message_n "initializing ..." || message "initializing ..."

    # save variables we have in varlist but dont want to lose
    oldVERBOSE=$VERBOSE; oldverbosity=$verbosity

    initialize_vars ${varlist}

    # set default values
    FLAGGED=$FALSE
    d_message_n "sourcing BUILD ..." 2
    source /etc/crossbuild-tools/BUILD ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting PN = $(basename $0)" 2
    PN=$(basename $0) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "sourcing BPN ..." 2
    source /etc/crossbuild-tools/BPN ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "sourcing cb-common-functions ..." 2
    source /usr/sbin/cb-common-functions ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting old_dir = $(pwd)" 2
    export old_dir=$(pwd) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting user = joe" 2
    export user="joe" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting STOCKPILE = /home/${user}/sbc-stockpile" 2
    export STOCKPILE="/home/${user}/sbc-stockpile" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default starting_step = 0" 2
    export starting_step=0 ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    export stopping_step=$(( ${#command_sequence[@]} - 1 )) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default mkenvstatusfile = /root/bin/mkcrossbuildenv_status" 2
    export mkenvstatusfile="/root/bin/mkcrossbuildenv_status" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default INTERACTIVE true" 2
    export INTERACTIVE=$TRUE ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default VERBOSE = $(TrueFalse $oldVERBOSE)" 2
    export VERBOSE=$oldVERBOSE ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default verbosity = $oldverbosity" 2
    export verbosity=$oldverbosity ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above"
        return 1
    else
        message "initialization complete"
        return 0
    fi
}

stockpile-env() {
    # (should be run after finalize-chroot-env and cb-umount have both completed)
    # copy the completed ${BOARD}.img file so it can be used as a minimal
    # start point for development of multle different individual systems
    # and/or as a distcc-cross-build or binary package server on this or
    # some other CHOST (save file as ${BOARD}.env

    copy-to-stockpile "/usr/${BOARD}.img" "${STOCKPILE%/}/${BOARD}.env"

    return 0
}

symlink-repos() {
    # for a simple crossbuild environment, we can just use the CHOST's repos
    # (we don't need to take up extra storage with what would be redundant
    #  data if our use case is simple crossbuilding or binhosting)
    # we could alternatively mount the host's repositories on empty target repo-named directories,
    # (that is what cb-chroot-env has to do), but we only link for now
    # because it is a simpler "lighter" approach to sharing the host's repos
    # for cross-building only (not for chroot)
    for x in gentoo joetoo; do
        VALID_LINK=$FALSE
        # check them first
        repo=/usr/${TARGET}/var/db/repos/${x}
	message_n "checking repo ${repo}"
        if [ -e ${repo} ] ; then
            # ${repo} already exists - is it a link or a directory?
            if [ -L ${repo} ] ; then
                # ${repo} is a link path - is it valid?
                echo -en " (${BGon}link${Boff}"
                target_path=$(readlink -f "$repo")
                if [[ "${target_path}" == "/var/db/repos/${x}" ]] ; then
                    echo -en " ${BGon}validated${Boff})"
                    right_status $TRUE
                    VALID_LINK=$TRUE
                else
                    echo -en " ${BRon}invalid${Boff})"
                    right_status 1
                fi
            elif [ -d ${repo} ] ; then
                # ${repo} (not a link), but is a directory - is it empty? (maybe relevant)
                echo -en " (${BRon}dir${Boff}"
                if [ -z "$(ls -A ${repo})" ] ; then
                    # empty
                    echo -en " empty)"
                    right_status 1
                else
                    # not empty
                    echo -en " ${BMon}not${Boff} empty)"
                    right_status 1
                    # die here so we don't have to use rm -r to remove blindly below
                    # what might be an invalid link pointing to something important
                    die "repo $x is a non-empty directory; please resolve this before resuming ${PN}"
                fi
            else
                # ${repo} exists but is neither link nor directory, so it is invalid
                echo -en " (exists; ${BRon}not link/dir: invalid${Boff})"
                right_status 1
            fi
            # if not valid, ask if user wants to remove the existing dir/link
            if [ ! $VALID_LINK ] ; then
                MSG="${BYon}Do you want to remove the invalid link/dir?${Boff}\n"
                MSG+="( y: yes, remove it; n|s: no, exit program )"
                new_prompt "${MSG}"
                if [[ "${response}" == [yY] ]] ;then
                    message_n "removing existing ${repo} ..."
                    # use %/ and don't use -r here to avoid removing
                    # important data from a non-empty directory, or
                    # what might be an invalid link pointing to something important
                    rm -r ${repo%/} 2>/dev/null || die "failed to remove existing repo"
                    right_status $TRUE
                else
                    die "not removing existing repo; exiting as instructed"
                fi
            fi
        else
            # repo does not exist
            echo -en " (does not exist)"
            right_status $TRUE
        fi
        # if we got here, repo is either already valid or does not (or no longer) exist(s)
        # create the link for it if not already valid
        if [ ! $VALID_LINK ] ; then
            message_n "creating symlink for /var/db/repos/${x}"
            ln -s /var/db/repos/${x} /usr/${TARGET}/var/db/repos/${x} || die "failed to create $x repo"
            right_status $TRUE
        fi
    done
    return 0
}

quickpkg-toolchain() {
    # build binary packages for each of the cross-toolchain programs (used to be separate script cb-quickpkg-toolchain

    toolchain=(
    'gcc'
    'glibc'
    'binutils'
    'linux-headers'
    )

    FLAGGED=$FALSE
    for tool in ${toolchain[@]}; do
        message "  building (quickpkg) binary package for ${LBon}cross-${TARGET}/${tool}${Boff}"
        quickpkg --include-unmodified-config=y cross-${TARGET}/${tool} ; result=$?
        if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi
    done
    [ $FLAGGED ] && die "failed binary package build; note red flags above"
    return 0
}

get-max-profile-number() {
    BOARD=$1
    validate_target ${BOARD} # set TARGET, TARGET_ARCH just in case not already set
    cmd="ARCH=${TARGET_ARCH}"
    cmd+=" PORTAGE_CONFIGROOT=/usr/${TARGET}/"
    cmd+=" eselect profile list |"
    cmd+=" grep '\[[0-9]\+\]' |"
    cmd+=" awk '{print \$1}' |"
    cmd+=" sed 's/\[//' |"
    cmd+=" sed 's/\]//' |"
    cmd+=" sort -n |"
    cmd+=" tail -n 1"
    result=$(eval ${cmd})
    echo $result
    return $result
}

profile_number_prompt()  {
    ps=$1; echo; echo; CUU; SCP;
    get-max-profile-number ${BOARD} >/dev/null ; max_num=$?
    message_n "$ps [0-${max_num}]: " && read profile_number;
    isnumber $profile_number ; result=$?
    while [ $result -ne 0 ] || [ $profile_number -lt 0 ] || [ $profile_number -gt ${max_num} ] ; do
        RCP; echo -en "$( repeat ' ' $( termwidth ) )"; RCP;
        message_n "$ps [0-${max_num}]: " && read profile_number;
        isnumber $profile_number ; result=$? ; done
}

eselect-profile() {
    message "setting profile ..."
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile set ${default_profile}
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list | grep '\*'
    d_message "INTERACTIVE: $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff}" 3
    if [[ $INTERACTIVE ]] ; then
        message "${BMon}Note: carefully examine your selected profile ${BYon}(e.g. merged vs split-usr)${Boff}"
        msg="${BYon}Would you like to select a different profile?\n"
        msg+="${BWon}( y: yes select new | s: no; continue with default | n: no; exit )${Boff}"
        response="" ; new_prompt "${msg}"
    else
        response="s"  # keep default profile and continue
    fi
    case ${response:0:1} in
        [yY] )
            message "${BMon}Available profiles --${Boff}"
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
            profile_number_prompt "${BYon}Select profile: ${Boff}"
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile set ${profile_number}
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
            ;;
        [nN] ) E_message "exiting as instructed"; return 0;;
        [sS] ) E_message "skipping; profile remains ${default_profile}" ;;
        * ) E_message "invalid response [ ${response} ]"; exit 1 ;;
    esac
    return 0
}

untar-stage3() {
    message_n "extracting stage3 from tar.xz archive ..."
    tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner -C /usr/${TARGET}/
    result=$? ; right_status $result ; return $result
}

verify-stage3-hashes() {
    selector='SHA512'
    SHA512_DIGEST=$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')
    SHA512_HASH="$(openssl dgst -r -sha512 stage3-*.tar.xz | awk '{print $1}')"

    selector='BLAKE2B'
    BLAKE2B_DIGEST=$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')
    BLAKE2B_HASH="$(openssl dgst -r -blake2b512 stage3-*.tar.xz | awk '{print $1}')"
    d_message "SHA512_DIGEST..: ${SHA512_DIGEST}" 3
    d_message "SHA512_HASH....: ${SHA512_HASH}" 3
    d_message "BLAKE2B_DIGEST.: ${BLAKE2B_DIGEST}" 3
    d_message "BLAKE2B_HASH...: ${BLAKE2B_HASH}" 3

    if [[ "${SHA512_DIGEST}" != "${SHA512_HASH}" ]] ; then
        E_message "openssl sha512 hash has does not match digest"
        return 1
    elif [[ "${BLAKE2B_DIGEST}" != "${BLAKE2B_HASH}" ]] ; then
        E_message "openssl blake2b512 hash has does not match digest"
        return 1
    else
        message_n "openssl sha512 and blake2b512 hashes both ${BGon}match${Boff} digest"
        right_status $TRUE
    fi
    return 0
}

wget-stage3() {
    local old_dir="$(pwd)"
    local target_dir="/usr/${TARGET}"
    local download_url="https://www.gentoo.org/downloads/#${TARGET_ARCH}"

    message_n "Moving from ${old_dir} to ${target_dir} ..."
    cd "${target_dir}" || { message "Failed to enter ${target_dir}"; return 1; }
    right_status $?

    # Fetch the download page with a timeout and retry logic
    message_n "fetching Gentoo download page ..."
    local html_content
    # -f, --fail                  Fail fast with no output on HTTP errors
    # -s, --silent                Silent mode
    # -L, --location              makes curl redo the request to the new place if page has moved
    # --connect-timeout <seconds> max time that curl's connection is allowed to take
    # --retry <num>               retry this number of times before giving up
    html_content=$(curl -f -s -L --connect-timeout 15 --retry 3 "${download_url}" 2>/dev/null)
    if [[ $? -ne 0 || -z "${html_content}" ]]; then
        right_status 1
        E_message "${BRon}Error${Boff}: Failed to reach Gentoo downloads page or page is empty"
        return 1
    else
        right_status $TRUE
    fi

    # Extract the href so we can use it as an assignment of the link to the stage3 tarball
    message_n "extracting href to formulate link to stage3 tarball ..."
    # (look specifically for the .tar.xz link matching ${STAGE3_SELECTOR}
    local raw_stage3_link
    # -P, --perl-regexp         PATTERNS are Perl regular expressions
    # -o, --only-matching       show only nonempty parts of lines that match
    # href=\"                   looks for the literal text href="; anchors the search to an actual HTML link attribute
    # \K                        ignore everything before this marker (with -o also excludes it from output)
    # [^\"]+                    match one or more characters that are NOT a double-quote ([^ ... ] is a negated character class)
    # ${STAGE3_SELECTOR}        match the ${STAGE3_SELECTOR} sourced by target's /root/.cb_config
    # [^\"]+                    again match any characters not a quote, incl timestamp and rest of filename after selector
    # \.tar\.xz                 match the literal filename extension .tar.xz
    # 2>/dev/null               be quiet
    # | head -n 1               take only the first, if there happen to be multiple matches
    raw_stage3_link=$(grep -oP "href=\"\K[^\"]+${STAGE3_SELECTOR}[^\"]+\.tar\.xz" 2>/dev/null <<< "${html_content}" | head -n 1)

    if [[ -z "${raw_stage3_link}" ]]; then
        right_status 1
        E_message "${BRon}Error${Boff}: Could not find a stage3 link matching [${STAGE3_SELECTOR}] for [${TARGET_ARCH}]"
        return 1
    else
        right_status $TRUE
        message "${LBon}raw_stage3_link${Boff}: ${Mon}${raw_stage3_link}${Boff}"
    fi

    message_n "constructing final url for stage3 tarball ..."
    # Clean the path of any leading slash, just in case this is a root-relative path
    local clean_path="${raw_stage3_link#/}" || { E_message "failed to assign clean_path=${raw_stage3_link#/}"; return 1; }
    # Strip trailing slash (prevents ...tar.xz/)
    clean_path="${clean_path%/}" || { E_message "failed to assign clean_path=${clean_path%/}"; return 1; }

    # Construct full URL (test in case it is relative)
    # If the link starts with http, use it as is, otherwise, prepend the mirror
    local final_url
    if [[ "${clean_path}" =~ ^http ]]; then
        final_url="${clean_path}" || { E_message "failed to assign final_url=${clean_path}"; return 1; }
    else
        # prepend mirror and remove any trailing spaces with "# "
        final_url="https://distfiles.gentoo.org/${clean_path}" || { E_message "failed to assign final_url=${https://distfiles.gentoo.org/${clean_path}"; return 1; }
    fi

    message "Downloading: ${full_url}"
    wget -c --show-progress "${full_url}" && wget -c "${full_url}.DIGESTS"

    return $?
}

#-----[ main script ]---------------------------------------------
checkroot
separator ${PN} $(hostname)
# option s (status) is the only one that can appear alone on the command line
# - otherwise it should be at least 2: -b <BOARD>
arglist="$@"
[ $# -eq 0 ] && E_message "null command line arguments" && usage
[ $# -eq 1 ] && [[ "$1" != "-s"* ]] && [[ "$1" != "--status" ]] && E_message "invalid argument(s) [$arglist]" && usage
[ $# -lt 2 ] && E_message "invalid argument(s) [$arglist]" && usage

# basic common approach -
# initialize variables (local function)
# validate_status_file  (script_header_joetoo_extended)
# process_cmdline (script_header_joetoo_extended)
# validate_target which must follow process_cmdline (cb-common-functions)
# display_configuration so we can see what's what if insane (script_header_joetoo_extended)
# sanity_check (cb-common-functions)
# run_sequence (script_header_joetoo_extended)

# initialize variables and set default values
initialize_variables || die "Failed to initialize_variables"

validate_status_file ${mkenvstatusfile} || die "Failed to validate_status_file"

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5

# over-ride configuration with commandline input
separator ${PN} "(process_cmdline)"
process_cmdline ${@} || usage

validate_target ${BOARD} || usage
display_configuration || die "Failed to display_configuration"

sanity_check  || die "Failed sanity_check"
run_sequence ${mkenvstatusfile} || die "Failed to run_sequence"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0
