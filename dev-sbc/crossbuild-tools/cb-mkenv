#!/bin/bash
#
# mkcrossbuildenv   joe brendler 17 April 2025
#
# interactive sequence to create a crossbuild environment (which qemu chroot)
#    for ${TARGET} system
#

# Note: as of build 0.1.4, these additional functions were moved to cb-common-functions:
#    sanity_check() display_configuration(), process_cmdline(),
#    process_argument(), process_compound_arg(), and run_sequence()
# These were already in cb-common-functions:
#    linear_search(), new_prompt(), TARGET-emerge-world(), TARGET-emerge-system(),
#    validate_target(), and validate_status_file()
# Most of these functions and most "cb-<name>" crossbuild-tools employ only one argument
#    (BOARD, status_file) or simply subsist off the environment of whichever abstract automated
#    workflow script called them or sourced cb-common-functions (cb-mkenv or cb-complete-image)
# However, usage() and initialize_variables() as well as the command_ and messageN_sequence
#    array variables will be defined somewhat differently in both of the abstract automated
#    workflow scripts (cb-mkenv and cb-complete-image)

source /usr/sbin/script_header_joetoo
message_n "sourcing BUILD ..."
source /etc/crossbuild-tools/BUILD ; right_status $?
message_n "sourcing BPN ..."
source /etc/crossbuild-tools/BPN ; right_status $?
source /usr/sbin/script_header_joetoo_extended

#-----[ variagles ]-----------------------------------------------------

VERBOSE=$TRUE
# set verbosity > 1 for debug incl initialization
#verbosity=1
verbosity=2
PN=$(basename $0)
response=""

varlist="PN BPN BUILD BOARD TARGET TARGET_ARCH QEMU_ARCH STAGE3_SELECTOR"
varlist+=" profile_number"
varlist+=" starting_step stopping_step mkenvstatusfile"
varlist+=" bool.RESUME bool.INTERACTIVE"
varlist+=" bool.CREATE bool.DESTROY"
varlist+=" BREAK bool.VERBOSE verbosity old_dir"

command_sequence=(
'cb-umount ${BOARD}'
'cb-cleanup ${BOARD}'
'cb-setup ${BOARD}'
'cb-mount ${BOARD}'
'wget-stage3'
'verify-stage3-hashes'
'untar-stage3'
'create-new-cross-compiler'
'eselect-profile'
'cb-quickpkg-toolchain ${BOARD}'
'cb-populate-target ${BOARD}'
'symlink-repos'
'TARGET-emerge-system'
'TARGET-emerge-world'
'cb-buildtarget-qemu ${BOARD}'
'emerge-host-world'
'emerge-cross-rust-std'
'cb-chroot-target ${BOARD}'
)

msg1_sequence=(
'detach loop_dev and un-mount ${BOARD}.img, ${TARGET}'
'clean up crossdev environment'
'set up BOARD image'
'mount BOARD image on TARGET'
'download stage3'
'verify stage3 hashes'
'extract stage3 from tar.xz archive'
'create new cross compiler'
'eselect a profile'
'create crossbuild toolchain binary packages with quickpgk'
'populate configs in crossbuild target environment'
'symlink repositories'
'${TARGET}-emerge @system set'
'${TARGET}-emerge @world set'
'build qemu binary for ${TARGET}'
'restore host with emerge -uavDNgk @world'
'emerge cross-${TARGET}/rust-std'
'chroot into new ${TARGET} environment'
)

msg2_sequence=(
'detaching loop_dev and un-mounting ${BOARD}.img, ${TARGET}'
'cleaning up crossdev environment'
'settin up BOARD image'
'mounting BOARD image on TARGET'
'downloading stage3'
'verifying stage3 hashes'
'extracting stage3 from tar.xz archive'
'creating new cross compiler'
'eselecting profile'
'creating crossbuild toolchain binary packages with quickpgk'
'populating configs in crossbuild target environment'
'symlinking repositories'
'${TARGET}-emerging @system set'
'${TARGET}-emerging @world set'
'building qemu binary for ${TARGET}'
'restoring host with emerge -uavDNgk @world'
'emerging cross-${TARGET}/rust-std'
'chrooting into new ${TARGET} environment'
)

#-----[ functions ]-----------------------------------------------------

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?

# usage() ... moved to script_header_joetoo_extended, suplemented by /etc/${BPN}/local.usage

initialize_variables() {
    [ $verbosity -lt 2 ] && message_n "initializing ..." || message "initializing ..."
    initialize_vars ${varlist}

    # set default values
    FLAGGED=$FALSE
    d_message_n "sourcing BUILD ..." 2
    source /etc/crossbuild-tools/BUILD && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting PN = $(basename $0)" 2
    PN=$(basename $0) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "sourcing BPN ..." 2
    source /etc/crossbuild-tools/BPN && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting old_dir = $(pwd)" 2
    export old_dir=$(pwd) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default starting_step = 0" 2
    export starting_step=0 && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    export stopping_step=$(( ${#command_sequence[@]} - 1 )) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default mkenvstatusfile = /root/bin/mkcrossbuildenv_status" 2
    export mkenvstatusfile="/root/bin/mkcrossbuildenv_status" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default INTERACTIVE true" 2
    export INTERACTIVE=$TRUE && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default VERBOSE true" 2
    export VERBOSE=$TRUE && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default verbosity = 3" 2
    export verbosity=3 && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above"
        return 1
    else
        message "initialization complete"
        return 0
    fi
}

emerge-host-world() {
    [[ $INTERACTIVE ]] && emerge_options="-uavDNgk" || emerge_options="-uvDNgk"
    emerge ${emerge_options} @world --keep-going
    result=$?
    return $result
}

emerge-cross-rust-std() {
    # this doesn't work yet
#    emerge -av cross-${TARGET}/rust-std
    E_message "emerge -av cross-${TARGET}/rust-std doesn't work... skip for now"
    return 0
}

symlink-repos() {
    # for a simple crossbuild environment, we can just use the CHOST's repos
    # (we don't need to take up extra storage with what would be redundant
    #  data if our use case is simple crossbuilding or binhosting)
    for x in gentoo joetoo; do
        VALID_LINK=$FALSE
        # check them first
        repo=/usr/${TARGET}/var/db/repos/${x}
	message_n "checking repo ${repo}"
        if [ -e ${repo} ] ; then
            # ${repo} already exists - is it a link or a directory?
            if [ -L ${repo} ] ; then
                # ${repo} is a link path - is it valid?
                echo -en " (${BGon}link${Boff}"
                target_path=$(readlink -f "$repo")
                if [[ "${target_path}" == "/var/db/repos/${x}" ]] ; then
                    echo -en " ${BGon}validated${Boff})"
                    right_status $TRUE
                    VALID_LINK=$TRUE
                else
                    echo -en " ${BRon}invalid${Boff})"
                    right_status 1
                fi
            elif [ -d ${repo} ] ; then
                # ${repo} (not a link), but is a directory - is it empty? (maybe relevant)
                echo -en " (${BRon}dir${Boff}"
                if [ -z "$(ls -A ${repo})" ] ; then
                    # empty
                    echo -en " empty)"
                    right_status 1
                else
                    # not empty
                    echo -en " ${BMon}not${Boff} empty)"
                    right_status 1
                    # die here so we don't have to use rm -r to remove blindly below
                    # what might be an invalid link pointing to something important
                    die "repo $x is a non-empty directory; please resolve this before resuming ${PN}"
                fi
            else
                # ${repo} exists but is neither link nor directory, so it is invalid
                echo -en " (exists; ${BRon}not link/dir: invalid${Boff})"
                right_status 1
            fi
            # if not valid, ask if user wants to remove the existing dir/link
            if [ ! $VALID_LINK ] ; then
                MSG="${BYon}Do you want to remove the invalid link/dir?${Boff}\n"
                MSG+="( y: yes, remove it; n|s: no, exit program )"
                new_prompt "${MSG}"
                if [[ "${response}" == [yY] ]] ;then
                    message_n "removing existing ${repo} ..."
                    # use %/ and don't use -r here to avoid removing
                    # important data from a non-empty directory, or
                    # what might be an invalid link pointing to something important
                    rm -r ${repo%/} 2>/dev/null && right_status $? || die "failed to remove existing repo"
                else
                    die "not removing existing repo; exiting as instructed"
                fi
            fi
        else
            # repo does not exist
            echo -en " (does not exist)"
            right_status $TRUE
        fi
        # if we got here, repo is either already valid or does not (or no longer) exist(s)
        # create the link for it if not already valid
        if [ ! $VALID_LINK ] ; then
            message_n "creating symlink for /var/db/repos/${x}"
            ln -s /var/db/repos/${x} /usr/${TARGET}/var/db/repos/${x} && \
                right_status $? || die "failed to create $x repo"
        fi
    done
    return 0
}

get-max-profile-number() {
    BOARD=$1
    validate_target ${BOARD} # set TARGET, TARGET_ARCH just in case not already set
    cmd="ARCH=${TARGET_ARCH}"
    cmd+=" PORTAGE_CONFIGROOT=/usr/${TARGET}/"
    cmd+=" eselect profile list |"
    cmd+=" grep '\[[0-9]\+\]' |"
    cmd+=" awk '{print \$1}' |"
    cmd+=" sed 's/\[//' |"
    cmd+=" sed 's/\]//' |"
    cmd+=" sort -n |"
    cmd+=" tail -n 1"
    result=$(eval ${cmd})
    echo $result
    return $result
}

profile_number_prompt()  {
    ps=$1; echo; echo; CUU; SCP;
    get-max-profile-number ${BOARD} >/dev/null ; max_num=$?
    message_n "$ps [0-${max_num}]: " && read profile_number;
    isnumber $profile_number ; result=$?
    while [ $result -ne 0 ] || [ $profile_number -lt 0 ] || [ $profile_number -gt ${max_num} ] ; do
        RCP; echo -en "$( repeat ' ' $( termwidth ) )"; RCP;
        message_n "$ps [0-${max_num}]: " && read profile_number;
        isnumber $profile_number ; result=$? ; done
}

eselect-profile() {
    message "setting default profile ..."
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile set ${profile_number}
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list | grep '\*'
    d_message "INTERACTIVE: $(status_color $INTERACTIVE)$(TrueFalse $INTERACTIVE)${Boff}" 3
    if [[ $INTERACTIVE ]] ; then
        message "${BMon}Note: carefully examine your selected profile ${BYon}(e.g. merged vs split-usr)${Boff}"
        msg="${BYon}Would you like to select a diffeeent profile?\n"
        msg+="${BWon}    y: yes select new | s: no; continue with default | n: no; exit${Boff}"
        response="" ; new_prompt "${msg}"
    else
        response="s"  # keep default profile and continue
    fi
    case ${response:0:1} in
        [yY] )
            message "${BMon}Available profiles --${Boff}"
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
            profile_number_prompt "${BYon}Select profile: ${Boff}"
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile set ${profile_number}
            ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
            ;;
        [nN] ) E_message "exiting as instructed"; return 0;;
        [sS] ) E_message "skipping; profile remains ${profile_number}" ;;
        * ) E_message "invalid response [ ${response} ]"; exit 1 ;;
    esac
    return 0
}

create-new-cross-compiler() {
    message "creating new crossdev cross compiler. Done after stage3 extraction"
    message "because crossdev may produce split-usr layout, and I prefer the"
    message "merged-usr layout that modern stage3 provides ..."
    echo
    FLAGGED=$FALSE
    for x in profiles metadata; do
        target_dir="/var/db/repos/crossdev/${x}"
        message_n "validating ${target_dir} ..."
        if [ ! -d ${target_dir} ] ; then
            echo -en " (${BYon}creating${Boff})"
            mkdir -p ${target_dir} && right_status $? || ( right_status $? && FLAGGED=$TRUE )
        else
            echo -en " (${BGon}valid${Boff})"
            right_status $TRUE
        fi
    done

    # validate or populate /var/db/repos/crossdev/metadata/layout.conf
    message_n "validating /var/db/repos/crossdev/metadata/layout.conf ..."
    if [ ! -f /var/db/repos/crossdev/metadata/layout.conf ] || \
       [ -z "$(grep 'masters = gentoo' /var/db/repos/crossdev/metadata/layout.conf 2>/dev/null)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'masters = gentoo' > /var/db/repos/crossdev/metadata/layout.conf && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # validate or populate /var/db/repos/crossdev/profiles/repo_name
    message_n "validating /var/db/repos/crossdev/profiles/repo_name ..."
    if [ ! -f /var/db/repos/crossdev/profiles/repo_name ] || \
       [ -z "$(grep 'crossdev' /var/db/repos/crossdev/profiles/repo_name)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'crossdev' > /var/db/repos/crossdev/profiles/repo_name && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # set permissions
    message_n "setting permission for portate on /var/db/repos/crossdev ..."
    chown -R portage:portage /var/db/repos/crossdev && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )

    # now actually build the new cross-compiler
    message "building new cross-compiler ..."
    crossdev -S -t ${TARGET} && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )
    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above" ; return 1
    else
        message "cross-compiler creation complete" ; return 0
    fi
}

untar-stage3() {
    message_n "extracting stage3 from tar.xz archive ..."
    tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner -C /usr/${TARGET}/
    result=$? ; right_status $result ; return $result
}

verify-stage3-hashes() {
    selector='SHA512'
    SHA512_DIGEST=$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')
    SHA512_HASH="$(openssl dgst -r -sha512 stage3-*.tar.xz | awk '{print $1}')"

    selector='BLAKE2B'
    BLAKE2B_DIGEST=$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')
    BLAKE2B_HASH="$(openssl dgst -r -blake2b512 stage3-*.tar.xz | awk '{print $1}')"
    d_message "SHA512_DIGEST..: ${SHA512_DIGEST}" 3
    d_message "SHA512_HASH....: ${SHA512_HASH}" 3
    d_message "BLAKE2B_DIGEST.: ${BLAKE2B_DIGEST}" 3
    d_message "BLAKE2B_HASH...: ${BLAKE2B_HASH}" 3

    if [[ "${SHA512_DIGEST}" != "${SHA512_HASH}" ]] ; then
        E_message "openssl sha512 hash has does not match digest"
        return 1
    elif [[ "${BLAKE2B_DIGEST}" != "${BLAKE2B_HASH}" ]] ; then
        E_message "openssl blake2b512 hash has does not match digest"
        return 1
    else
        message_n "openssl sha512 and blake2b512 hashes both ${BGon}match${Boff} digest"
        right_status $TRUE
    fi
    return 0
}

wget-stage3() {
    old_dir="$(pwd)"
    message_n "moving from ${old_dir} to /usr/${TARGET} ..."
    cd /usr/${TARGET} ; right_status $?
    message "now getting stage3 in target sysroot directory: [${Mon}$(pwd)${Boff}] ..."
#    eval "$(grep ${STAGE3_SELECTOR} <<< $(curl -s https://www.gentoo.org/downloads/#arm) | awk '{print $2}')" && \
    eval "$(grep ${STAGE3_SELECTOR} <<< $(curl -s https://www.gentoo.org/downloads/#${TARGET_ARCH}) | awk '{print $2}')"
    wget ${href} && wget ${href}.DIGESTS
    return $?
}

#-----[ main script ]---------------------------------------------
checkroot
separator ${PN} $(hostname)
# option s (status) is the only one that can appear alone on the command line
if [ $# -eq 1 ] ; then if [[ "$1" != "-"*"s"* ]] && [[ "$1" != "--status" ]] ; then
    E_message "invalid argument [${arglist}]"
    usage
fi; fi

# basic common approach - 
# initialize variables (local function)
# validate_status_file  (script_header_joetoo_extended)
# process_cmdline (script_header_joetoo_extended)
# validate_target which must follow process_cmdline (cb-common-functions)
# display_configuration so we can see what's what if insane (script_header_joetoo_extended)
# sanity_check (cb-common-functions)
# run_sequence (script_header_joetoo_extended)

# initialize variables and set default values
initialize_variables || die "Failed to initialize_variables"

validate_status_file ${mkenvstatusfile} || die "Failed to validate_status_file"

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5

# over-ride configuration with commandline input
separator ${PN} "(process_cmdline)"
process_cmdline ${@} || die "Failed to process_cmdline"

validate_target ${BOARD} || die "Failed to validate_target [${BOARD}]"
display_configuration || die "Failed to display_configuration"

sanity_check  || die "Failed sanity_check"
run_sequence ${mkenvstatusfile} || die "Failed to run_sequence"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0
