#!/bin/bash
#
# cb-umount   (c) joe.brendler  2025-2072
# un-mount a crossbuild image file from its associated TARGET
#

source /usr/sbin/script_header_joetoo
message_n "sourcing BUILD ..."
source /etc/crossbuild-tools/BUILD ; right_status $?
message_n "sourcing BPN ..."
source /etc/crossbuild-tools/BPN ; right_status $?
source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

PN=$(basename $0)

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?
TARGET=""

usage() {
    message "${BRon}usage: ${BGon}${PN} <BOARD>${Boff}"
    smaller_script_common_usage_message
    exit 1
}

umount-board() {
    # inspect target (mount point) - is anything mounted? (un-mount)
    if [ ! -z "$(findmnt -n -M /usr/${TARGET})" ] ; then
        # something is mounted - display, offer to zero-fill, and then un-mount it
        E_message "${BYon}the following devices are mounted on /usr/${TARGET} --${Boff}"
        mount | grep "on /usr/${TARGET}" | sed 's|^|    |'

        response=""
        msg="${BYon}Do you want to zero-fill and resparsify this image?${Boff}\n"
        msg+="${BWon}(y|Y: yes; s|S: skip; n|N: no, abort) ${Boff}"
        new_prompt "${msg}"
        case ${response:0:1} in
            [yY] )  # zero-fill and remove empty space to facilitate "resparsification" of sparse image
                message "zero-filling empty space"
                # zero-fill and ignore "No space left on device" ...
                dd if=/dev/zero of=/usr/${TARGET}/ZERO_FILL bs=1M status=progress 2>&1 | grep -v "No space left"
                true # reset error code and continue
                sync; echo -e "${BGon}done${Boff}" ; right_status $TRUE
                message_n "removing zero-fill"
                rm /usr/${TARGET}/ZERO_FILL 2>/dev/null || die "failed to remove zero-fill"
                sync; echo -e -n " (${BGon}done${Boff})" ; right_status $TRUE
                # note: complete "resparsification" with fallocate after detaching
                ;;
            [sS] ) message "skipping, as instructed" ;;
            *    ) die "aborting, as instructed" ;;
        esac

        # now un-mount the special chroot-parts from the image mountpoint
        message_n "umounting chroot parts from /usr/${TARGET%/}/ ..."
	umount -l /usr/${TARGET}/dev{/shm,/pts,} 2>/dev/null ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1
                E_message "umount -l /usr/${TARGET}/dev{/shm,/pts,} failed! Exit status: [${Mon}$result${Boff}]"
                ;;  # non-fatal; continue anyway
        esac

        # check pwd - if inside the image's mountpoint, cd elsewhere
        if [[ "$PWD" == "/usr/${TARGET}/"* ]] ; then
            message_n "relocating from $PWD to safe location for umount "
            cd /usr/ || die "relocation failed"
            echo -e -n " (${BYon}new PWD: ${LBon}$PWD${Boff})"
            right_status $TRUE
        fi

        # now un-mount the image (recursively)
        message_n "recursively umounting /usr/${TARGET} ..."
        umount -R /usr/${TARGET} ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1
                die "failed to umount -R /usr/${TARGET}"
                ;;  # fatal; user will have to resume to finish cb-umount
        esac
        right_status $TRUE

        # run fsck with optimization
        message_n "optimizing directory indexes with e2fsck -fD ..."
        # -f forces check, -D optimizes/reindexes, -y assumes yes to all
        e2fsck -fD /dev/loop0p2 -y >/dev/null 2>&1
        result=$?
        case $result in
            0|1|2 ) right_status $TRUE ;;  # 0: clean; 1: fixed; 2: fixed->reboot (N/A for .img)
            * ) die "${BRon}e2fsck failed!${Boff} exit code: [${Mon}${result}${Boff}]"
                ;;  # fatal; user will have to resume to finish cb-umount
        esac
    else
        message "nothing is mounted on /usr/${TARGET} ; continuing"
    fi

    # inspect for loop devices attached to BOARD image file and detach them
    message "looking for loop device attached to /usr/${BOARD}.img ..."
    loop_dev=$(losetup -a | grep "/usr/${BOARD}.img" | cut -d':' -f1)
    if [ -b "${loop_dev}" ] ; then
        message_n "detaching ${loop_dev} ..."
        losetup -d ${loop_dev} || die "failed to detach ${loop_dev}"
        right_status $TRUE
    else
        message "no loop device is attached to /usr/${BOARD}.img ; continuing"
    fi

    # use fallocate to resparsify the image file
    if [ -f /usr/${BOARD}.img ] ; then
        response=""
        msg="${BYon}Do you want to remove zero-filled space (resparsify) this image?${Boff}\n"
        msg+="${BWon}(y|Y: yes; s|S: skip; n|N: no, abort) ${Boff}"
        new_prompt "${msg}"
        case ${response:0:1} in
            [yY] )  # zero-fill and remove empty space to facilitate "resparsification" of sparse image
                message_n "using ${BBon}fallocate ${BMon}-d${Boff} to resparsify /usr/${BOARD}.img"
                fallocate -d /usr/${BOARD}.img  || die "failed to resparsify /usr/${BOARD}.img"
                right_status $TRUE
                apparent_size=$(du -h --apparent-size /usr/${BOARD}.img | awk '{print $1}')
                actual_size=$(du -h /usr/${BOARD}.img | awk '{print $1}')
                message "${BYon}/usr/${BOARD}.img${Boff} apparent: ${Mon}${apparent_size}${Boff} actual: ${Gon}${actual_size}${Boff}"
                ;;
            [sS] ) message "skipping, as instructed" ;;
            *    ) die "aborting, as instructed" ;;
        esac
    else
        message "no /usr/${BOARD}.img exists; resparsification skipped"
    fi
    return 0
}

#-----[ main script ]---------------------------------------------
checkroot
separator "(${BOARD})" "${PN}"
[ $# -ne 1 ] && usage
BOARD=$1
validate_target ${BOARD} || die "Failed to validate_target [${BOARD}]"

old_dir="$(pwd)"
cd /usr/
message "now working in parent of crossbuild target directory: [${Mon}$(pwd)${Boff}]"

umount-board

echo
cd $old_dir
message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
exit 0
