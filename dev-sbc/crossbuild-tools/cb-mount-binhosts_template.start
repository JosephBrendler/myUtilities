#!/bin/bash
#
# the purpose of this .start script is to facilitate the use of
# stockpiled crossbuilt images for use as binary package hosts

source /usr/sbin/script_header_joetoo
source /usr/sbin/script_header_joetoo_extended
source /usr/sbin/script_header_joetoo_unicode
source /usr/sbin/cb-common-functions

#-----[ user variables ]--------------------------------------------------------------------------
user="joe"
stockpile_dir="/home/${user}/sbc-stockpile"
binhost_mountpoint_dir="/mnt"
webroot="/var/www/localhost/htdocs/"
pkg_website="${webroot%/}/packages"

# you have to have crossbuilt image(s) in a stockpile to make this work, so let's start there -

# identify the board names for which .env or .img files are available to use as backends
# for web-hosting binary package services. ( .env and/or .img files in /home/${user}/sbc-stockpile )
# HINT: in a separate terminal, run the list_boards() function below and then pick which you want to include here

# mannually assign them in this array
declare -a boards=()         # array of board names for which we have backing files available in stockpile
boards=(
bcm2708-rpi-b
bcm2709-rpi-2-b
)
#boards=(
#bcm2708-rpi-b
#bcm2709-rpi-2-b
#rk3588-radxa-rock-5b+
#meson-gxl-s905x-libretech-cc-v2
#meson-sm1-s905d3-libretech-cc
#meson-g12b-a311d-libretech-cc
#)

# alternatively, you can do this automatically and just rely on pick_best_backing_file
AUTOMATIC=$TRUE
#AUTOMATIC=$FALSE

#-----[ non-user variables ]--------------------------------------------------------------------------
PN=$(basename $0)
VERBOSE=$TRUE
#verbosity=5
#VERBOSE=$FALSE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3
#[ -z $verbosity ] && verbosity=5

bh=""     # identify binhost name for board
link=""   # identify weblink to binpkgs for board

declare -a bh_boards=()     # array of board names that are candidate binhosts
declare -a backing_files=()       # array of all candidate backing files
declare -a backing_file_chunck=() # array of some candidate backing files
declare -a img_candidates=()      # array of .img candidate backing files (preferred)
declare -a env_candidates=()      # array of .env candidate backing files

backing_file=""

#-----[ functions ]--------------------------------------------------------------------------

# list boards - maybe useful but not used here
list_boards() {
    # send sorted list of boards to stdout
    for board in ${boards[@]} ; do echo $board; done | sort -u || return 1
    # HINT: run this command manually to create a list and then pick which you want to include above
    return 0
}

# list backing files - maybe useful but not used here
list_backing_files() {
    # send sorted list of backing files to stdout
    for file in ${backing_files[@]}; do echo $file; done
}

load_boards() {
    d_message "in ${FUNCNAME[0]}" 5
    # populate array with names of boards for which we have .emv or .img files available in stockpile
    # -z flag tells sed to use null char (\0) as line delimiter instead of newline (\n)
    # first substitution: (s|.*/||) removes the leading path
    #   (delim: | regex: .*/ = any char . zero+ times followed by /)
    # second substitution: (s/\.\(env\|img\)$//) removes .env or .img filename extensions
    #   (delim: / regex \. = dot \( \) = escaped parens for \| = escaped "or" between env & img ; $ = right end of line)
    # third substitution: (s/_[^_]*$//) removes any remaining suffix following underscore
    #   (e.g. _hostname in board_hostname.img)
    #   (delim: / regex: _ = underscore ; [^_]*$ = any # of non-underscore chars; $ = at the right end of line)
    # tr translates the null char line delimiters back to newlines for mapfile -t
    # sort -u eliminates duplicates and passes an ordered list to mapfile (aka readarray)
    mapfile -t boards < <(find "$stockpile_dir" -maxdepth 1 -type f \
        \( -name '*.env' -o -name '*.img' \) -print0 \
        | sed -z 's|.*/||; s/\.\(env\|img\)$//; s/_[^_]*$//' \
        | tr '\0' '\n' \
        | sort -u)  || return 1
    return 0
}

load_backing_files() {
    d_message "in ${FUNCNAME[0]}" 5
    # populate array with filenames available to back a binhost for $1 (brd)
    local brd=$1
    # if there are more than one board that can serve as bh, load the others, too
    # identify the binhost and weblink to binpkgs for this board
    id_binhost_and_link_for_board ${brd}
    d_message "  bh: $bh ; link: $link" 3
    id_boards_for_binhost ${bh}  # loads array bh_boards
    backing_files=()             # re-initialize arrays
    backing_file_chunck=()       # re-initialize arrays
    # load filenames that are a binhost-match for brd
    for bh_board in ${bh_boards[@]}; do
        d_message_n "  loading backing files for binhost-[${bh}]-matching board [${bh_board}]" 3
        # match all backing file candidates that start <board>. or <board>_ (but not <board>-)
        # (e.g. for bcm2710-rpi-3-b, match bcm2710-rpi-3-b.env and bcm2710-rpi-3-b_raspi332q1.img,
        #    but NOT bcm2710-rpi-3-b-plus.env or bcm2710-rpi-3-b-plus_raspi36402.img )
        mapfile -t backing_file_chunck < <(find "$stockpile_dir" -maxdepth 1 -type f \
            \( -name '*.env' -o -name '*.img' \) -printf '%f\n' | grep ${bh_board}[._] )
        # add chunk to array if it isn't empty
        if [ ${#backing_file_chunck[@]} -gt 0 ] ; then
            backing_files+=(${backing_file_chunck[@]})
            result=$?
            if [ $result -eq 0 ] ; then
                d_right_status $TRUE 3
            else
                die "failed to load backing files for bh_board [$bh_board]"
            fi # 0 result
        else
            echo
            dE_message "no backing files found for candidate board [${bh_board}]" 3
        fi # -gt 0
    done
    return 0
}

# moved id_binhost_and_link_for_board() to cb-common-functions
# moved id_boards_for_binhost() to cb-common-functions

setup_mountpoints_and_weblinks() {
    separator "${PN}" "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 5
    # look up each board to be included and set up its mountpoint and its web-hosting link to binpkgs
    for board in ${boards[@]} ; do
        d_message "${LBon}board: $board${Boff}" 2
        # identify the binhost and weblink to binpkgs for this board
        id_binhost_and_link_for_board ${board}
        d_message "  bh: ${bh} ; link: ${link}" 2
        # if the mount point does not exist, create it
        d_message_n "checking mountpoint" 2
        if [ ! -d "${binhost_mountpoint_dir%/}/${bh}_binhost" ] ; then
            debug_do 'echo -e -n " (${BYon}creating${Boff})"' 2
            mkdir -p "${binhost_mountpoint_dir%/}/${bh}_binhost" ; result=$?
            if [ ! $result -eq 0 ] ; then
                logger -p cron.err "$PN failed to mkdir -p binhost_mountpoint for  board [$board]"
                echo; die "failed to mkdir -p binhost_mountpoint for board [$board]"
            fi
            logger -p cron.notice "$PN created mountpoint ${binhost_mountpoint_dir%/}/${bh}_binhost for board [$board]"
        else
            debug_do 'echo -e -n " (${BGon}exists${Boff})"' 2
        fi
        d_right_status $TRUE 2
        # if the web-hosting link to binpkgs doesn't exist, create it
        d_message_n "checking web-link to binpkgs" 2
        if [ ! -L "${pkg_website%/}/${link}" ] ; then
            debug_do 'echo -e -n " (${BYon}creating${Boff})"' 2
            # identify the target for binpkgs to which we want to link
            link_target="${binhost_mountpoint_dir%/}/${bh}_binhost/var/cache/binpkgs"
            d_message "link_target: $link_target" 5
            d_message "pkg_website: $pkg_website" 5
            d_message "link: $link" 5
            ln -s "${link_target}" "${pkg_website%/}/${link}" ; result=$?
            if [ ! $result -eq 0 ] ; then
                logger -p cron.err "$PN failed to create weblink [${link}] for board [$board]"
                echo; die "failed to create web-link for $board"
            fi
            logger -p cron.notice "$PN created weblink [${link}] for board [$board]"
        else
            debug_do 'echo -e -n " (${BGon}exists${Boff})"' 2
        fi
        d_right_status $TRUE 2
    done
    return 0
}

find_newest_file() {
    local file=""
    local newest_file=""
    local newest_time=0
    local file_list=("${@}")
    # If the file list is empty, return an empty string
    if [[ ${#file_list[@]} -eq 0 ]]; then echo ""; return 1; fi
    # iterate through file_list and compare modification time
    for file in "${file_list[@]}"; do
        local file_path="$stockpile_dir/$file"
        # Check if the file exists before attempting to get its modification time
        if [[ ! -f "$file_path" ]]; then continue; fi   # continue jumps out to next iteration in for loop
        # Use stat to get the modification time in seconds since the epoch
        local mod_time=$(stat -c %Y "$file_path")
        # Compare and find the newest
        if [[ $mod_time -gt $newest_time ]]; then
            newest_time=$mod_time
            newest_file="$file"
        fi
    done
    echo "$newest_file"
    return 0
}

pick_and_mount_best_backing_file() {
    separator "${PN}" "(${FUNCNAME[0]})"
#    d_message "in ${FUNCNAME[0]}" 5

    # re-initialize arrays
    backing_files=()
    img_candidates=()
    env_candidates=()
    local best_pick=""

    # for each board included, identify the best backing file available, then
    # use cb-mount-binhost to activate a loop device and mount it
    for board in "${boards[@]}"; do
        # if there is already a loop device activated for this board's backing file, skip to the next
        # (should only apply when run manually, since this is a .start scrit run at boot time)
        d_message "${LBon}examining situation for board [${BMon}${board}${LBon}]${Boff}" 2
        if [[ ! -z $(losetup -a | grep "${board}") ]] ; then
            d_message "${BMon}loop device already active for board [${LBon}${board}${BMon}]${Boff}" 2
            continue; # continue jumps out to next iteration in for loop
        fi
        # identify the binhost appropriate for this board and determine if it is already in use with another board
        id_binhost_and_link_for_board ${board}
        d_message "${LBon}examining situation for board [${BMon}${board}${LBon}]'s binhost [${bh}]${Boff}" 2
        if [[ ! -z $(findmnt -lno TARGET,SOURCE,FSTYPE | grep "${bh}_binhost") ]] ; then
            d_message "${BMon}mountpoint(s) already in use for binhost [${LBon}${bh}${BMon}]${Boff}" 2
            continue; # continue jumps out to next iteration in for loop
        fi
        # identify candidate backing file(s)
        load_backing_files "${board}"
        d_message "${BYon}available backing files:${Boff}" 2
        d_message "${BYon}#: [${Mon}${#backing_files[@]}${BYon}] list: [${Mon}${backing_files[*]}${BYon}]${Boff}" 2
        # if there are more than one candidate, pick the "best" ; rules --
        # (1) prefer .img to .env (more complete) ; (2) prefer newest
        best_pick=""       # (re)initialize
        img_candidates=()
        env_candidates=()
        if [[ ${#backing_files[@]} -eq 0 ]] ; then
            die "no backing files available for board [$board]"
            logger -p cron.err "no backing files available for board [$board]"
        elif [[ ${#backing_files[@]} -eq 1 ]] ; then
            d_message "picking the only candidate" 2
            best_pick="${backing_files[0]}"
        elif [[ ${#backing_files[@]} -gt 1 ]] ; then
            # sort them by type since .img is preferred
            d_message "sorting candidates by type" 5
            for file in "${backing_files[@]}" ; do
                if [[ "$file" == *.img ]]; then
                    img_candidates+=("$file")
                elif [[ "$file" == *.env ]]; then
                    env_candidates+=("$file")
                else
                    # save to convert to elif if/when qcow2 images are incorporated
                    die "invalid backing file [$file]"
                fi
            done
            # apply rule (1) prefer .img file if available; in either case if more than 1, pick newest
            if [[ ${#img_candidates[@]} -gt 0 ]] ; then
                # note use "${img_candidates[*]}" which expands to single string
                # whereas "${img_candidates[@]}" expands to multiple strings
                d_message "${BYon}picking from [${Mon}${#img_candidates[@]}${BYon}] img_candidates: [${LBon}${img_candidates[*]}${BYon}]${Boff}" 2
                best_pick=$(find_newest_file "${img_candidates[@]}")
            elif [[ ${#env_candidates[@]} -gt 0 ]] ; then
                d_message "${BYon}picking from [${Mon}${#env_candidates[@]}${BYon}] env_candidates: [${LBon}${env_candidates[*]}${BYon}]${Boff}" 2
                best_pick=$(find_newest_file "${env_candidates[@]}")
            else  # nonsense case, should have been caught above
                die "nonsense case in elif comparisons #img_candidates: [${#img_candidates[@]}] #env_candidates: [${#env_candidates[@]}]"
            fi
        else  # nonsense case
            die "nonsense case in elif comparisons #backingfiles: [${#backing_files[@]}]"
        fi
        # now proceed with best_pick as the backing file
        # if it exists, mount backend on binhost mountpoint
        d_message "${BYon}chose best_pick: [${Mon}${best_pick}${BYon}]${Boff}" 1

        backing_file="${stockpile_dir%/}/${best_pick}"
        if [ -f ${backing_file} ] ; then
            d_message "${BMon}trying to mount backing file [${LBon}${backing_file}${BMon}] ...${Boff}" 1
            # new syntax: cb-mount-binhost <BACKINGFILE> # (which takes basename only; no path)
#            cb-mount-binhost "${backing_file}" "${binhost_mountpoint_dir%/}/${bh}_binhost" >/dev/null 2>&1
            if [ $verbosity -gt 0 ] ; then
                cb-mount-binhost "$(basename ${backing_file})"
                result=$?
            else
                cb-mount-binhost "$(basename ${backing_file})" >/dev/null 2>&1
                result=$?
            fi
        else
            d_message "${backing_file} doesn't exist" 1
            # didn't exist
            result=2
        fi
        case $result in
            0) PRIORITY="notice" && RESULT="succeeded" && message "${RESULT}" ;;
            1) PRIORITY="err" && RESULT="failed" && E_message "${RESULT}" ;;
            2) PRIORITY="err" && RESULT="failed (backing file doesn't exist)" && E_message "${RESULT}";;
            *) PRIORITY="err" && RESULT="failed (invalid result [$result])" && E_message "${RESULT}" ;;
        esac
    #    [ $result -eq 0 ] && ( RESULT="succeeded"; PRIORITY="notice" ) || \
     #       ( RESULT="failed"; PRIORITY="err" )
        logger -p cron.${PRIORITY} "cb-mount-binhost ${backing_file} on ${bh}_binhost ${RESULT}"
    done
}

#-----[ main script ]------------------------------------------------------------------------
# ** if you have no duplicates ** you can automate the assignment of boards array
# by setting AUTOMATIC=$TRUE above
[ $AUTOMATIC ] && load_boards

separator "$(hostname)" "${PN}"
d_message "in main script; verbosity: $verbosity" 5
d_message "AUTOMATIC: $(status_color ${AUTOMATIC})$(TrueFalse ${AUTOMATIC})${Boff}" 2
#d_message "boards: ${boards[@]}" 2
# "${array[@]}"	Expands to N separate, safely quoted arguments
# "${array[*]}"	Expands to a single, safely quoted argument
d_message "boards: ${boards[*]}" 2

setup_mountpoints_and_weblinks || die "failed to setup_mountpoints_and_weblinks"

pick_and_mount_best_backing_file || die "failed to pick_and_mount_best_backing_file"

d_message "done!" 2

#echo -e "${BMon}Debug Marker${Boff}"; exit

