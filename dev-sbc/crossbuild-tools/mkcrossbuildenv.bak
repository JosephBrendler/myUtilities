#!/bin/bash
#
# mkcrossbuildenv   joe brendler 17 April 2025
#
# interactive sequence to create a crossbuild environment (which qemu chroot)
#    for ${TARGET} system
#
source /usr/local/sbin/script_header_brendlefly
VERBOSE=$TRUE
verbosity=3


TARGET=""
TARGET_ARCH=""
STAGE3=""
old_dir=$(pwd)
answer=""
status=0
status_file="/root/bin/mkcrossbuildenv_status"

command_sequence=(
'cleanup-crossdev-environment'
'make-target-dir'
'wget-stage3'
'verify-stage3-hashes'
'untar-stage3'
'create-new-cross-compiler'
'select-profile'
'quickpgk-toolchain ${TARGET}'
'populate-target ${TARGET}'
'${TARGET}-emerge -uavDN @system --keep-going'
'buildtarget-qemu ${TARGET}'
'emerge -uavDN @world --keep-going'
'emerge-cross-rust-std'
'chroot-target ${TARGET}'
)

msg1_sequence=(
'clean up crossdev environment'
'make target directory'
'download stage3'
'verify stage3 hashes'
'extract stage3 from tar.xz archive'
'create new cross compiler'
'select profile'
'create crossbuild toolchain binary packages with quickpgk'
'populate configs in crossbuild target environment'
'${TARGET}-emerge @system set'
'build qemu binary for ${TARGET}'
'restore host with emerge -uavDN @world'
'emerge cross-${TARGET}/rust-std'
'chroot into new ${TARGET} environment'
)

msg2_sequence=(
'cleaning up crossdev environment'
'making target directory'
'downloading stage3'
'verifying stage3 hashes'
'extracting stage3 from tar.xz archive'
'creating new cross compiler'
'selecting profile'
'creating crossbuild toolchain binary packages with quickpgk'
'populating configs in crossbuild target environment'
'${TARGET}-emerging @system set'
'building qemu binary for ${TARGET}'
'restoring host with emerge -uavDN @world'
'emerging cross-${TARGET}/rust-std'
'chrooting into new ${TARGET} environment'
)

number_prompt ()
{
    ps=$1;
    echo;
    echo;
    CUU;
    SCP;
    message_n "$ps [0-999]: " && read answer;
    isnumber $answer
    result=$?
    while [ $result -ne 0 ] || [ $answer -lt 0 ] || [ $answer -gt 999 ]; do
        RCP;
        echo -en "$(repeat ' ' $(termwidth))";
        RCP;
        message_n "$ps [0-999]: " && read answer;
        isnumber $answer
        result=$?
    done
}

emerge-cross-rust-std() {
    # this doesn't work yet
#    emerge -av cross-${TARGET}/rust-std
    E_message "emerge -av cross-${TARGET}/rust-std doesn't work... skip for now"
}

select-profile() {
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
    number_prompt "Select profile: "
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile set ${answer}
    ARCH="${TARGET_ARCH}" PORTAGE_CONFIGROOT="/usr/${TARGET}/" eselect profile list
}

create-new-cross-compiler() {
    message "creating new crossdev cross compiler. Done after stage3"
    message "because crossdev defaults to split-usr layout, and I"
    message_n "prefer the merged-usr layout that modern stage3 provides ..."
    crossdev -S -t ${TARGET} ; right_status $?
}

untar-stage3() {
    message_n "extracting stage3 from tar.xz archive ..."
    tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner -C /usr/${TARGET}/
    right_status $?
}

verify-stage3-hashes() {
    selector='SHA512'
    SHA512_DIGEST="$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')"
    SHA512_HASH="$(openssl dgst -r -sha512 stage3-*.tar.xz)"

    selector='BLAKE2B'
    BLAKE2B_DIGEST="$(grep -A1 ${selector} $(basename ${href}).DIGESTS | \
                  grep -v "CONTENTS\|${selector}\|--" | awk '{print $1}')"
    BLAKE2B_HASH="$(openssl dgst -r -blake2b512 stage3-*.tar.xz)"
    d_message "SHA512_DIGEST..: ${SHA512_DIGEST}" 3
    d_message "SHA512_HASH....: ${SHA512_HASH}" 3
    d_message "BLAKE2B_DIGEST.: ${BLAKE2B_DIGEST}" 3
    d_message "BLAKE2B_HASH...: ${BLAKE2B_HASH}" 3

    if [[ "${SHA512_DIGEST}" != "${SHA512_HASH}" ]] ; then
        E_message "openssl sha512 hash has does not match digest"
        exit
    elif [[ "${BLAKE2B_DIGEST}" != "${BLAKE2B_HASH}" ]] ; then
        E_message "openssl blake2b512 hash has does not match digest"
    else
        message "openssl sha512 and blake2b512 hashes both match digest" 
    fi
    # to do: verify hashes automatically
#    E_message "automatic hash verification would occur here. not implemented yet ..."
#    message "compare output of commands above to verify manually"
}

wget-stage3() {

    eval "$(grep ${STAGE3} \
          <<< $(curl -s https://www.gentoo.org/downloads/#arm) \
          | awk '{print $2}')"
    wget ${href}
    wget ${href}.DIGESTS
}

make-target-dir() {
    message_n "creating /usr/${TARGET} directory ..."
    mkdir /usr/${TARGET} ; right_status $?
    cd /usr/${TARGET}
    message "now working in $(pwd)"
}

cleanup-crossdev-environment() {
    message_n "cleaning up old crossdev environment ..."
    crossdev -C -t ${TARGET} ; right_status $?
}

usage() {
    message "${BRon}usage: ${BGon}mkcrossbuildenv <TARGET>${Boff}"
    message "${BYon}  Note: exactly one argument <TARGET> is required. Examples:${Boff}"
    message "    aarch64-unknown-linux-gnu"
    message "    armv6j-unknown-linux-gnueabihf"
    message "    armv7a-unknown-linux-gnueabihf"
    exit
}

validate_target() {
    case $TARGET in
        "aarch64-unknown-linux-gnu" )
            d_message "valid target: [${TARGET}]" 2 ;
            TARGET_ARCH="arm64" ;
            STAGE3="stage3-arm64-openrc-[0-9]" ;
            ;;
        "armv6j-unknown-linux-gnueabihf" )
            d_message "valid target: [${TARGET}]" 2 ;
            TARGET_ARCH="arm" ;
            STAGE3="stage3-armv6j_hardfp-openrc-[0-9]" ;
            ;;
        "armv7a-unknown-linux-gnueabihf" )
            d_message "valid target: [${TARGET}]" 2 ;
            TARGET_ARCH="arm" ;
            STAGE3="stage3-armv7a_hardfp-openrc-[0-9]" ;
            ;;
        * )
            E_message "invalid target: [${TARGET}]" ;
            usage ;;
    esac
}

run_sequence() {

    while [[ ${status} -lt ${#command_sequence[@]} ]]
    do
      [[ ! $answer == [gG] ]] && answer="" && \
        separator "${msg1_sequence[${status}]}" "$(basename $0) now starting"
        get_answer "Are you ready to execute step ${status} -- ${BYon}${msg1_sequence[${status}]}${Boff}?"
      if [[ $answer == [YyGg] ]]
      then
        message "${LBon}Now executing step ${status} -- ${BYon}${msg2_sequence[${status}]}${LBon}...${Boff}"
        eval ${command_sequence[${status}]}; result="$?"; right_status "${result}"
        if [[ ${result} ]]
        then
          message "Step ${status} -- ${BYon}${msg1_sequence[${status}]}${Boff} -- complete"
        else
          E_message "Step ${status} -- ${BYon}${msg1_sequence[${status}]}${Boff} -- ${BRon}failed${Boff}"
          E_message "Quitting..."
        fi
      else
        E_message "User chose ${BRon}NOT${Boff} to execute step ${status} -- ${BYon}${msg1_sequence[${status}]}${Boff}."
        E_message "Quitting..."
        exit
      fi
      # increment number of next step and store in status_file
      let status++;
      message "Saving [${status}] to ${status_file}"
      echo $status > ${status_file}
    done

    echo
    message "$(basename $0) complete."
}

#-----[ main script ]---------------------------------------------
checkroot
separator $(basename $0) $(hostname)
[ $# -ne 1 ] && usage
TARGET=$1
validate_target

message_n "validating status_file [${status_file}] ..."
[ ! -d $(dirname ${status_file}) ] && mkdir -pv $(dirname ${status_file})
right_status $?

old_dir="$(pwd)"
cd /usr/${TARGET}
message "now working in target sysroot directory: [${Mon}$(pwd)${Boff}]"

# for each command in command_sequence array (like rus/jus/kernelupdate)
run_sequence

echo
cd $old_dir
message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
