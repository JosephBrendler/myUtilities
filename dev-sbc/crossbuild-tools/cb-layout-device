#!/bin/bash
#
# cb-layout-device   (c) joe.brendler  2025-2072
# copy appropriate template files into crossbuild target filesystem
#

source /usr/sbin/script_header_joetoo
message_n "sourcing BUILD ..."
source /etc/crossbuild-tools/BUILD ; right_status $?
message_n "sourcing BPN ..."
source /etc/crossbuild-tools/BPN ; right_status $?
source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
#verbosity=2
verbosity=3

#-----[ variables ]-------------------------------------------------------------------------

PN=$(basename $0)

varlist="BOARD OUTPUTDEVICE"
varlist+=" MiB"
varlist+=" configfile DEV_HOSTNAME bool.LUKS"
varlist+=" crypt_keydev crypt_keydev_type crypt_keydev_mountpoint keyfile"
varlist+=" root_vg root_dev_mountpoint mounttherestscript chrootprepscript chrootcommandsfile"
varlist+=" BREAK bool.VERBOSE verbosity bool.FLAGGED bool.ERROR"

hidden_varlist="crypt_passphrase"

#-----[ functions ]-------------------------------------------------------------------------

initialize_variables() {

    message_n "sourcing cb-common-functions ..."
    source /usr/sbin/cb-common-functions ; right_status $?

    initialize_vars ${varlist}
    initialize_vars ${hidden_varlist}

    message_n "sourcing BUILD ..."
    source /etc/crossbuild-tools/BUILD ; right_status $?

    message_n "sourcing BPN ..."
    source /etc/crossbuild-tools/BPN ; right_status $?

    message_n "re-initializing VERBOSE = TRUE ..."
    VERBOSE=$TRUE ; right_status $?
    message_n "re-initializing verbosity = 3 ..."
    verbosity=3 ;  right_status $?

    # "source" the template files to read some global variables
    #     medium (mmc, usb, nvme)
    #     encryption (plain, luks)
    #     disk label (dos/gpt)
    #     unit (sectors)
    #     sector-size (512)
    #     partition-count
    #     for each partition (label, type, mountpoint, luks?)
    #     LUKS (bool)
    #         PVname, VGname, LVnames()
    #         for each LV (name, size, mountpoint)

    # maybe optional config file for -
    #     DEV_HOSTNAME (can get from .img file)
    #     crypt_keydev
    #     crypt_passphrase
    # all the other data from old config file is in sfdisk, blkid, and lsblk template files
    message_n "initializing configfile = /etc/crossbuild-tools/cb-layout-device.conf"
    configfile=/etc/crossbuild-tools/cb-layout-device.conf  ; right_status $?

    message_n "sourcing cb-layout-device.conf ..."
    if [ -e ${configfile} ] ; then
        source ${configfile} ; result=$?
        if [ $result -eq 0 ] ; then
            right_status $TRUE
        else
            right_status 1
            die "failed to source ${configfile}"
        fi
    else
        right_status 1
        die "${configfile} does not exist"
    fi

    message_n "initializing crypt_keydev_mountpoint = /mnt/key ..."
    crypt_keydev_mountpoint=/mnt/key ; right_status $?

    message_n "initializing root_dev_mountpoint = /mnt/gentoo ..."
    root_dev_mountpoint="/mnt/gentoo" ; right_status $?

    message_n "initializing mounttherestscript = ${root_dev_mountpoint%/}/mount-the-rest.${DEV_HOSTNAME} ..."
    mounttherestscript="${root_dev_mountpoint%/}/mount-the-rest.${DEV_HOSTNAME}" ; right_status $?

    message_n "initializing chrootprepscript = ${root_dev_mountpoint%/}/chroot-prep ..."
    chrootprepscript="${root_dev_mountpoint%/}/chroot-prep" ; right_status $?

    message_n "initializing chrootcommandsfile = ${root_dev_mountpoint%/}/chroot-commands ..."
    chrootcommandsfile="${root_dev_mountpoint%/}/chroot-commands" ; right_status $?

    message_n "initializing default LUKS = FALSE ..."
    LUKS=$FALSE ; right_status $?

    message_n "initializing default OUTPUTDEVICE NULL ..."
    OUTPUTDEVICE="" ; right_status $?

    return 0
}

usage() {
    E_message "${BRon}usage: ${BGon}${PN} <BOARD> <OUTPUTDEVICE>${Boff}"
    echo
    message "${BYon}BOARD: must be one of --${Boff}"
    joetoo-sbc-list | sed 's|^|    |'
    echo
    message "${BYon}OUTPUTDEVICE: must be a valid device${Boff}"
    E_message "${BRon}*** Warning ***${BYon} this process will destroy all data on OUTPUTDEVICE${Boff}"
    message "Note: these candidate devices are present in your system but not mounted"
    echo
    list_unused_disks
    echo
    exit 1
}

# non-stty-separator() ...... moved to /usr/sbin/script_header_joetoo_extended
# non-stty-right_status () ..  moved to /usr/sbin/script_header_joetoo_extended

list_unused_disks() {
    # set this now because doing so will be an inappropriate use of io control for stdin during while loop's redirection for "read line"
    TERMWIDTH=$(termwidth)
    # read every line of lsblk (NAME, TYPE, MOUNTPOINT columns)
    while read line ; do
        # use eval to interpret the -P pairs as variable assignments
        eval ${line}
        if [[ "${TYPE}" == "disk" ]] ; then
            # look for disks with no children (TYPE crypt, part, lvm) mounted
            candidate_name=$NAME ; candidate_type=$TYPE
            INUSE=$FALSE
            message_n "checking ${candidate_type} ${candidate_name} ..."
            while read innerline; do
                eval ${innerline}
                if [[ ! -z ${MOUNTPOINTS} ]] || [[ ! -z "$(findmnt | grep ${NAME})" ]] ; then
                    INUSE=$TRUE
                fi
            done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS /dev/${candidate_name})
            if [[ ! $INUSE ]] ; then
                echo -en "${BGon}(not in use) ${BMon}/dev/${candidate_name}${Boff}"
                non-stty-right_status $TRUE
                lsblk /dev/${candidate_name} | sed 's|^|    |'
            else
                echo -en "${BRon}(in use)${Boff}"
                non-stty-right_status 1
            fi
        fi
    done <<<$(lsblk -P -o NAME,TYPE,MOUNTPOINTS)
    return 0
}

set-crypt_passphrase() {
#  set crypt_passphrase
    response=""
    message "${BYon}Please provide the crypt_passphrase for this system${Boff}"
    message "${BMon}This will be used in formatting luks-encrypted partition(s)${Boff}"
    echo
    echo -en " ${BGon}*${Boff} Enter crypt_passphrase: "
    read -s candidate1 ; echo
    echo -en " ${BGon}*${Boff} re-enter to confirm crypt_passphrase: "
    read -s candidate2 ; echo
    if [[ "${candidate1}" == "${candidate2}" ]] ; then
        message_n "setting crypt_passphrase ..."
        export crypt_passphrase="${candidate1}" ; result=$? && \
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && return 1 )
    else
        die "candidate crypt_passphrases did not match"
    fi
    return 0
}

set-DEV_HOSTNAME() {
#  set DEV_HOSTNAME
    response=""
    message "${BYon}Please provide the hostname for this system${Boff}"
    message "${BMon}This will be used in naming volume groups used in cryptsetup layout${Boff}"
    echo
    while [[ ! "${response}" == [yYsS] ]] ; do
        echo -en "${BGon}*${Boff} set hostname for this system: "
        read candidate
        message "you responded [ ${candidate} ]"
        new_prompt "is this correct?"
    done
    if [[ "${response}" == [yY] ]] ; then
        message_n "setting DEV_HOSTNAME: ${candidate}"
        export DEV_HOSTNAME="${candidate}" ; result=$? && \
        ( echo -en " ${BGon}(success)${Boff}" && right_status $result  && return 0 ) || \
        ( echo -en " ${BRon}(fail)${Boff}" && right_status $result && return 1 )
    else
        die "candidate hostname provided, then rejected"
    fi
    return 0
}

finalize_config() {
    separator "(finalize_config)" ${PN}
    # this function only runs for LUKS, so sanity check that
    if [ ${#partition_list[@]} -eq 1 ] ; then
        E_message "luks format is requested, but there is only 1 partition defined"
        die "invalid partition configuration for luks"
    else
        d_message "luks format requested; and more than 1 partition: ok" 3
    fi
    # check/get DEV_HOSTNAME
    if [ -z $DEV_HOSTNAME ] ; then
        msg="DEV_HOSTNAME is unset; please provide one"
        set-DEV_HOSTNAME
        d_message "DEV_HOSTNAME: $DEV_HOSTNAME" 3
    else
        d_message "DEV_HOSTNAME already assigned" 3
    fi
    # now that it has been checked, use DEV_HOSTNAME to set root_vg
    export root_vg="vg_${DEV_HOSTNAME}"

    # check/get luks passphrase
    if [ -z $crypt_passphrase ] ; then
        msg="crypt_passphrase is unset; please provide one"
        set-crypt_passphrase
###        d_message "crypt_passphrase: $crypt_passphrase"
    else
        d_message "crypt_passphrase already set" 3
    fi
}

layout_partitions() {
    separator "(layout_partitions)" ${PN}
    d_message "in ${FUNCNAME[0]}" 3
    # calculate disk size in MiB
    #  (to-do: use this for relative layout sizing on device or arbitrary size)
    disksize_bytes=$(fdisk -l ${OUTPUTDEVICE} | head -n1 | awk '{print $5}')
    d_message "disksize_bytes: $disksize_bytes" 3
    disksize_mb=$(( $disksize_bytes / $((1024 * 1024)) ))
    d_message "disksize_mb: $disksize_mb" 3

    # use sfdisk script to lay out partitions

    return 0
}

format_partitions() {
    separator "(format_partitions)" ${PN}
    d_message "in ${FUNCNAME[0]}" 3

    # use blkid template to format partitions

    return 0

}

layout_cryptsetup() {
    ERROR=$FALSE
    separator "(layout_cryptsetup)" ${PN}
    d_message "in ${FUNCNAME[0]}" 3

    # use lsblk template to identify luks partition (last "part") and container "crypt" names

    # dd random data to the luks "part" name

    # cryotsetup luksFormat the "part"; luksAddKey; luksOpen with key as "crypt" container name

    # pvcreate the "crypt" container name as a lvm physical volume (PV)

    # vgcreate with standard name "vg_${hostname}" a lvm volume group (VG) on the "crypt" container

    # use lsblk "lvm" lines to identify and lvcreate (size and name) all lvm logical volumes (LVs)
    # (these are named root, usr, var, opt, tmp, home, srv, swap, etc)

    # use blkid to format all of the LVs

}

#-----[ main script ]---------------------------------------------
checkroot
separator "$(hostname)" "${PN}"
initialize_variables || die "failed to initialize variables"
[ $# -ne 2 ] && usage
BOARD=$1
OUTPUTDEVICE=$2

# validate BOARD, assign TARGET, ARCH. etc.
validate_target ${BOARD} || die "failed to validate_target ${BOARD}"

# validate OUTPUTDEVICE
validate_device ${OUTPUTDEVICE} || die "failed to validate device [ ${OUTPUTDEVICE} ]"

# todo - select template from those available for BOARD (e.g. mmc.plain or nvme.luks)
select_template || die "failed to select_template"

# don't use configs - just select template (e.g. mmc.plain or nvme.luks)
# todo: validate all three template parts (sfdisk, blkid, lsblk)
# number of partitions; partition type vs format; device size; partition sizes
validate_templates || die "failed to validate config"

if [ $LUKS ] ; then
    # todo: break this into logical parts as separate functions
    # validate luks container (appropriate partition, size)
    # set device hostname (for vg naming)
    # set luks pashphrase
    finalize_config || die "failed to finalize config"
fi

display_configuration || die "failed to display_configuration"

format_warning || die "failed format warning somehow, oddly"

layout_partitions || die "failed to layout partitions"

format_partitions || die "failed to format partitions"

[ $LUKS ] && layout_cryptsetup || message "no luks layout requested; skipping"

message "layout complete"
message "${BYon}Hint:  use ${BGon}cb-flash-device <BOARD> <OUTPUTDEVICE>${Boff}"
message "        to populate the new device with data from a"
message "        mounted crossbuild target image file"

exit 0
