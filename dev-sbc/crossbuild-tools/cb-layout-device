#!/bin/bash
#
# cb-layout-device   (c) joe.brendler  2025-2072
# prepare a block device to be used as system storage (root/boot_fs) for a crossbuild target filesystem
#

# Note: 14 September 2025 - trying to convert this program to run as a "run_sequence" with "process_cmdline"
#   which will require it to have its own reference to "/etc/${BPN}" - where functions in script_header_joetoo_extended
#   will look to get local.usage, local.cmdline_arguments, local.cmdline_compound_arguments
#   This program will define BPN=$(basename ${config_dir})/${PN} where PN=$(basename $0) [crossbuild-tools/cb-layout-device]
#   rather than load the BPN file created by the parent package which uses BPN= its own PN

source /usr/sbin/script_header_joetoo
source /usr/sbin/script_header_joetoo_unicode
export LC_NUMERIC="en_US.UTF-8"
declare -A lv_size  # user later, for size of LVs (root, usr, var, opt, home, tmp, srv, extra, swap)

PN=$(basename $0)

config_dir="/etc/crossbuild-tools"
message_n "sourcing BUILD ..."
source ${config_dir%/}/BUILD ; right_status $?
#message_n "sourcing BPN ..."
#source ${config_dir%/}/BPN ; right_status $?
message_n "assigning BPN = $(basename ${config_dir})/${PN}.local"
BPN=$(basename ${config_dir})/${PN}.local || die "failed to assign BPN" ; right_status $TRUE
source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

#-----[ variables ]-------------------------------------------------------------------------

varlist="DEVICE_DATA OUTPUTDEVICE BOARD MEDIUM ENCRYPTION bool.LUKS"
varlist+=" disksize_bytes ez_disksize_bytes disksize_MiB ez_disksize_MiB MiB GiB"
varlist+=" swap_size DEV_HOSTNAME"
varlist+=" BREAK CONFIG_DATA config_dir configfile layoutstatusfile"
varlist+=" BREAK TEMPLATE_DATA sfdisk_template_dir blkid_template_dir lsblk_template_dir"
varlist+=" sfdisk_template blkid_template lsblk_template"
varlist+=" sfdisk_head_label sfdisk_head_unit sfdisk_head_first_lba sfdisk_head_sector_size"
varlist+=" p_prefix partition_count"
varlist+=" BREAK CRYPT_DATA crypt_keydev crypt_keydev_type crypt_keydev_mountpoint keyfile"
varlist+=" luks_partition_device edev"
varlist+=" BREAK ROOT_DATA root_vg root_dev_mountpoint mount_the_rest_script"
varlist+=" draft_fstab_generator_script"
varlist+=" BREAK PROGRAM_DATA boot.INTERACTIVE bool.VERBOSE verbosity bool.FLAGGED bool.ERROR"

hidden_varlist="crypt_passphrase"

command_sequence=(
'source_templates'
'display_template_varlist'
'set-DEV_HOSTNAME'
'maybe_luks_lvm_config'
'display_configuration_and_local_sanity_check'
'layout_partitions'
'format_partitions'
'maybe_layout_cryptsetup_lvm'
'mount_and_populate'
)

msg1_sequence=(
'source templates'
'display template data (varlist)'
'set hostname'
'maybe run luks_lvm_config'
'display configuration and sanity-check'
'lay out partitions'
'format partitions'
'maybe lay out cryptsetup and lvm'
'mount and populate new device'
)

msg2_sequence=(
'sourcing templates'
'displaying template data (varlist)'
'setting hostname'
'maybe running luks_lvm_config'
'displaying configuration and sanity-checking'
'laying out partitions'
'formatting partitions'
'maybe laying out cryptsetup and lvm'
'mounting and populating new device'
)

#-----[ functions ]-------------------------------------------------------------------------

# non-stty-separator() ...... moved to /usr/sbin/script_header_joetoo_extended
# non-stty-right_status () .. moved to /usr/sbin/script_header_joetoo_extended
# list_unused_disks(() ...... moved to /usr/sbin/script_header_joetoo_extended

# usage() ... moved to script_header_joetoo_extended, suplemented by /etc/${BPN}/local.usage

initialize_variables() {

    d_message_n "sourcing cb-common-functions ..." 2
    source /usr/sbin/cb-common-functions ; d_right_status $? 2

    # save variables we have in varlist but dont want to lose
    oldVERBOSE=$VERBOSE; oldverbosity=$verbosity

    initialize_vars ${varlist}
    initialize_vars ${hidden_varlist}

    d_message_n "re-assigning config_dir = /etc/crossbuild-tools" 2
    config_dir="/etc/crossbuild-tools" ; d_right_status $? 2

    d_message_n "sourcing BUILD ..." 2
    source ${config_dir%/}/BUILD ; d_right_status $? 2

#    message_n "sourcing BPN ..."
#    source ${config_dir%/}/BPN ; right_status $?
    d_message_n "re-assigning BPN = $(basename ${config_dir})/${PN}.local" 2
    BPN=$(basename ${config_dir})/${PN}.local || die "failed to assign BPN" ; d_right_status $TRUE 2
    d_message_n "sourcing /usr/sbin/script_header_joetoo_extended" 2
    source /usr/sbin/script_header_joetoo_extended ; d_right_status $? 2

    d_message_n "initializing INTERACTIVE = TRUE ..." 2
    INTERACTIVE=$TRUE ; d_right_status $? 2
    d_message_n "re-initializing VERBOSE = $(TrueFalse $oldVERBOSE)" ..." 2
    VERBOSE=$oldVERBOSE ; d_right_status $? 2
    d_message_n "re-initializing verbosity = $oldverbosity ..." 2
    verbosity=$oldverbosity ;  d_right_status $? 2
    d_message_n "setting default starting_step = 0" 2
    starting_step=0 ; d_right_status $? 2
    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    stopping_step=$(( ${#command_sequence[@]} - 1 )) ; d_right_status $? 2
    d_message_n "setting default layoutstatusfile = /root/bin/layout_status" 2
    layoutstatusfile="/root/bin/layout_status" ; d_right_status $? 2
    d_message_n "initializing default LUKS = FALSE ..." 2
    LUKS=$FALSE ; d_right_status $? 2
    d_message_n "initializing partition_count = 0 ..." 2
    partition_count=0 ; d_right_status $? 2

# these now done by process_cmdline
#    d_message_n "assigning BOARD from command line ..." 2
#    BOARD="${myBOARD}" ; d_right_status $? 2
#    d_message_n "assigning OUTPUTDEVICE from command line ..." 2
#    OUTPUTDEVICE="${myOUTPUTDEVICE}" ; d_right_status $? 2

    # source config file - sets MEDIUM and LUKS, as well as INTERACTIVE, VERBOSE, verbosity
    # and it optionally sets DEV_HOSTNAME, crypt_keydev, crypt_passphrase
    # all the other data from old config file is in sfdisk, blkid, and lsblk template files
    d_message_n "assigning configfile = cb-layout-device.conf" 2
    configfile="cb-layout-device.conf"  ; d_right_status $? 2
    d_message_n "sourcing config file cb-layout-device.conf ..." 2
    if [ -e ${config_dir%/}/${configfile} ] ; then
        source ${config_dir%/}/${configfile} ; result=$?
        if [ $result -eq 0 ] ; then
            d_right_status $TRUE 2
        else
            d_right_status 1 2
            die "failed to source ${configfile}"
        fi
    else
        d_right_status 1 2
        die "${configfile} does not exist"
    fi
    if [[ $LUKS ]] ; then
        d_message_n "assigning ENCRYPTION = luks , per config file ..." 2
        ENCRYPTION="luks" ; d_right_status $? 2
    else
        d_message_n "assigning ENCRYPTION = plain , per config file ..." 2
        ENCRYPTION="plain" ; d_right_status $? 2
    fi

    # initialize luks keying device mountpoint
    d_message_n "assigning crypt_keydev_mountpoint = /mnt/key ..." 2
    crypt_keydev_mountpoint=/mnt/key ; d_right_status $? 2

    # initialize root_dev_mountpoint and related variables
    d_message_n "assigning root_dev_mountpoint = /mnt/gentoo ..." 2
    root_dev_mountpoint="/mnt/gentoo" ; d_right_status $? 2
    # moved initialization of mount_the_rest_script to set-DEV_HOSTNAME
    d_message_n "assigning chroot_prep_script = chroot-prep ..." 2
    chroot_prep_script="chroot-prep" ; d_right_status $? 2
    d_message_n "assigning chroot_command_textsfile = chroot-commands ..." 2
    chroot_command_textsfile="chroot-commands" ; d_right_status $? 2
    d_message_n "assigning draft_fstab_generator_script = draft_fstab_generator_script ..." 2
    draft_fstab_generator_script="draft_fstab_generator_script" ; d_right_status $? 2

    # initialize display_configuration section headings
    d_message_n "assigning DEVICE_DATA section heading" 2
    DEVICE_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning CONFIG_DATA section heading" 2
    CONFIG_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning TEMPLATE_DATA section heading" 2
    TEMPLATE_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning CRYPT_DATA section heading" 2
    CRYPT_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning ROOT_DATA section heading" 2
    ROOT_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning PROGRAM_DATA section heading" 2
    PROGRAM_DATA="see below" ; d_right_status $? 2
    d_message_n "assigning MiB = 1024 * 1024" 2
    MiB=$((1024*1024)) ; d_right_status $? 2
    d_message_n "assigning GiB = 1024 * MiB" 2
    GiB=$((1024*${MiB})) ; d_right_status $? 2

    # initialize lv_size associative array
    for x in root usr var opt home tmp srv swap extra; do
        d_message_n "initializing lv_size[${x}] = 0" 2
        lv_size["${x}"]="0" || die "failed to initialize lv_size[${x}] = 0"
        debug_do 'echo -e -n " (${lv_size[${x}]})"' 2 ; d_right_status $? 2
    done

    return 0
}

assign_BOARD_and_OUTPUTDEVICE_derived_variables() {
    # initialize sfdisk_ blkid_ and lsblk_template with BOARD and info from config file (medium, LUKS)
    d_message_n "assigning sfdisk_template_dir = cb-layout-device-sfdisk-templates ..." 2
    sfdisk_template_dir="cb-layout-device-sfdisk-templates" ; d_right_status $? 2
    d_message_n "assigning blkid_template_dir = cb-layout-device-blkid-templates ..." 2
    blkid_template_dir="cb-layout-device-blkid-templates" ; d_right_status $? 2
    d_message_n "assigning lsblk_template_dir = cb-layout-device-lsblk-templates ..." 2
    lsblk_template_dir="cb-layout-device-lsblk-templates" ; d_right_status $? 2
    d_message_n "assigning sfdisk_template = sfdisk.${BOARD}.${MEDIUM}.${ENCRYPTION}.template ..." 2
    sfdisk_template="sfdisk.${BOARD}.${MEDIUM}.${ENCRYPTION}.template" ; d_right_status $? 2
    d_message_n "assigning blkid_template = blkid.${BOARD}.${MEDIUM}.${ENCRYPTION}.template ..." 2
    blkid_template="blkid.${BOARD}.${MEDIUM}.${ENCRYPTION}.template" ; d_right_status $? 2
    d_message_n "assigning lsblk_template = lsblk.${BOARD}.${MEDIUM}.${ENCRYPTION}.template ..." 2
    lsblk_template="lsblk.${BOARD}.${MEDIUM}.${ENCRYPTION}.template" ; d_right_status $? 2

    # read blktype as first 2 chars of text to the right of right-most / (e.g. sd in /dev/sdc)
    d_message_n "assigning partition number prefix" 2
    blkname=${OUTPUTDEVICE##*/}; blktype=${blkname:0:2}
    case ${blktype} in
        "sd" ) p_prefix="";; # e.g. /dev/sdc
        "mm" ) p_prefix="p" ;; # e.g. /dev/mmcblk0
        "nv" ) p_prefix="p" ;; # e.g. /dev/nvme0n1
    esac ; result=$?
    echo -n " p_prefix = $p_prefix ..."
    d_right_status $result 2

    # calculate disk size in MiB; LC_NUMERIC is set to en_US.UTF-8 at the top
    d_message_n "calculating disksize_bytes" 2
    disksize_bytes=$(fdisk -l ${OUTPUTDEVICE} | head -n1 | awk '{print $5}') || \
        die "failed to calculate disksize_bytes"
    debug_do 'echo -e -n " ($disksize_bytes)"' 2 ; d_right_status $? 2
    d_message_n "calculating disksize_MiB" 2
    disksize_MiB=$(( $disksize_bytes / $((1024 * 1024)) )) || \
        die "failed to calculate disksize_MiB"
    debug_do 'echo -e -n " ($disksize_MiB)"' 2 ; d_right_status $? 2
    d_message_n "calculating disksize_GiB" 2
    disksize_GiB=$(( $disksize_bytes / $((1024 * ${MiB})) )) || \
        die "failed to calculate disksize_GiB"
    debug_do 'echo -e -n " ($disksize_GiB)"' 2 ; d_right_status $? 2
    d_message_n "calculating ez_disksize_bytes" 2
    ez_disksize_bytes="$(printf "%'d\n" $disksize_bytes) bytes" || \
        die "failed to calculate ez_disksize_bytes"
    debug_do 'echo -e -n " ($ez_disksize_bytes)"' 2 ; d_right_status $? 2
    d_message_n "calculating ez_disksize_MiB" 2
    ez_disksize_MiB="$(printf "%'d\n" $disksize_MiB) MiB" || \
        die "failed to calculate ez_disksize_MiB"
    debug_do 'echo -e -n " ($ez_disksize_MiB)"' 2 ; d_right_status $? 2
    d_message_n "calculating ez_disksize_GiB" 2
    ez_disksize_GiB="$(printf "%'d\n" $disksize_GiB) MiB" || \
        die "failed to calculate ez_disksize_GiB"
    debug_do 'echo -e -n " ($ez_disksize_GiB)"' 2 ; d_right_status $? 2

    # calculate SWAP size appropriate for BOARD
    d_message_n "calculating appropriate swap_size" 2
    calculate_appropriate_swap || die "failed to calculate swap_size"
    swap_size="${lv_size[swap]}"
    debug_do 'echo -e -n " ($swap_size)"' 2 ; d_right_status $? 2

    return 0
}

source_templates() {
    # "source" the template files to read some global variables not set in configs
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 5

    template_varlist="" # each ingest adds to this

    d_message "config_dir: $config_dir" 5
    d_message "sfdisk_template_dir: $sfdisk_template_dir" 5
    d_message "sfdisk_template: $sfdisk_template" 5
    # (1) ingest sfdisk_template
    message_n "checking sfdisk_template ..."
    if [ -f "${config_dir%/}/${sfdisk_template_dir%/}/${sfdisk_template}" ] ; then
        right_status $TRUE
    else
        die "sfdisk_template does not exist"
    fi
    ingest_sfdisk_template || die "failed to ingest_sfdisk_template"

    # (2) ingest blkid_template
    message_n "checking blkid_template ..."
    if [ -f "${config_dir%/}/${blkid_template_dir%/}/${blkid_template}" ] ; then
        right_status $TRUE
    else
        die "blkid_template does not exist"
    fi
    ingest_blkid_template || die "failed to ingest_blkid_template"

    # (3) ingest lsblk_template
    message_n "checking lsblk_template ..."
    if [ -f "${config_dir%/}/${lsblk_template_dir%/}/${lsblk_template}" ] ; then
        right_status $TRUE
    else
        die "lsblk_template does not exist"
    fi
    ingest_lsblk_template || die "failed to ingest_lsblk_template"

    # (4) set luks_partition_device (so it can be used and displayed in config)
    # luks_partition_device= (last on OUTPUTDEVICE)
    # example /dev/sdc4 or /dev/mmcblk1p4 or /dev/nvme0n1p4
    # can't do this in initialization b/c we need partition_count first (derived above from sfdisk template)
    message_n "assigning luks_partition_device = ${OUTPUTDEVICE}${p_prefix}${partition_count}"
    luks_partition_device="${OUTPUTDEVICE}${p_prefix}${partition_count}" || \
        die "failed to set luks_partition_device"
    right_status $TRUE

    # (5) set luks container name - get_luks_edev_name operates on luks_partition_device and sets edev
    message_n "assigning luks container name (edev ="
    get_luks_edev_name || die "failed to get_luks_edev_name"
    echo -n " ${edev})" ; right_status $TRUE

    return 0
}

display_configuration_and_local_sanity_check() {
    display_configuration || return 1
    local_sanity_check || return 1
    maybe_format_warning || return 1
    return 0
}

display_template_varlist() {
    # display variables added by templates
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "template_varlist: ${template_varlist}" 5
    longest=0
    longest=$(get_longest ${template_varlist}) ; d_message "longest: $longest" 5
    template_varlist=$(for x in ${template_varlist}; do echo $x; done | sort)
    display_vars $longest ${template_varlist}
    return 0
}

ingest_sfdisk_template() {
    # read sfdisk template line by line using info left of delimiter ':' to identify each line
    # ignore comments with grep -v '^#'; ignore blank lines with grep ':'
    # assign values, count partitions ; extra echo to trim whitespace
    # assume only one line for each header setting (label, unit, first-lba, sector-size, device, etc)
    message_n "ingesting sfdisk_template"
    d_echo "" 5
    while read LINE ; do
        d_message "${LBon}reading LINE:${Boff} $LINE" 5
        var=$(echo $(echo $LINE | cut -d':' -f1)) ; d_message "var: $var" 5
        val=$(echo $(echo $LINE | cut -d':' -f2)) ; d_message "val: $val" 5
        case ${var} in
            "label"        ) sfdisk_head_label="${val}" ; template_varlist+=" sfdisk_head_label" ;;
            "unit"         ) sfdisk_head_unit="${val}" template_varlist+=" sfdisk_head_unit" ;;
            "first-lba"    ) sfdisk_head_first_lba="${val}" template_varlist+=" sfdisk_head_first_lba" ;;
            "sector-size"  ) sfdisk_head_sector_size="${val}" template_varlist+=" sfdisk_head_sector_size" ;;
            "device"       ) d_message "ignoring device line" 5 ;;
            "/dev/"*       )
                let partition_count+=1
                p_num=$(right_most ${var}) ; d_message "p_num: $p_num" 5
                part_vals=()  # (re)initialize
                IFS=',' read -r -a part_vals <<<"${val}" ; unset IFS # just want TYPE, for help formatting
                d_message "part_vals count: ${#part_vals[@]}" 5
                [ $verbosity -ge 5 ] && echo -e  "${BGon} * ${Boff}part_vals: ${part_vals[@]}"
                for ((i=0; i<${#part_vals[@]}; i++)); do
                    partvar=$(echo $(echo ${part_vals[$i]} | cut -d'=' -f1)) ; d_message "partvar: $partvar" 5
                    partval=$(echo $(echo ${part_vals[$i]} | cut -d'=' -f2)) ; d_message "partval: $partval" 5
                    eval "sfdisk_p${p_num}_${partvar}=${partval}" ; d_message "assigned sfdisk_p${p_num}_${partvar}=${partval}" 5
                    template_varlist+=" sfdisk_p${p_num}_${partvar}"
                done
                ;;

            *              ) die "invalid var [${var}] in sfdisk_template input LINE" ;;
        esac
    done <<< "$( grep ':' ${config_dir%/}/${sfdisk_template_dir%/}/${sfdisk_template} | grep -v '^#')"
    right_status $?
    return 0
}

ingest_blkid_template() {
    # read blkid template line by line using info left of delimiter ':' to identify each line
    # ignore comments with grep -v '^#'; ignore blank lines with grep ':'
    # verify partition_count; assign values for each partition pn_LABEL, pn_TYPE
    message_n "ingesting blkid_template"
    d_echo "" 5
    p_count=0  # verify against partition_count
    while read LINE ; do
        let p_count+=1 ; d_message "p_count: $p_count" 5
        d_message "${LBon}reading LINE:${Boff} $LINE" 5
        var=$(echo $(echo $LINE | cut -d':' -f1)) ; d_message "var: $var" 5
        val=$(echo $(echo $LINE | cut -d':' -f2)) ; d_message "val: $val" 5
        p_num=$(right_most ${var}) ; d_message "p_num: $p_num" 5
        LABEL=""; TYPE="" # (re)initialize
        eval "${val}"  # assign LABEL, TYPE, etc
        eval "blkid_p${p_num}_LABEL=${LABEL}" ; d_message "assigned blkid_p${p_num}_LABEL=${LABEL}" 5
        eval "blkid_p${p_num}_TYPE=${TYPE}" ; d_message "assigned blkid_p${p_num}_TYPE=${TYPE}" 5
        template_varlist+=" blkid_p${p_num}_LABEL blkid_p${p_num}_TYPE"
    done <<< "$( grep ':' ${config_dir%/}/${blkid_template_dir%/}/${blkid_template} | grep -v '^#')"
    right_status $?
    [ $p_count -ne $partition_count ] && die "blkid partition count does not match sfdisk partition count"
    return 0
}

ingest_lsblk_template() {
    # read blkid template line by line using info left of delimiter ':' to identify each line
    # (there should not be any comments or blank lines to ignore)
    # ignore the first (column names) line wth grep -v '^NAME'
    # verify partition_count; assign values for each partition pn_LABEL, pn_TYPE
    # assume only one "disk" line and if luks, only one "crypt" line (for now)
    # assume template was created by collect-layout-data tool
    # (which formats its output to include just these columns - NAME,SIZE,TYPE,MOUNTPOINTS)
    message_n "ingesting blkid_template"
    d_echo "" 5
    p_count=0  # verify against partition_count
    lv_count=0
    while read LINE ; do
        eval "$(echo $LINE | awk '{ print "NAME="$1 " SIZE="$2 " TYPE="$3 " MOUNTPOINTS="$4 }')"
        case $TYPE in
            "crypt" )
                lsblk_crypt_NAME=$NAME ; lsblk_crypt_SIZE=$SIZE
                d_message "lsblk_crypt_NAME: $lsblk_crypt_NAME" 5
                d_message "lsblk_crypt_SIZE: $lsblk_crypt_SIZE" 5
                template_varlist+=" lsblk_crypt_NAME lsblk_crypt_SIZE"
                ;;
            "disk"  )
                lsblk_disk_NAME=$NAME ; lsblk_disk_SIZE=$SIZE
                d_message "lsblk_disk_NAME: $lsblk_disk_NAME" 5
                d_message "lsblk_disk_SIZE: $lsblk_disk_SIZE" 5
                template_varlist+=" lsblk_disk_NAME lsblk_disk_SIZE"
                ;;
            "lvm"   )
                let lv_count+=1 ; d_message "lv_count: $lv_count" 5
                eval "lsblk_lv${lv_count}_NAME=$NAME"
                eval "lsblk_lv${lv_count}_SIZE=$SIZE"
                eval "lsblk_lv${lv_count}_MOUNTPOINTS=$MOUNTPOINTS"
                d_message "assigned lsblk_lv${lv_count}_NAME=$NAME" 5
                d_message "assigned lsblk_lv${lv_count}_SIZE=$SIZE" 5
                d_message "assigned lsblk_lv${lv_count}_MOUNTPOINTS=$MOUNTPOINTS" 5
                template_varlist+=" lsblk_lv${lv_count}_NAME lsblk_lv${lv_count}_SIZE lsblk_lv${lv_count}_MOUNTPOINTS"
                ;;
            "part"  )
                let p_count+=1 ; d_message "p_count: $p_count" 5
                eval "lsblk_p${p_count}_NAME=$NAME"
                eval "lsblk_p${p_count}_SIZE=$SIZE"
                eval "lsblk_p${p_count}_MOUNTPOINTS=$MOUNTPOINTS"
                d_message "assigned lsblk_p${p_count}_NAME=$NAME" 5
                d_message "assigned lsblk_p${p_count}_SIZE=$SIZE" 5
                d_message "assigned lsblk_p${p_count}_MOUNTPOINTS=$MOUNTPOINTS" 5
                template_varlist+=" lsblk_p${p_count}_NAME lsblk_p${p_count}_SIZE lsblk_p${p_count}_MOUNTPOINTS"
                ;;
            *       ) die "invalid TYPE [${TYPE}] in lsblk_template input LINE" ;;
        esac
    done <<< "$( grep -v '^NAME' ${config_dir%/}/${lsblk_template_dir%/}/${lsblk_template})"
    right_status $?
    lsblk_lv_count=${lv_count}
    template_varlist+=" lsblk_lv_count"
    [ $p_count -ne $partition_count ] && die "lsblk partition count does not match sfdisk partition count"
    return 0
}

set-crypt_keydev() {
#  set crypt_passphrase
    response=""
    msg="${BYon}Please provide a crypt_keydev identifier for this system${Boff}\n"
    msg+="  (${BMon}This will be used to encrypt data in the luks container${Boff})"
    msg+="  please identify how I should recognize the device --\n"
    msg+="    by name (e.g. /dev/sda1)\n"
    msg+="    by UUID (e.g. AB94-DF90\n"
    msg+="or by label (e.g. KEY or CARD)\n"
    message ${msg}
    E_message "${BMon}if you skip this step, external device keying will not be enabled${Boff}"
    echo
    response="n"
    while [[ "${response:0:1}" == [nN] ]] ; do
        echo -en " ${BGon}*${Boff} Enter crypt_keydev selector: "
        read candidate ; echo
        new_prompt "You entered crypt_keydev = ${candidate} ; is this correct?"
    done
    message_n "setting crypt_keydev ..."
    export crypt_keydev="${candidate}" || die "failed to assign crypt_keydev"
    echo -e -n " ${BGon}(success)${Boff}" ; right_status $TRUE
    return 0
}

set-crypt_passphrase() {
#  set crypt_passphrase
    response=""
    message "${BYon}You must provide a crypt_passphrase for this system${Boff}"
    message "  (${BMon}This will be used in formatting luks-encrypted partition(s)${Boff})"
    echo
    candidate1=X ; candidate2=Z
    while [[ "${candidate1}" != "${candidate2}" ]] ; do
        echo -en " ${BGon}*${Boff} Enter crypt_passphrase: "
        read -s candidate1 ; echo
        echo -en " ${BGon}*${Boff} Re-enter to confirm crypt_passphrase: "
        read -s candidate2 ; echo
        [[ "${candidate1}" != "${candidate2}" ]] && E_message "${BRon}candidate passphrases do not match${Boff}"
    done || die "failed while trying to get crypt_passphrase"
    message_n "setting that crypt_passphrase ..."
    export crypt_passphrase="${candidate1}" || die "failed to set crypt_passphrase"
    echo -en " ${BGon}(success)${Boff}" ; right_status $TRUE
    return 0
}

set-DEV_HOSTNAME() {
    #  set DEV_HOSTNAME - used in mount-the-rest.hostname script and if LUKS also in vg_hostname-
    [ -z ${DEV_HOSTNAME} ] && DEV_HOSTNAME="demobox"
    [ -f /usr/${TARGET}/etc/hostname ] && read -r candidate2 < /usr/${TARGET}/etc/hostname

    if [ ! $INTERACTIVE ] ; then
        # if not interactive, then go with template or default
        [ ! -z "${candidate2}" ] && DEV_HOSTNAME="${candidate2}"
    else
        # confirm or get hostname from user
        message "${BYon}Please select a hostname for this system${Boff}"
        message "  (${BMon}This will be used in naming volume groups used in cryptsetup layout${Boff})"
        message "  ${BYon}currently, DEV_HOSTNAME = [ $DEV_HOSTNAME ]"
        if [ ! -z ${candidate2} ] ; then
            E_message "${BMon}However, a (cross)build image is mounted at /usr/${TARGET}${Boff}"
            message "   ${BMon}and it's /etc/hostname contains \"${LBon}${candidate2}${BMon}\"${Boff}"
            message "   ${BYon}Type (s)kip if you want to use that hostname instead${Boff}"
        else
            candidate2="${DEV_HOSTNAME}"
            E_message "${BYon}Type (s)kip if you want to use that hostname${Boff}"
        fi
        echo
        response="n"
        msg="${BYon}Would you like to select a different hostname for this system?\n${Boff}"
        msg+="(${BWon}y:${LBon} yes, select new ;"
        msg+=" ${BWon}s:${LBon} skip, accept [${Boff}${candidate2}${LBon}] ;"
        msg+=" ${BWon}n:${LBon} no, exit program${Boff})"
        new_prompt "${msg}"
        case ${response:0:1} in
            [nN] ) die "aborting program as instructed" ;;
            [yY] ) message "affirmative response; continuing"; response="n" ;;
            [sS] ) candidate="${candidate2}" ; response="y" ;;
        esac
        while [[ "${response:0:1}" == [nN] ]] ; do
            echo -en "${BGon}*${Boff} set hostname for this system: "
            read candidate
            message "you responded [ ${candidate} ]"
            new_prompt "is this correct?"
        done
        message_n "setting DEV_HOSTNAME"
        export DEV_HOSTNAME="${candidate}" || die "failed to set DEV_HOSTNAME"
        echo -n " (${DEV_HOSTNAME})" ; right_status $TRUE
    fi
    # now use DEV_HOSTNAME to name the mount-the-rest.hostname script
    d_message_n "assigning mount_the_rest_script = mount-the-rest.${DEV_HOSTNAME} ..." 2
    mount_the_rest_script="mount-the-rest.${DEV_HOSTNAME}" ; d_right_status $? 2

    return 0
}

luks_lvm_config() {
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    # (1) this function only runs for LUKS, so sanity check that
    message_n "sanity-checking luks format request"
    if [ ${partition_count} -le 1 ] ; then
        echo -e -n " (${BRon}only ${partition_count} partition(s) defined${Boff})" ; right_status 1
        die "invalid partition configuration for joetoo use of luks container"
    else
        echo -e -n " (${#partition_list[@]} partitions defined)" ; right_status $TRUE
    fi

    # (3) now that it has been checked, use DEV_HOSTNAME to set root_vg
    export root_vg="vg_${DEV_HOSTNAME}"

    # check/get luks passphrase
    message_n "checking if crypt_passphrase is assigned"
    if [ -z $crypt_passphrase ] ; then
        echo -e " (crypt_passphrase ${BRon}unset${Boff})"
        set-crypt_passphrase
###        d_message "crypt_passphrase: $crypt_passphrase" 1
    else
        echo -e -n " (crypt_passphrase ${BGon}set${Boff})" ; right_status $TRUE
    fi

    # (4) if crypt_keydev is set, use it to get keyfile
    message_n "checking for keying device crypt_keydev"
    if [ -z $crypt_keydev ] ; then
        # otherwise, scan for default crypt_keydev and if found, use that to set keyfile
        echo -e -n " (${BRon}unset${Boff}, scanning)"
        eval $(lsblk -P -o NAME,LABEL,MOUNTPOINTS | grep 'LABEL="KEY"')
        if [ -z $NAME ] ; then
            echo " (not found)"
            set-crypt_keydev
            d_message "crypt_keydev is now set [${crypt_keydev}]" 3
        else
            crypt_keydev="/dev/${NAME}"
            echo -n " (scanned: ${crypt_keydev})" ; right_status $TRUE
        fi
    else
        echo -n " (alreaady assigned: ${crypt_keydev})"  ; right_status $TRUE
    fi
    # mount crypt_keydev, verify keyfile exists, assign keyfile variable
    get_luks_keyfile || die "failed to get_luks_keyfile"

    # (5) validate keyfile, which should be assigned now
    message_n "validating keyfile"
    if [ -f ${keyfile} ] ; then
        echo -e -n " (${keyfile})" ; right_status $TRUE
    else
        echo -e -n " (${BRon}${keyfile} does not exist${Boff})" ; right_status 1
        die "keyfile pathname is assigned, but the file does not exist"
    fi

    # (6) set luks partition and container names
    # luks_partition_device and edev now set in initialization

    # if we made it this far and did not choke, return success
    return 0
}


calculate_lv_sizes() {
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    # build "lookup table" to properly size LVs for this device
    # moved calc of disksize and swap_size to initialization
    # if disk size is < 200G use mini-luks format
    if [ $(( $disksize_MiB * $MiB )) -lt $(( 200 * ${GiB} )) ] ; then
        # use mini-luks format (root, usr, and swap LVs only)
        LVM_list="root usr swap" # save "extra" for later
        d_message "small disk [$ez_disksize_MiB] LVM_list: $LVM_list" 4
        # swap_size already set
        # use actual disk size to scale-map usr_size
        # from 9G (min) to 15G (preferred) between 32G and 200G disk-size range
        # new_usr:9::disk_MiB:32 or map 9 (0-32) to (0-disk_MiB) but cap at 15
        d_message_n "mapping usr_lv_size for small disk" 4
        result=0
        map 9 0 32 0 ${disksize_GiB} 1 || \
            die "failed to map-scale lv_size[usr] for small disk"
        lv_size[usr]="${result}G"
        echo -e -n " (${lv_size[usr]})" ; d_right_status $? 4
        # allocate whatever is left to the root LV
        d_message_n "setting root_lv_size for small disk" 4
        lv_size[root]="$(( ${disksize_GiB} - ${swap_size} - ${usr_lv_size}))G" || \
            die "failed to set lv_size[root] for small disk"
        echo -e -n " (${lv_size[root]})" ; d_right_status $? 4
    else
        # otherwise use standard LVs with size appropriate for this disk
        LVM_list="root usr var opt swap home tmp srv" # save "extra" for later
        d_message "large disk [$ez_disksize_MiB] LVM_list: $LVM_list" 4
        # swap_size already set
        # set root usr var opt to standard sizes
        d_message "setting LV sizes for large disk" 4
        d_message_n "setting standard size for root LV" 4
        lv_size[root]="10G" || die "failed to set lv_size[root] for large disk"
        echo -e -n " (${lv_size[root]})" ; d_right_status $? 4

        d_message_n "setting standard size for usr LV" 4
        lv_size[usr]="75G" || die "failed to set lv_size[usr] for large disk"
        echo -e -n " (${lv_size[usr]})" ; d_right_status $? 4

       d_message_n "setting standard size for var LV" 4
        lv_size[var]="75G" || die "failed to set lv_size[var] for large disk"
        echo -e -n " (${lv_size[var]})" ; d_right_status $? 4

        d_message_n "setting standard size for opt LV" 4
        lv_size[opt]="5G" || die "failed to set lv_size[var] for large disk"
        echo -e -n " (${lv_size[opt]})" ; d_right_status $? 4

        d_message_n "reporting size already allocated for swap LV" 4
        echo -e -n " (${lv_size[swap]})" ; d_right_status $? 4

        # set ( home tmp srv ) by mapping to reference range
        # use template lv size  to scale-map this lv_size
        #     from range (200G to actual template disk size)
        #     to range (200G this disk-size)

        gibval=0 # (re)initialize
#        convert_size_to_GiB "123T" 2 ; echo "gibval: $gibval"

        # get template_crypt_size from already-ingested data
        d_message "lsblk_crypt_SIZE: ${lsblk_crypt_SIZE}" 4
        convert_size_to_GiB "${lsblk_crypt_SIZE}" 1 || die "failed convert_size_to_GiB lsblk_crypt_SIZE"
        template_crypt_size=${gibval}
        d_message "template_crypt_size: $template_crypt_size" 4

        # get this_crypt_size from lsblk *** must be done AFTER luksFormat
        lookup_size=$(lsblk -lno NAME,SIZE,TYPE ${OUTPUTDEVICE} | grep crypt | awk '{print $2}') || \
            die "failed to look up lsblk crypt size"
        d_message "lsblk lookup crypt_size: $lookup_size" 4
        convert_size_to_GiB ${lookup_size} || die "failed convert_size_to_GiB lookup_size"
        this_crypt_size=${gibval}
        d_message "this_crypt_size: $this_crypt_size" 4
        # calculate the amount of disk allocated to fixed-size volumes
        used=0
        for x in root usr var opt swap; do
            d_message_n "used: $used" 5
            # drop the trailing "G" on the size
            x_size=$(echo ${lv_size[${x}]} | sed 's|G$||')
            echo -e -n "; ${x}_size: ${x_size}" 5
            used=$(echo "scale=1; $used + ${x_size=}" | bc -l)
            echo "; accumulated, now with $x: $used" 5
        done
        d_message "used: $used" 5
        # calculate the amount remaining for non-fixed size volumes in both the template and this disk
        template_remainder=$(echo "scale=1; ${template_crypt_size} - ${used}" | bc -l)
        d_message "template_remainder: $template_remainder" 5
        this_remainder=$(echo "scale=1; ${this_crypt_size} - ${used}" | bc -l)
        d_message "this_remainder: $this_remainder" 5

        # for home, tmp, srv - allocate proportionally (this_lv:this_crypt :: template_lv:template_crypt)
        for lv_name in home tmp srv; do
            # look up the size of this LV in lsblk template; then convert to GiB
            template_lv_lookup=$(grep 'lvm' ${config_dir%/}/${lsblk_template_dir}/${lsblk_template} | grep ${lv_name} | awk '{print $2}') || \
                die "failed to get template_lv_lookup"
            d_message "${lv_name} template_lv_lookup: ${template_lv_lookup}" 4
            convert_size_to_GiB ${template_lv_lookup} || die "failed convert_size_to_GiB template_lv_lookup"
            template_lv_size=${gibval}
            d_message "${lv_name} template_lv_size: ${template_lv_size}" 4
            # calculate the proportional size for this LV
           # allocate the same fraction of space as was allocated in the part of the template not allocated to fixed-size volumes
            # (scale up/down depending on relative size of template and this disk)
            result=0
            map ${template_lv_size} 0 ${template_remainder} 0 ${this_remainder} 1 || \
                die "failed to calculate converted_size"
            converted_size="${result}G"  # add the "G" for sake of lvcreate -L
            lv_size[${lv_name}]="${converted_size}" || die "failed to set lv_size[${lv_name}]"
            d_message "new lv_size[${lv_name}]: ${lv_size[${lv_name}]}" 4
        done
        # space will be allocated for "extra" LV *after* other LVs have actually been created/formatted
    fi

    # if we made it this far and did not choke, return success
    return 0
}

convert_size_to_GiB() {
    # convert size ($1) to GiB
    input_size=$1
    scale=${2:-1}  # set scale to 1 if not supplied on command line as $2
    gibval=0  #initialize
    # read input_size and convert to GiB if needed
    units=$(right_most ${input_size})
#    units=$(echo ${input_size} | rev | cut -c1)
    val=${input_size%${units}}
#    d_message "input_size: $input_size" 5
#    d_message "scale: $scale" 5
#    d_message "units: $units" 5
#    d_message "val: $val" 5
    case ${units} in
        [tT]  ) gibval=$(echo "scale=$scale; (($val * 1024))" | bc -l) && return 0 ;;
        [gG]  ) gibval=$val && return 0 ;;
        [mM]  ) gibval=$(echo "scale=$scale; (( $val / 1024.0 ))" | bc -l) && return 0 ;;
        [kK]  ) gibval=$(echo "scale=$scale; (( $val / ${MiB} ))" | bc -l) && return 0 ;;
        [0-9] )
            # no units provided
            val=${input_size}
            gibval=$(echo "scale=$scale; (( $val / ${GiB} ))" | bc -l) && return 0 ;;
        *     ) E_message "invalid units in convert_size_to_GiB"
    esac
    # if we got here, one of the avove failed to return 0
    E_message "looks like a failure to convert_size_to_GiB"
    return 1
}

calculate_appropriate_swap() {
    # calculate appropriate swap size for this board
    # Gentoo rule: MEM<=2G swap=2*MEM; 2G<MEM<6G swap=MEM+2G; MEM>=6G swap=8G
    # joetoo rule: min swap=4G; 2G<MEM<6G swap=MEM+2G; MEM>=6G swap=8G
    # assume no hibernation in joetoo systems (would need swap>=MEM even in big systems)
    d_message "looking up appropriate swap size for BOARD [$BOARD]" 5
    case ${BOARD} in
        "bcm2712-rpi-cm5-cm5io"            ) lv_size[swap]="8G" ;; # 8G RAM
        "bcm2712-rpi-5-b"                  ) lv_size[swap]="8G" ;; # 8G RAM
        "bcm2711-rpi-cm4-io"               ) lv_size[swap]="8G" ;; # 4G or 8GRAM
        "bcm2711-rpi-4-b"                  ) lv_size[swap]="8G" ;; # 4G or 8G RAM
        "bcm2710-rpi-3-b-plus"             ) lv_size[swap]="6G" ;; # 4G RAM
        "bcm2710-rpi-3-b"                  ) lv_size[swap]="4G" ;; # 1G RAM
        "bcm2709-rpi-2-b"                  ) lv_size[swap]="4G" ;; # 1G RAM
        "bcm2708-rpi-b"                    ) lv_size[swap]="4G" ;; # 500M RAM
        "rk3288-tinker-s"                  ) lv_size[swap]="4G" ;; # 2G RAM
        "rk3399-rock-pi-4c-plus"           ) lv_size[swap]="6G" ;; # 4G RAM
        "rk3399-rock-4se"                  ) lv_size[swap]="6G" ;; # 4G RAM
        "rk3399-tinker-2"                  ) lv_size[swap]="4G" ;; # 2G RAM
        "rk3588-rock-5b"                   ) lv_size[swap]="8G" ;; # 8G RAM
        "rk3588-radxa-rock-5b+"            ) lv_size[swap]="8G" ;; # 8G+ RAM
        "rk3588s-orangepi-5"               ) lv_size[swap]="8G" ;; # 15G RAM
        "rk3588s-orangepi-5b"              ) lv_size[swap]="8G" ;; # 15G RAM
        "rk3588s-rock-5c"                  ) lv_size[swap]="8G" ;; # 15G RAM
        "fsl-imx8mq-phanbell"              ) lv_size[swap]="4G" ;; # 1G or 2G RAM
        "meson-gxl-s905x-libretech-cc-v2"  ) lv_size[swap]="4G" ;; # 2G RAM (sweet potato)
        "meson-sm1-s905d3-libretech-cc"    ) lv_size[swap]="6G" ;; # 4G RAM (solitude)
        "meson-g12b-a311d-libretech-cc"    ) lv_size[swap]="4G" ;; # 6G RAM (alta)
        "generic-armv6j"                   ) lv_size[swap]="8G" ;; # assume >8G RAM
        "generic-armv7a"                   ) lv_size[swap]="8G" ;; # assume >8G RAM
        "generic-aarch64"                  ) lv_size[swap]="8G" ;; # assume >8G RAM
        "generic-amd64"                    ) lv_size[swap]="8G" ;; # assume >8G RAM
        *                                  ) die "invalid board in SWAP size calculation"
    esac
    d_message "lv_size[swap] = ${lv_size[swap]}" 5
    return 0
}

layout_partitions() {
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    # use sfdisk script to lay out partitions
    if [ $INTERACTIVE ] ; then
        message "About to run sfdisk script to replicate template layout on OUTPUTDEVICE [$OUTPUTDEVICE]"
        confirm_continue_or_exit
    fi
    sfdisk ${OUTPUTDEVICE} < ${config_dir%/}/${sfdisk_template_dir%/}/${sfdisk_template} || \
        die "sfdisk script failed"
    return 0
}

format_partitions() {
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    # use blkid template data (already ingested) to format partitions
    for ((i=1; i<=${partition_count}; i++)) ; do
        # if this is the last partition in a LUKS setup, don't format it; be done now
        [ $i -eq ${partition_count} ] && [ $LUKS ] && return 0
        # otherwise, determine the partition name on the new device
        #   use TYPE in formatted lablk -o output to filter on partition (ignore disk) lines with grep 'part'
        #   use PARTN to identify THIS partition number in column 3 of formated -o output with awk
        p_dev_name="${OUTPUTDEVICE}${p_prefix}${i}"
        d_message "i: $i" 4
        d_message "p_dev_name: $p_dev_name" 4

        eval "myType=\${blkid_p${i}_TYPE}"
        eval "myLabel=\${blkid_p${i}_LABEL}"
        case ${myType} in
            ""            )
                d_message "skipping un-typed/un-formatted partition [${p_dev_name}]" 1
                ;;
            "vfat"        )
                # example mkfs.vfat -F 32 -n efi_fs /dev/sdc2
                myCmd="mkfs.vfat -F 32"
                [ ! -z "${myLabel}" ] && myCmd+=" -n ${myLabel}"
                myCmd+=" ${p_dev_name} >/dev/null 2>/dev/null"
                d_message_n "running [${myCmd}] ..." 1
                eval "${myCmd}" || die "failed to format ${p_dev_name}"
                d_right_status $? 1
                ;;
            "ext2"        )
                # example mkfs.ext2 -L boot_fs /dev/sdc1
                myCmd="mkfs.ext2"
                [ ! -z "${myLabel}" ] && myCmd+=" -L ${myLabel}"
                myCmd+=" ${p_dev_name} >/dev/null 2>/dev/null"
                d_message_n "running [${myCmd}] ..." 1
                eval "${myCmd}" || die "failed to format ${p_dev_name}"
                d_right_status $? 1
                ;;
            "ext4"        )
                # example mkfs.ext4 -L root_fs /dev/sdc2
                myCmd="mkfs.ext4"
                [ ! -z "${myLabel}" ] && myCmd+=" -L ${myLabel}"
                myCmd+=" ${p_dev_name} >/dev/null 2>/dev/null"
                d_message_n "running [${myCmd}] ..." 1
                eval "${myCmd}" || die "failed to format ${p_dev_name}"
                d_right_status $? 1
                ;;
            "crypto_LUKS" )
                # set traps for mis-use of this type
                [ ! $LUKS ]] && die "crypto_LUKS format requested but LUKS is FALSE; => fix templates"
                [ ! $i -eq $partition_count ] && die "crypto_LUKS format type requested but this is not the last partition; => fix templates"
                # ignore this here - call layout_cryptsetup_lvm separately from main script
                d_message "skipping ${myType} typed partition [${p_dev_name}] for now" 1
                ;;
            *             ) die "invalid partition type in blkid_template input" ;;
        esac
    done

    return 0
}

layout_cryptsetup_lvm() {
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    # luks_partition_device and edev were set in luks_lvm_config (and shown in display_configuration)

    # dd random data to the luks "part" name
    myCmd="dd if=/dev/urandom of=${luks_partition_device} bs=4M status=progress"
    msg="about to run [${myCmd}]\n"
    msg+="(you can safely skip this step if you have done it before)\n"
    msg+="(y: yes; s: skip; n: exit program)"
    response=""
    if [ $INTERACTIVE ] ; then
        new_prompt "${msg}"
    else
        response="y"
    fi
    case ${response:0:1} in
        [yY] )
            maybe_format_warning || die "failed format_warning somehow"
            # ensure disk-write is complete before reporting
            ${myCmd} && sync || die "failed to execute ${myCmd}"
            ;;
        [nN] ) die "aborting, as instructed" ;;
        [sS] ) message "skipping, as instructed" ;;
        *    ) die "invalid response to new_prompt for dd command"
    esac

    # run cryptsetup luksFormat (provide passphrase it will ask for)
    d_message "using passphrase to run cryptsetup -q luksFormat ${luks_partition_device}" 3
    message_n "formatting luks_partition_device [${luks_partition_device}] ..."
    eval "echo -n ${crypt_passphrase} | cryptsetup -q luksFormat ${luks_partition_device} --label luks_fs"
    result=$? ; right_status $result ; [ $result -eq 0 ] || die "cryptsetup failed to luksFormat ${luks_partition_device}"

    # run cryptsetup luksAddKey (should already be mounted) (provide passphrase it will ask for)
    message_n "using passphrase to add keyfile with cryptsetup luksAddKey ${luks_partition_device} ${keyfile} ..."
    eval "echo -n ${crypt_passphrase} | cryptsetup luksAddKey ${luks_partition_device} ${keyfile}"
    result=$? ; right_status $result ; [ $result -eq 0 ] || die "cryptsetup failed to luksAddKey ${luks_partition_device} ${keyfile}"

    # open (unlock) the device
    message_n "unlocking ${luks_partition_device} as ${edev} with key at ${keyfile}"
    cryptsetup luksOpen -d ${keyfile} ${luks_partition_device} ${edev} || die "failed to unlock device"
    right_status $TRUE

    # create physical volume (PV)
    message_n "creating PV /dev/mapper/${edev} ..."
    pvcreate /dev/mapper/${edev} >/dev/null || \
        die "failed to pvcreate /dev/mapper/${edev} >/dev/null"
    right_status $TRUE

    # create volume group (VG)
    message_n "creating VG vg_${DEV_HOSTNAME} ..."
    vgcreate vg_${DEV_HOSTNAME} /dev/mapper/${edev} >/dev/null || \
        die "failed to vgcreate vg_${DEV_HOSTNAME} /dev/mapper/${edev} >/dev/null"
    right_status $TRUE

    # if disk size is < 200G use mini-luks format, otherwise,

    # use lsblk "lvm" lines (already ingested) to create and format logical volumes (LVs)
    # (these are named root, usr, var, opt, tmp, home, srv, swap, etc)
    # use algorithm to properly size the volumes for this device

    # ignore the lvx_SIZE from lsblk template data (use lookup)
    # will use small-disk layout for < 200G
    calculate_lv_sizes || die "failed to calculate_lv_sizes"

    d_message "here are the assigned lv_size values" 5
    for LVM_name in ${LVM_list}; do
        d_message "lv_size[${LVM_name}]: ${lv_size[${LVM_name}]}" 5
    done

    for LVM_name in ${LVM_list}; do
        LVM_size=${lv_size[${LVM_name}]}
        d_message "LVM_name: $LVM_name ; LVM_size: $LVM_size" 5
        d_message "lv_size[${LVM_name}]: ${lv_size[${LVM_name}]}" 5
        message_n "creating LV ${LVM_name} with size ${LVM_size} on VG vg_${DEV_HOSTNAME}"
        lvcreate -L ${LVM_size} -n ${LVM_name} vg_${DEV_HOSTNAME} >/dev/null || \
            die "failed to lvcreate vg_${DEV_HOSTNAME}-${LVM_name}"
        right_status $TRUE

        message_n "formatting LV vg_${DEV_HOSTNAME}-${LVM_name}"
        if [[ "${LVM_name}" == "swap" ]] ; then
            mkswap -L "swap_fs" /dev/mapper/vg_${DEV_HOSTNAME}-${LVM_name} 2>/dev/null >/dev/null || \
                die "failed to mkswap"
            right_status $TRUE
        else
            mkfs.ext4 -L "${LVM_name}_fs" "/dev/mapper/vg_${DEV_HOSTNAME}-${LVM_name}" 2>/dev/null >/dev/null || \
                die "failed to mkfs.ext4 for vg_${DEV_HOSTNAME}-${LVM_name}"
            right_status $TRUE
        fi
    done

    # now that space for other LVs has been allocated, allocate whatever is left to "extra" LV
    # (MUST be done after other space is already allocated for vgs to report what is available)
    # (note that --units G will result in "G" appended to size value --> ok for use in lvcreate -L)
    # (HOWEVER, vgs reports G as multiples of 1000 and g as multiples of 1024, whereas lvcreate
    #  treats both as representing multiples of 1024, so we CANNOT use the vgs --units G number as
    # input to lvcreate for this final volume - there won't be space left; we have to use "--units g")
    unused=$(vgs --noheadings --units g  -o vg_free vg_${DEV_HOSTNAME})
    d_message "unused: $unused" 5
    convert_size_to_GiB ${unused} 1  # scale to 1 digit after decimal to ensure space (round down)
    lv_size[extra]="${gibval}G"   # append G so lvcreate will treat as GiB (mult. of 1024)
    # now create/format "extra"
    LVM_name="extra"
    d_message "lv_size[${LVM_name}]: ${lv_size[${LVM_name}]}" 5
    # lvcreate
    message_n "creating LV ${LVM_name} with size ${lv_size[${LVM_name}]} on VG vg_${DEV_HOSTNAME}"
        lvcreate -L ${lv_size[${LVM_name}]} -n ${LVM_name} vg_${DEV_HOSTNAME} >/dev/null || \
            die "failed to lvcreate vg_${DEV_HOSTNAME}-${LVM_name}"
        right_status $TRUE
    # format
    message_n "formatting LV vg_${DEV_HOSTNAME}-${LVM_name}"
    mkfs.ext4 -L "${LVM_name}_fs" "/dev/mapper/vg_${DEV_HOSTNAME}-${LVM_name}" 2>/dev/null >/dev/null || \
        die "failed to mkfs.ext4 for vg_${DEV_HOSTNAME}-${LVM_name}"
    right_status $TRUE

    message "done creating/formatting all LVs"

    # if we made it this far and did not choke, return success
    return 0
}

mount_and_populate() {
    # mount and minimally populate the new root device
    # Things to make (based on layout, UUIDs, etc)
    #     create fstab?
    #     create boot config (joetooEnv.txt/boot.cmd or cmdline.txt/config.txt)
    #     link from /var/www to /var/srv
    #     mount-the-rest.hostname script
    #     chroot-prep script and chroot-commands text file
    separator ${PN} "(${FUNCNAME[0]})"
    d_message "in ${FUNCNAME[0]}" 4

    ERROR=$FALSE   # write_mount_the_rest_script can set this $TRUE

    # identify the name and UUID of the root device (LV if LUKS, part if not)
    identify_root_device || die "failed to identify_root_device for ${PN}"
    d_message "(${PN}) ROOT_DEVICE: $ROOT_DEVICE   ROOT_UUID: $ROOT_UUID" 5

    message_n "mounting new root dev [ /dev/mapper/vg_${DEV_HOSTNAME}-root ] ..."
    mount ${ROOT_DEVICE} ${root_dev_mountpoint} 2>/dev/null || die "failed to mount ${ROOT_DEVICE} ${root_dev_mountpoint} "
    right_status $TRUE

    # populate the chroot-prep script
    message_n "populating ${chroot_prep_script} ..."
    cp -a ${config_dir%/}/mkdev-files/chroot-prep ${root_dev_mountpoint%/}/${chroot_prep_script} || \
        die "failed to copy chroot-prep script to ${root_dev_mountpoint%/}/"
    right_status $TRUE

    # populate the chroot-commands file
    message_n "populating ${chroot_command_textsfile} ..."
    cp -a ${config_dir%/}/mkdev-files/chroot-commands ${root_dev_mountpoint%/}/${chroot_command_textsfile} || \
        die "failed to copy chroot-commands text file to ${root_dev_mountpoint%/}/"
    right_status $TRUE

    # if there is not more than one partition, then this is not applicable
    if [ ${partition_count} -gt 1 ] ; then
        # populate the mount-the-rest.<hostname> script, to mount other LVs and/or partitions
        write_mount_the_rest_script || die "failed to write_mount_the_rest_script"
    else
        message "partition_count is [${partition_count}]; mount-the-rest script is N/A; skipping"
    fi

    [ $ERROR ] && return 1
    return 0
}

write_mount_the_rest_script() {
    # populate the mount-the-rest.<hostname> script, to mount other LVs and/or partitions
    # initialize script file by writing header line with ">"
    message_n "creating ${mount_the_rest_script} ..."
    echo "#!/bin/bash" > ${root_dev_mountpoint%/}/${mount_the_rest_script} ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac
    # append mountpoint line
    message_n "appending mountpoint=${root_dev_mountpoint} to ${mount_the_rest_script}"
    echo "mountpoint=${root_dev_mountpoint}" >> ${root_dev_mountpoint%/}/${mount_the_rest_script} ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # if LUKS, append a root_vg line to identify the VG parent of all LVs
    if [ $LUKS ] ; then
        message_n "appending root_vg line to identify the VG parent of all LVs"
        echo "root_vg=vg_${DEV_HOSTNAME}" >> ${root_dev_mountpoint%/}/${mount_the_rest_script} ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1; ERROR=$TRUE ;;
        esac
    fi
    # append a partition_list line and look up uuid while we're at it
    # (use live blkid data to get var/val pairs for LABEL, TYPE, UUID)
    pnames=""
    unset partition_uuids
    declare -A partition_uuids # partition_uuids is associative; pnames and partition_list just word-lists
    TERMWIDTH=$(termwidth) # for non_stty_right_status (needed b/c it is inside while read loop)
    while read -r LINE ; do
        LABEL=""; TYPE=""; UUID=""
        assignments=$(echo $LINE | cut -d':' -f2-)
        eval $assignments
        # if LUKS, ignore a TYPE="crypto_LUKS" line; otherwise trap it as an error
        if [[ "$TYPE" == "crypto_LUKS" ]] ; then
            if [ $LUKS ] ; then
                message "ignoring TYPE=crypto_LUKS partition in LUKS layout"
            else
                die "plain layout requested, but crypto_LUKS partition discovered"
            fi
        elif [[ "$TYPE" == "" ]] ; then
            # ignore un-typed/unformatted partitions like bios boot
            message "ignoring un-typed/unformatted partitions (e.g. legacy bios boot)"
        else
            # not a crypto_LUKS partition - process it
            d_message "for partition_list - LABEL: $LABEL   TYPE: $TYPE   UUID: $UUID" 4
            selector="$(echo $LABEL | sed 's|_fs||')"
            d_message "  selector: $selector" 5
            d_message "  UUID: $UUID" 5
            message "appending ${selector} to partition_list"
            pnames+=" ${selector}"
            # save uuid assignment data while we are here
            d_message "  pnames: ${pnames}" 5
            eval "partition_uuids[${selector}]=$UUID"
            d_message "  partition_uuids[${selector}]: ${partition_uuids[${selector}]}" 5
        fi
    done <<<$(blkid | grep ${OUTPUTDEVICE})
    d_message "recap pnames: ${pnames}" 5
#    d_message "recap partition_uuids[@]: ${partition_uuids[@]}" 5
    debug_do 'echo -e "${BMon} * ${Boff}recap partition_uuids[@]: ${partition_uuids[@]}"' 5
    message_n "appending partition_list assignment line"
    echo "partition_list=\"${pnames}\"" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # now append uuid assignments for all partitions, using partition_uuids already saved
    for selector in ${pnames} ; do
        uuid_assignment="${selector}_uuid=${partition_uuids[${selector}]}"
        message_n "appending uuid assignment: [${uuid_assignment}]"
        echo "${uuid_assignment}" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1; ERROR=$TRUE ;;
        esac
        non_stty_right_status $? || (non_stty_right_status $?; ERROR=$TRUE)
    done

    # now append mountpoint assignments for all partitions
    # (use blkid to get partitions again, lsblk template to get mountpoins)
    for selector in ${pnames} ; do
        mp=$(awk '$3 =="part" {print $4}' ${config_dir%/}/${lsblk_template_dir%/}/${lsblk_template} | grep ${selector})
        if [ -z "${mp}" ] ; then
            # no mountpoint for this partition found in lsblk template
            E_message "no mountpoint for LABEL=$LABEL found in lsblk template"
            message_n "trying work-around"
            # see if an easy fix can be applied
            case $selector in
                "root" ) mp="/"     ; echo -e -n " (assigned ${mp})" ; result=0 ;;
                "boot" ) mp="/boot" ; echo -e -n " (assigned ${mp})" ; result=0 ;;
                *      ) echo -e -n " (none yet available)" ; result=1 ; ERROR=$TRUE ;;
            esac
            right_status $result
        fi
        mp_assignment="${selector}_mountpoint=${mp}"
        message_n "appending mountpoint assignment: [${mp_assignment}]"
        echo "${mp_assignment}" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
        case $result in
            0 ) non_stty_right_status $TRUE ;;
            * ) non_stty_right_status 1; ERROR=$TRUE ;;
        esac
    done
    # append a blank line, for format clarity
    message_n "appending a blank line, for format clarity"
    echo "" >> ${root_dev_mountpoint%/}/${mount_the_rest_script} ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # now append (concatenate) a standard script to mount partitions
    message_n "concatenating standard script to mount partitions"
    cat ${config_dir%/}/mkdev-files/mount-PARTs_template >> ${root_dev_mountpoint%/}/${mount_the_rest_script} ; result=$? 
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # append a blank line, for format clarity
    message_n "appending a blank line, for format clarity"
    echo "" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # if LUKS, append (concatenate) a standard script to mount LVs
    if [ $LUKS ] ; then
        message_n "concatenating standard script to mount LVs"
        cat ${config_dir%/}/mkdev-files/mount-LVs_template.luks >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1; ERROR=$TRUE ;;
        esac
    fi
    # append a blank line, for format clarity
    message_n "appending a blank line, for format clarity"
    echo "" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # append a line that will generate a blank line in output, for format clarity
    message_n "appending a line to generate a blank line, for format clarity"
    echo "echo" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # append lines that will display what was mounted
    message_n "appending lines to display what was mounted (indented)"
    echo "echo 'here is what was mounted --'" >> ${root_dev_mountpoint%/}/${mount_the_rest_script} && \
    echo "mount | grep ${root_dev_mountpoint} | sed 's|^|    |'" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    # capture and append the blkid data for each partition
    # (prefix each line with # to comment it out)
    # append a blank line, for format clarity
    message_n "appending a blank line, for format clarity"
    echo "" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
    case $result in
        0 ) right_status $TRUE ;;
        * ) right_status 1; ERROR=$TRUE ;;
    esac

    for selector in ${pnames} ; do
        # get blkid data to append to file
        message_n "capturing blkid data for ${selector} ..."
        blkid_data="$(blkid | grep ${partition_uuids[${selector}]} | sed 's|^|#|')" && \
        echo "# ${blkid_data}" >> ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1; ERROR=$TRUE ;;
        esac
    done
    # make the script executable
    message_n "making ${root_dev_mountpoint%/}/${mount_the_rest_script} executable"
    chmod +x ${root_dev_mountpoint%/}/${mount_the_rest_script}  ; result=$?
        case $result in
            0 ) right_status $TRUE ;;
            * ) right_status 1; ERROR=$TRUE ;;
        esac
    return 0
}

local_sanity_check() {
    # check for insane or stupid stuff
    # todo: validate all three template parts (sfdisk, blkid, lsblk) for consistency
    # partition type vs format; device size; partition sizes
    d_message "sanity check partition_count: [$partition_count]" 5
    [ $partition_count -gt 9 ] && die "invalid partition_count; ${PN} supports up to 9"
    d_message "sanity check disksize_bytes: [$disksize_bytes] vs 32 * GiB [$((32 * $GiB))]" 5
    [ $disksize_bytes -lt $((32 * $GiB)) ] && die "rejecting device with less than 32GiB space"
    return 0
}

maybe_luks_lvm_config() {
    if [ $LUKS ] ; then
        # validate luks container (appropriate partition, size)
        # set device hostname (for vg naming)
        # set luks pashphrase
        # id and mount luks keying device and assign keyfile
        luks_lvm_config || return 1
    fi
    return 0
}

maybe_layout_cryptsetup_lvm() {
    if [ $LUKS ] ; then
        layout_cryptsetup_lvm || return 1
    else
        message "luks lvm layout not requested; skipping"
    fi
    return 0
}

maybe_format_warning() {
    if [ $INTERACTIVE ] ; then
        format_warning || return 1
    fi
    return 0
}

#-----[ main script ]---------------------------------------------
checkroot
separator "$(hostname)" "${PN}"
# option -s|--status is the only one that can appear alone on the command line
# otherwise there must be at least 4: -b <BOARD> -o <OUTPUTDEVCIE>
arglist="$@"
[ $# -eq 0 ] && E_message "null command line arguments" && usage
[ $# -eq 1 ] && [[ "$1" != "-"*"s"* ]] && [[ "$1" != "--status" ]] && E_message "invalid argument(s) [$arglist]" && usage
[ $# -lt 4 ] && E_message "invalid argument(s) [$arglist]" && usage

# basic common approach - 
# initialize variables (local function)
# validate_status_file  (script_header_joetoo_extended)
# process_cmdline (script_header_joetoo_extended)
# validate_target which must follow process_cmdline (cb-common-functions)
# display_configuration so we can see what's what if insane (script_header_joetoo_extended)
# sanity_check (cb-common-functions)
# run_sequence (script_header_joetoo_extended)
# (here, display config and local_sanity_check are included in command_sequence due to pre-requisite complexity)
initialize_variables || die "failed initialize_variables"
validate_status_file ${layoutstatusfile} || die "Failed to validate_status_file"

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5
# over-ride configuration with commandline input
separator ${PN} "(process_cmdline)"
process_cmdline ${@} || usage

# validate BOARD, assign TARGET, ARCH. etc.
validate_target ${BOARD} || die "failed validate_target ${BOARD}"
# validate OUTPUTDEVICE
validate_device ${OUTPUTDEVICE} || die "failed to validate device [ ${OUTPUTDEVICE} ]"
# now assign variables that depend on BOARD and/or OUTPUTDEVICE
assign_BOARD_and_OUTPUTDEVICE_derived_variables || die "failed assign_BOARD_and_OUTPUTDEVICE_derived_variables"

# Note: choice of config file selects templates (e.g. mmc.plain or nvme.luks)

run_sequence ${layoutstatusfile} || die "Failed to run_sequence"

# possible to-do - create draft_fstab_generator_script
# run mount-the-rest, then use lsblk data to get uuid, mountpoint, fstype (use lookup to determine options and pass/dump)
# for now, leave that for cb-flash-device, which needs to do that anyway

echo
message "layout complete"
message "${BYon}The root device [${ROOT_DEVICE}] has been mounted for you at [${root_dev_mountpoint}]${Boff}"
if [ ${partition_count} -gt 1 ] ; then
    message "${BYon}You can mount the rest of the new fs with --"
    message "  ${BGon}cd ${root_dev_mountpoint}; ./mount-the-rest.${DEV_HOSTNAME}${Boff}"
    message "${BMon}Caution:${BYon} you should validate mount-the-rest.${DEV_HOSTNAME} before you run it${Boff}"
    echo
fi
message "${BYon}Note: you can use ${BGon}cb-flash-device <BOARD> <OUTPUTDEVICE>${Boff}"
message "        to load the new device with data from a"
message "        mounted (cross)build-target image file"

exit 0
