#!/bin/bash
#
# mkcrossbuildupdate   joe brendler 15 December 2025
#
# interactive sequence to update a crossbuilt image via cross-build and chroot methods
#    for ${TARGET} system
#

# Note: based on the cb-mkenv script and command_sequence, modified for purpose.
#   Further modified to take only a stockpiled filename as arg $1 (like cb-mount-binhost)
#   and derive BOARD and TARGET from that.

# 20251218/19 - consolidated functions from cb-mkenv, cb-mkimg, and cb-mkupd to cb-common-functions --
# buildtarget-qemu()
# emerge-host-world()
# configure-make-conf-for-crossbuilding()
# configure-make-conf-for-chroot()
# emerge-cross-rust-std()
# rebuild-rust-and-llvm()
# prepare-cross-rust()
# run-dispatch-conf()
# edit-make-conf()
# edit-package-use-platform()
# edit-package-use-common()
# edit-package-accept-keywords()
# create-new-cross-compiler()

# 20260107 - switched from rust-std (legacy Gentoo Crossbuild-Environment wiki)
#    to rust-bin as cross-compiler for rust, with RUST_CROSS_TARGETS array
#    defined at /etc/portage/env/dev-lang/rust
#    (updated prepare-cross-rust() and deprecated emerge-cross-rust-std in cb-common-functions)
#    (*for cb-mkupd*) moved prepare-cross-rust to include as part of validate-prerequisites()
#     which runs BEFORE run-sequence

# ToDo: - consolidate other functions cb-mkimg to cb-common-functions

source /usr/sbin/script_header_joetoo
source /usr/sbin/script_header_joetoo_unicode

PN=$(basename $0)
config_dir="/etc/crossbuild-tools"

message_n "sourcing BUILD ..."
source "${config_dir%/}/BUILD" ; right_status $?

#message_n "sourcing BPN ..."
#source /etc/crossbuild-tools/BPN ; right_status $?
message_n "assigning BPN = $(basename ${config_dir})/${PN}.local"
BPN="$(basename ${config_dir})/${PN}.local" || die "failed to assign BPN" ; right_status $TRUE

source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
# set verbosity > 1 for debug incl initialization
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

response=""

#-----[ variables ]-----------------------------------------------------

varlist="PN BPN BUILD BREAK UPDATEIMAGE BOARD TARGET"
varlist+=" TARGET_ARCH QEMU_ARCH STAGE3_SELECTOR default_profile LLVM_TARGET"
varlist+=" BREAK starting_step stopping_step mkupdstatusfile user STOCKPILE"
varlist+=" bool.RESUME bool.INTERACTIVE"
varlist+=" bool.CREATE bool.DESTROY"
varlist+=" BREAK bool.VERBOSE verbosity old_dir"

command_sequence=(
'create-new-cross-compiler'
'cb-populate-upd ${BOARD}'
'configure-make-conf-for-crossbuilding'
'edit-make-conf'
'edit-package-use-platform'
'${TARGET}-emerge -av --sync'
'${TARGET}-emerge -av joetoo-platform-meta'
'run-dispatch-conf'
'edit-make-conf'
'edit-package-use-platform'
'edit-package-use-common'
'edit-package-accept-keywords'
'FEATURES="-collision-detect -protect-owned" ${TARGET}-emerge -av joetoo-common-meta'
'run-dispatch-conf'
'TARGET-emerge-world'
'run-dispatch-conf'
'buildtarget-qemu'
'emerge-host-world'
'configure-make-conf-for-chroot'
'edit-make-conf'
'cb-chroot-update'
'cb-umount ${BOARD}'
'stockpile-img'
)

msg1_sequence=(
'create new cross compiler'
'populate new/updated image filesystem'
'configure make.conf for crossbuilding'
'edit make.conf'
'edit platform-specific package.use'
'run TARGET-emerge --sync'
'run TARGET-emerge joetoo-platform-meta'
'run dispatch-conf'
'edit make.conf'
'edit platform-specific package.use'
'edit common package.use'
'edit package.accept_keywords'
'run ignore collisions TARGET-emerge joetoo-common-meta'
'run dispatch-conf'
'run TARGET-emerge update world set'
'run dispatch-conf'
'run buildtarget-qemu'
'emerge-world to restore host'
'prepare cross-rust'
'rebuild rust and llvm'
'emerge cross-rust-std'
'configure make.conf for chroot'
'edit make.conf'
'run cb-chroot-update'
'run cb-umount ${BOARD}'
'save updated image to STOCKPILE'
)

#-----[ functions ]-----------------------------------------------------

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?

# usage() ... moved to script_header_joetoo_extended, suplemented by /etc/${BPN}/local.usage

initialize_variables() {
    [ $verbosity -lt 2 ] && message_n "initializing ..." || message "initializing ..."

    # save variables we have in varlist but dont want to lose
    oldVERBOSE=$VERBOSE; oldverbosity=$verbosity
    oldUPDATEIMAGE="$UPDATEIMAGE"
    initialize_vars ${varlist}

    # set default values
    FLAGGED=$FALSE
    d_message_n "sourcing BUILD ..." 2
    source /etc/crossbuild-tools/BUILD ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting PN = $(basename $0)" 2
    PN=$(basename $0) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "assigning BPN = $(basename ${config_dir})/${PN}.local" 2
    BPN="$(basename ${config_dir})/${PN}.local" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "sourcing cb-common-functions ..." 2
    source /usr/sbin/cb-common-functions ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting old_dir = $(pwd)" 2
    export old_dir=$(pwd) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting user = joe" 2
    export user="joe" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting STOCKPILE = /home/${user}/sbc-stockpile" 2
    export STOCKPILE="/home/${user}/sbc-stockpile" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "(re)setting UPDATEIMAGE = $oldUPDATEIMAGE" 2
    export UPDATEIMAGE="$oldUPDATEIMAGE" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default starting_step = 0" 2
    export starting_step=0 ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    export stopping_step=$(( ${#command_sequence[@]} - 1 )) ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default mkupdstatusfile = /root/bin/mkcrossbuildenv_status" 2
    export mkupdstatusfile="/root/bin/mkcrossbuildenv_status" ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default INTERACTIVE true" 2
    export INTERACTIVE=$TRUE ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default VERBOSE = $(TrueFalse $oldVERBOSE)" 2
    export VERBOSE=$oldVERBOSE ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    d_message_n "setting default verbosity = $oldverbosity" 2
    export verbosity=$oldverbosity ; result=$?
    if [ $result -eq 0 ] ; then d_right_status $TRUE 2; else FLAGGED=$TRUE; d_right_status 1 2; fi

    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above"
        return 1
    else
        message "initialization complete"
        return 0
    fi
}

stockpile-img() {
    # (should be run after finalize-chroot-upd and cb-umount have both completed)
    # copy the completed ${BOARD}.img file so it can be used as a minimal
    # start point for development of multle different individual systems
    # and/or as a distcc-cross-build or binary package server on this or
    # some other CHOST (save file as ${BOARD}.env

    copy-to-stockpile "/usr/${BOARD}.img" "${STOCKPILE%/}/${UPDATEIMAGE}"

    return 0
}

validate_prerequisites() {
    separator "${PN}" "(${FUNCNAME[o]})"

    # must do ____ things before we can start or resume run-sequence
    # (1) Verify that the STOCKPILE UPDATEIMAGE exists
    # (2) make sure there isn't already something mounted on this TARGET mountpoint
    # (3) make sure there isn't a ${BOARD}.img file already active for this board
    # (4) check if a /usr/BOARD.img file is already in use (and remove it if so)
    # (5) validate the crossdev repository and cross-rust for TARGET
    # (6) verify the TARGET crossdevelopment mountpoint still exists
    # (7) copy the STOCKPILE UPDATEIMAGE file to /usr/
    # (8) mount the new /usr/${BOARD}.img file on the crossdev $TARGET


    # (1) Verify that the STOCKPILE UPDATEIMAGE exists
    # do this first so we can assign BOARD and run validate_target to assign TARGET
    message "verifying <UPDATEIMAGE> ..."
    if [ -f "${STOCKPILE%/}/${UPDATEIMAGE}" ] ; then
        message_n "deriving BOARD"
        BOARD="$(echo ${UPDATEIMAGE}| cut -d'_' -f1)"
        result=$?
        if [ "$result" -eq 0 ] ; then
            echo -e -n " (${BGon}$BOARD${Boff})"
            right_status $TRUE
        else
            echo -e -n " (${BRon}error${Boff})"
            right_status 2
            return 2
        fi  # result
    else
        E_message "${STOCKPILE%/}/${UPDATEIMAGE} does not exist"
        usaage
    fi  # updateimage existence
    # now use BOARD to validate TARGET
    validate_target ${BOARD} || usage

    # (2) make sure there isn't already something mounted on this TARGET mountpoint
    MOUNTPOINT_BUSY=$FALSE
    LOOPDEV_BUSY=$FALSE
    message_n "checking for other active crossbuilding on TARGET mountpoint"
    findmnt_output=$(findmnt -M /usr/${TARGET} -Po SOURCE)
    if [ ! -z "${findmnt_output}" ] ; then
        right_status 1
        eval "${findmnt_output}"
        E_message "${BRon}$SOURCE${Boff} is already mounted on ${LBon}$TARGET${Boff}"
        MOUNTPOINT_BUSY=$TRUE
#        die "Please correct this before continuing"
    else
        echo -e -n " (${BGon}clear${Boff})"
        right_status $TRUE
    fi  # something else mounted for crossbuilding

    # (3) make sure there isn't a ${BOARD}.img file already active for this board
    loop_dev=$(losetup -a -O NAME,BACK-FILE | grep "/usr/${BOARD}.img" | cut -d' ' -f1 | head -n1)
    if [ ! -z "${loop_dev}" ] ; then
        right_status 1
        E_message "${BRon}$loop_dev${Boff} is already active for ${LBon}/usr/${BOARD}.img${Boff}"
        LOOPDEV_BUSY=$TRUE
#        die "Please correct this before continuing"
    else
        echo -e -n " (${BGon}clear${Boff})"
        right_status $TRUE
    fi  # something else mounted for crossbuilding

    if [ $MOUNTPOINT_BUSY ] || [ $LOOPDEV_BUSY ] ; then
        message "running cb-umount to release busy device(s)"
        cb-umount "${BOARD}" || die "failed cb-umount ${BOARD}"
    fi

    # (4) check if a /usr/BOARD.img file is already in use (and remove it if so)
    message "checking for pre-existing $BOARD.img"
    cb-cleanup "${BOARD}"

    # (5) validate the crossdev repository and cross-rust for TARGET
    message_n "looking for /var/db/repos/crossdev/"
    if [ ! -d "/var/db/repos/crossdev" ] ; then
        echo -e -n " (${BRon}not found${Boff})"
        right_status 1
        die "please run ${BWon}eselect repository create crossdev /var/db/repos/crossdev${Boff}"
    else
        echo -e -n " (${BGon}found${Boff})"
        right_status $TRUE
        message_n "looking for /var/db/repos/crossdev/cross-${TARGET}"
        if [ ! -d "/var/db/repos/crossdev/cross-${TARGET}" ] ; then
            echo -e -n " (${BRon}not found${Boff})"
            right_status 1
            E_message "TARGET sub-repo will need to be re-generated (Ok to continue)"
            E_message "Note: cross-rust will not work until prepare-cross-rust() runs"
        else
            echo -e -n " (${BGon}found${Boff})"
            right_status $TRUE
            message "TARGET sub-repo exists and will be updated (Ok to continue)"
            # as of crossbuild-tools-0.12.15 and prior used rust-std for cross-rust
            # based on legacy Gentoo Crossbuild-Environment wiki procedure
            # starting with 0.12.16 we use rust-bin instead and drop code previously found here to validate
            # the crossdev repos cross-${TARGET}/rust-std symlinks. Now we just
            # run prepare-cross-rust() and rebuild-rust-and-llvm() from cb-common-functions
            # (i.e. these are pre-requisite in cb-mkupd whereas they are part of run-sequence in cb-mkenv)
            message "(re)validating cross-rust ..."
            # update configs to use rust-bin as cross-compiler and
            #  set RUST_LLVM_CHANGE_FLAG=$TRUE in order to make rebuild-rust-and-llvm()
            #  update rust-bin [which is a dependency of crossbuild-tools], if needed)
            prepare-cross-rust || die "failed to prepare-cross-rust"
            # rebuild @world to update rust and llvm with the new configuration, if it changed
            rebuild-rust-and-llvm || die "failed to rebuild-rust-and-llvm"
        fi # sub-repo existence
    fi  # repo existence

    # (6) verify the TARGET crossdevelopment mountpoint still exists
    message_n "looking for /usr/${TARGET}"
    if [ ! -d "/usr/${TARGET}" ] ; then
        echo -e -n " (${BRon}not found${Boff})"
        right_status 1
        mkdir /usr/${TARGET} || die "failed to mkdir /usr/${TARGET}"
        echo -e -n " (${BGon}created${Boff})"
        right_status $TRUE
    else
        echo -e -n " (${BGon}found${Boff})"
        right_status $TRUE
    fi  # mountpoint existence

    # (7) copy the STOCKPILE UPDATEIMAGE file to /usr/
    msg="${BYon}copy ${UPDATEIMAGE} from STOCKPILE to /usr/ as ${BMon}${BOARD}.img${Boff}\n"
    msg+="(if you copied it manually, you can safely skip this)"
    new_prompt "${msg}"
    case ${response:0:1} in
        [yY] )
            message_n "copying image file"
            cp "${STOCKPILE%/}/${UPDATEIMAGE}" "/usr/${BOARD}.img" || die "failed to cp ${STOCKPILE%/}/${UPDATEIMAGE} /usr/${BOARD}.img"
            echo -e -n " (${BGon}copied${Boff})"
            # remove immutable attribute flag
            chattr -i "/usr/${BOARD}.img" 2>/dev/null || die "failed to unset immutabile flag"
            echo -e -n " (${BGon}immutable unset${Boff})"
            right_status $TRUE
            ;;
        [sS] ) mesasge_n "skipping copy"
            right_status $TRUE
            ;;
        * ) die "Please correct this before continuing" ;;
    esac

    # (8) mount the new /usr/${BOARD}.img file on the crossdev $TARGET
    cb-mount "${BOARD}" || die "failed to cb-mount ${BOARD}"

    return 0
}

local_sanity_check() {
    separator "${PN}" "(${FUNCNAME[o]})"
    message "might not need this function if it can be combined in validate-prerequisites"
}

debug_marker() {
    bremoji "${heart_red}${VS16}" ; echo -n " "
    echo -e -n "${Ron}D${BRon}e${Yon}b${BYon}u${Gon}g${BGon}_${LBon}M${Bon}a${BBon}r${Mon}k${BMon}e${Won}r${BWon}!${Boff}"
    echo -n " " ; bremoji $explosion; echo
    exit 1
}

#-----[ main script ]---------------------------------------------
checkroot
separator ${PN} $(hostname)
# only stockpiled filename (<UPDATEIMAGE=>) -s required (w/ -u)
# option s (status) is the only one that can appear alone on the command line
# - otherwise it should be at least 2: -u <UPDATEIMAGE>
arglist="$@"
[ $# -eq 0 ] && E_message "null command line arguments" && usage
[ $# -eq 1 ] && [[ "$1" != "-"*"s"* ]] && [[ "$1" != "--status" ]] && E_message "invalid argument(s) [$arglist]" && usage
[ $# -lt 2 ] && E_message "invalid argument(s) [$arglist]" && usage
UPDATEIMAGE="$1"

# basic common approach -
# initialize variables (local function)
# validate_status_file  (script_header_joetoo_extended)
# process_cmdline (script_header_joetoo_extended)
# validate_prerequisites (not already crossbuilding; have crossdev, target mountpoint)
# validate_target which must follow process_cmdline (cb-common-functions)
# display_configuration so we can see what's what if insane (script_header_joetoo_extended)
# local_sanity_check (rather than one in cb-common-functions that won't fit)
# run_sequence (script_header_joetoo_extended)

# initialize variables and set default values
initialize_variables || die "Failed to initialize_variables"

validate_status_file ${mkupdstatusfile} || die "Failed to validate_status_file"

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5

# over-ride configuration with commandline input
separator ${PN} "(process_cmdline)"
echo "checking BPN: [$BPN]"
echo "local cmdline args: [/etc/${BPN}/local.cmdline_arguments]"
process_cmdline ${@} || usage

# validate prerequisites and derive BOARD and TARGET from UPDATEIMAGE
validate_prerequisites ${UPDATEIMAGE} || usage

display_configuration || die "Failed to display_configuration"

local_sanity_check  || die "Failed local_sanity_check"

run_sequence ${mkupdstatusfile} || die "Failed to run_sequence"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0

#debug_marker

