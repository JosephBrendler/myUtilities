#!/bin/bash
#
# mkcrossbuildupdate   joe brendler 15 December 2025
#
# interactive sequence to update a crossbuilt image via cross-build and chroot methods
#    for ${TARGET} system
#

# Note: based on the cb-mkenv script and command_sequence, modified for purpose.
#   Further modified to take only a stockpiled filename as arg $1 (like cb-mount-binhost)
#   and derive BOARD and TARGET from that.
# Mpte: in cb-mkenv and cb-mkimg, the crossbuild and chroot actions occur in separate
#   scripts - here in cb-mkupd, both happen in this script

source /usr/sbin/script_header_joetoo
source /usr/sbin/script_header_joetoo_unicode

PN=$(basename $0)
config_dir="/etc/crossbuild-tools"

message_n "sourcing BUILD ..."
source "${config_dir%/}/BUILD" ; right_status $?

#message_n "sourcing BPN ..."
#source /etc/crossbuild-tools/BPN ; right_status $?
message_n "assigning BPN = $(basename ${config_dir})/${PN}.local"
BPN="$(basename ${config_dir})/${PN}.local" || die "failed to assign BPN" ; right_status $TRUE

source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
# set verbosity > 1 for debug incl initialization
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

response=""

#-----[ variables ]-----------------------------------------------------

varlist="PN BPN BUILD BREAK UPDATEIMAGE BOARD TARGET"
varlist+=" TARGET_ARCH QEMU_ARCH STAGE3_SELECTOR default_profile LLVM_TARGET"
varlist+=" BREAK starting_step stopping_step mkupdstatusfile stockpile_dir"
varlist+=" bool.RESUME bool.INTERACTIVE"
varlist+=" bool.CREATE bool.DESTROY"
varlist+=" BREAK bool.VERBOSE verbosity old_dir"

command_sequence=(
'create-new-cross-compiler'
'cb-populate-update'
'configure-make-conf-for-crossbuilding'
'edit-make-conf'
'edit-package-use-platform'
'${TARGET}-emerge -av --sync'
'${TARGET}-emerge -av joetoo-platform-meta'
'run-dispatch-conf'
'edit-make-conf'
'edit-package-use-platform'
'edit-package-use-common'
'edit-package-accept-keywords'
'FEATURES="-collision-detect -protect-owned" ${TARGET}-emerge -av joetoo-common-meta'
'run-dispatch-conf'
'TARGET-emerge-world'
'run-dispatch-conf'
'buildtarget-qemu'
'emerge-host-world'
'prepare-cross-rust'
'rebuild-rust-and-llvm'
'emerge-cross-rust-std'
'configure-make-conf-for-chroot'
'edit-make-conf'
'chroot-update'
'cb-umount ${BOARD}'
'stockpile-img'
)

msg1_sequence=(
'create new cross compiler'
'populate new/updated image filesystem'
'configure make.conf for crossbuilding'
'edit make.conf'
'edit platform-specific package.use'
'TARGET-emerge --sync'
'TARGET-emerge joetoo-platform-meta'
'run dispatch-conf'
'edit make.conf'
'edit platform-specific package.use'
'edit common package.use'
'edit package.accept_keywords'
'ignore collisions TARGET-emerge joetoo-common-meta'
'run dispatch-conf'
'TARGET-emerge update world set'
'run dispatch-conf'
'buildtarget-qemu'
'emerge-world to restore host'
'prepare cross-rust'
'rebuild rust and llvm'
'emerge cross-rust-std'
'configure make.conf for chroot'
'edit make.conf'
'chroot-updafe'
'cb-umount ${BOARD}'
'save updated image to stockpile'
)

#-----[ functions ]-----------------------------------------------------

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?

# usage() ... moved to script_header_joetoo_extended, suplemented by /etc/${BPN}/local.usage

initialize_variables() {
    [ $verbosity -lt 2 ] && message_n "initializing ..." || message "initializing ..."

    # save variables we have in varlist but dont want to lose
    oldVERBOSE=$VERBOSE; oldverbosity=$verbosity
    oldUPDATEIMAGE="$UPDATEIMAGE"
    initialize_vars ${varlist}

    # set default values
    FLAGGED=$FALSE
    d_message_n "sourcing BUILD ..." 2
    source /etc/crossbuild-tools/BUILD && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting PN = $(basename $0)" 2
    PN=$(basename $0) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "assigning BPN = $(basename ${config_dir})/${PN}.local" 2
    BPN="$(basename ${config_dir})/${PN}.local" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "sourcing cb-common-functions ..." 2
    source /usr/sbin/cb-common-functions && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting old_dir = $(pwd)" 2
    export old_dir=$(pwd) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting user = joe" 2
    export user="joe" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting stockpile = /home/${user}/sbc-stockpile" 2
    export stockpile="/home/${user}/sbc-stockpile" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "(re)setting UPDATEIMAGE = $oldUPDATEIMAGE" 2
    export UPDATEIMAGE="$oldUPDATEIMAGE" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default starting_step = 0" 2
    export starting_step=0 && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default stopping_step = $(( ${#command_sequence[@]} - 1 ))" 2
    export stopping_step=$(( ${#command_sequence[@]} - 1 )) && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default mkupdstatusfile = /root/bin/mkcrossbuildenv_status" 2
    export mkupdstatusfile="/root/bin/mkcrossbuildenv_status" && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default INTERACTIVE true" 2
    export INTERACTIVE=$TRUE && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default VERBOSE = $(TrueFalse $oldVERBOSE)" 2
    export VERBOSE=$oldVERBOSE && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    d_message_n "setting default verbosity = $oldverbosity" 2
    export verbosity=$oldverbosity && d_right_status $? 2 || ( d_right_status $? 2 && FLAGGED=$TRUE )
    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above"
        return 1
    else
        message "initialization complete"
        return 0
    fi
}

stockpile-img() {
    # (should be run after finalize-chroot and cb-umount have both completed)
    # copy the completed ${BOARD}.img file so it can be used as a minimal
    # start point for development of multle different individual systems
    # and/or as a distcc-cross-build or binary package server on this or
    # some other CHOST (save file as ${BOARD}.env

    # create stockpile directory if it doesn't exist
    message_n "examining stockpile"
    if [ ! -d ${stockpile} ] ; then
        echo -en " (${BRon}not found${Boff})"
        mkdir -p ${stockpile} && \
            echo -en " (${BGon}created${Boff})" || die "failed to create stockpile"
    else
        echo -en " (${BGon}found${Boff})"
    fi
    right_status $TRUE

    if [ -f ${stockpile%/}/${UPDATEIMAGE} ] ; then
        response=""
        msg="${BYon}${stockpile%/}/${UPDATEIMAGE} already exists. ${BRon}Create backup?\n${Boff}"
        msg+="${BWon}(y|Y: backup; n|N: abort; s|S: skip/overwrite)${Boff}"
        new_prompt "${msg}"
        case ${response:0:1} in
            [yY] )
                cp "${stockpile%/}/${UPDATEIMAGE}" "${stockpile%/}/${UPDATEIMAGE}.bak" || die "failed to create backup"
                echo -e -n " (${BGon}backed-up${Boff})"
                right_status $TRUE
                ;;
            [sS] ) echo -e -n " (${BMon}overwriting${Boff})"
                right_status $TRUE
                ;;
            * ) die "Please correct this before continuing" ;;
        esac
    fi
    # copy /usr/${BOARD}.img to ${stockpile}/${UPDATEIMAGE}
    message_n "stockpiling ${BOARD}.img as ${UPDATEIMAGE}"
    cp /usr/${BOARD}.img ${stockpile%/}/${UPDATEIMAGE} && \
        echo -en " (${BGon}copied${Boff})" || die "failed copy to stockpile"
    right_status $TRUE
    return 0
}

chroot-update() {
    separator "${PN}" "(${FUNCNAME[0]})"

    # possible validate dirlist
    # set old dir; cd mountpoint
    old_dir="$(pwd)"
    cd /usr/${TARGET}
    message "now working in crossbuild target directory: [${Mon}$(pwd)${Boff}]"

    mount_list="proc dev sys "
    # equivalent to "mount-everything" function in cb-chroot-target
    # tmp optional, and /dev/pts only for X
    mount-chroot-prep || die "failed mount-chroot-prep for ${PN}"

    # actual chroot
    chroot . /bin/bash --login

    echo
    cd old_dir
    message "now working in previous directory: [${Mon}$(pwd)${Boff}]"

    # equivalent to "umount-everything" function in cb-chroot-target
    #umount /usr/${TARGET}/dev/pts
    #umount /usr/${TARGET}/tmp
    umount-chroot-prep || FLAGGED=$TRUE

    [ $FLAGGED ] && return 1
    return 0
}

emerge-host-world() {
    options="--update --verbose --deep --newuse --getbinpkg --usepkg --keep-going"
    [ $INTERACTIVE ] && options+=" --ask"
    emerge @world ${options} ; result=$?
    return $result
}

configure-make-conf-for-crossbuilding() {
    # remove any pending version of make.conf and accept delivery of chroot and crossbuild versions
    message_n "accepting pending ._cfgxxxx_make.conf installs ..."
    for x in /etc/portage/._cfg*make.conf; do rm $x ; done
    for x in /etc/portage/._cfg*make.conf.crossbuild; do 
        mv $x make.conf.crossbuild
    done
    for x in /etc/portage/._cfg*make.conf.chroot; do
        mv $x make.conf.chroot
    done
    right_status $TRUE
    # change to the chroot version of make.conf installed by joetoo-platform-meta
    message_n "configuring make.conf for crossbuilding ..."
    newfile="/usr/${TARGET}/etc/portage/make.conf.crossbuild"
    oldfile="/usr/${TARGET}/etc/portage/make.conf"
    cp "${newfile}" "${oldfile}" || die "failed to cp ${newfile} ${oldfile}"
    right_status $TRUE
    return 0
}

configure-make-conf-for-chroot() {
    # change to the chroot version of make.conf installed by joetoo-platform-meta
    newfile="/usr/${TARGET}/etc/portage/make.conf.chroot"
    oldfile="/usr/${TARGET}/etc/portage/make.conf"
    message_n "configuring make.conf for chroot ..."
    cp "${newfile}" "${oldfile}" || die "failed to cp ${newfile} ${oldfile}"
    right_status $TRUE
    return 0
}

emerge-cross-rust-std() {
    # build cross-${TARGET}/rust-std
    options="--verbose --getbinpkg --usepkg"
    [ $INTERACTIVE ] && options+=" --ask"
    emerge cross-${TARGET}/rust-std ${options} ; result=$?
    return $result
}

rebuild-rust-and-llvm() {
    # rebuild rust and llvm with the new configuration, if it changed
    if [ $RUST_LLVM_CHANGE_FLAG ] ; then
        # configuration changed - rebuild
        message "${BYon}rust/llvm configuration ${BMon}changed -- rebuilding${Boff}"
        options="--update --verbose --deep --newuse --getbinpkg --usepkg"
        [ $INTERACTIVE ] && options+=" --ask"
        emerge @world ${options} ; result=$?
    else
        # configuration unchanged - just continue
        message "${BYon}rust/llvm configuration ${BGon}unchanged -- continuing${Boff}"
        right_status $TRUE
        result=0
    fi
    return $result
}

prepare-cross-rust() {
    # Some packages (such as gnome-base/librsvg) depend on a rust cross toolchain
    # so build the rust cross toolchain

    # change this if we have to modify the system
    export RUST_LLVM_CHANGE_FLAG=$FALSE

    host_package_use="/etc/portage/package.use/joetoo"
    # verify that USE flag "dev-lang/rust rust-src" is in CHOST's package.use
    message_n "looking for \"dev-lang/rust rust-src\" in ${host_package_use}"
    if grep -qF -- "dev-lang/rust rust-src" "${host_package_use}" ; then
        echo -en " (${BGon}found${Boff}))"
    else
        echo -en " (${BRon}not found${Boff}))"
        echo -e "\ndev-lang/rust rust-src" >> "${host_package_use}" || die "failed to append rust-src use flag"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE

    # verify that USE flag "dev-lang/rust-bin rust-src" is in CHOST's package.use
    message_n "looking for \"dev-lang/rust-bin rust-src\" in ${host_package_use}"
    if grep -qF -- "dev-lang/rust-bin rust-src" "${host_package_use}" ; then
        echo -en " (${BGon}found${Boff}))"
    else
        echo -en " (${BRon}not found${Boff}))"
        echo -e "\ndev-lang/rust-bin rust-src" >> "${host_package_use}" || die "failed to append rust-src use flag"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE

    # verify or correct LLVM_TARGETS in CHOST's make.conf
    # not sure this is really necessary -- all targets may be unconditionally enabled in llvm-core/llvm(?)
    # Gentoo forum administrator Hu noted on Fri Sep 16, 2022 -- news regarding adjustment of profiles' package.use.force --
        # Michał Górny <mgorny@gentoo.org> (2021-11-04)
        # Enable all LLVM targets unconditionally.  Unfortunately, disabling
        # targets tend to break reverse dependencies (e.g. Rust) and we are yet
        # to find a clean way of resolving that.  Compared to the damage
        # potential, the increase of build time is a minor problem.  Users who
        # really insist of building a smaller system can un-force the flags
        # at their own responsibility.
    # see more in footnote at the bottom of this file
    # anyway, do this for now
    # if make.conf doesn't contain LLVM_TARGETS, then add them
    host_make_conf="/etc/portage/make.conf"
    message "examining LLVM_TARGETS in ${host_make_conf}"
    message_n "looking for ${LLVM_TARGET}"
    if grep -qF "LLVM_TARGETS=" "${host_make_conf}" ; then
        # make.conf contains an assigment for LLVM_TARGETS - is this board's target in it?
        source "${host_make_conf}"  # activate the current assignemt so we can check it
        if [[ "${LLVM_TARGETS}" == *"${LLVM_TARGET}"* ]] ; then
            # our target is already included
            echo -en " (${BGon}found${Boff})"
        else
            echo -en " (${BRon}not found${Boff})"
            echo -e "\nLLVM_TARGETS=\"AArch64 AMDGPU ARM AVR BPF Hexagon Lanai LoongArch MSP430 Mips NVPTX PowerPC RISCV Sparc SystemZ VE WebAssembly X86 XCore SPIRV\"" >> "${host_make_conf}" && \
                echo -en "(${BGon}appended${Boff})" || die "failed to append LLVM_TARGETS to CHOSTs make.conf"
            export RUST_LLVM_CHANGE_FLAG=$TRUE
        fi
    else
        # make.conf does not contain an assignment for LLVM_TARGETS -- append one
        echo -en " (${BRon}not found${Boff})"
        echo -e "\nLLVM_TARGETS=\"AArch64 AMDGPU ARM AVR BPF Hexagon Lanai LoongArch MSP430 Mips NVPTX PowerPC RISCV Sparc SystemZ VE WebAssembly X86 XCore SPIRV\"" >> "${host_make_conf}" && \
            echo -en "(${BGon}appended${Boff})" || die "failed to append LLVM_TARGETS to CHOSTs make.conf"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE

    # now set up cross-rust in CHOSTs crossdev repo

    VALID_LINK=$FALSE
    message "creating rust-std link in crossdev repo (to CHOSTs rust-std ebuilds) ..."
    old_dir="$(pwd)"
    cd /var/db/repos/crossdev/cross-${TARGET} && \
    message "now working in crossdev repo: [${Mon}$(pwd)${Boff}]"
    message_n "looking for link"
    if [ -L rust-std ] ; then
        echo -en " (found, "
        # link forund - right target?
        target_path=$(readlink -f rust-std)
#        olv_verbosity=$verbosity ; verbosity=5
#        d_message "target_path: [${target_path}]" 4
#        verbosity=$old_verbosity
        if [[ "${target_path}" == "/var/db/repos/gentoo/sys-devel/rust-std" ]] ; then
            # link points to correct target
            echo -en "${BGon}valid${Boff})"
            VALID_LINK=$TRUE
        else
            # link does not point to correct target -- remove it
            echo -en "${BRon}invalid${Boff})"
            rm rust-std && echo -en "(removed)" || die "failed to remove invalid rust-std link"
        fi
    else
        echo -en " (not found)"
        # no link found
    fi
    if [ ! $VALID_LINK ] ; then
        # valid link does not yet exist or invalid one was removed -- create it
        ln -s /var/db/repos/gentoo/sys-devel/rust-std && \
            echo -en "(${BGon}created${Boff})" || die "failed to create link for rust-std"
    fi
    # if we got here (didn't die above) close action as OK
    right_status $TRUE
    echo
    cd $old_dir
    message "now working in previous directory: [${Mon}$(pwd)${Boff}]"

    # now unmask rust-std in CHOSTs package.accept_keywords
    message_n "unmasking rust-std in CHOSTs package.accept_keywords ..."
    echo "cross-${TARGET}/rust-std **" >> /etc/portage/package.accept_keywords/cross-target-rust-std && \
        right_status $? || die "failed to unmasking rust-std in CHOSTs package.accept_keywords"

    # now validate or create /etc/portage/env/dev-lang/rust per-package env setting
    # (should be installed by this package's ebuild)
    message_n "examining /etc/portage/env/dev-lang/rust"
    if [ -e /etc/portage/env/dev-lang/rust ] ; then
        echo -en " (${BGon}found${Boff})"
    else
        # not found - create
        echo -en " (${BRon}not found${Boff})"
        CONTENT="RUST_CROSS_TARGETS=(\n"
        CONTENT+=" \"ARM:arm-unknown-linux-gnueabihf:armv6j-unknown-linux-gnueabihf\"\n"
        CONTENT+=" \"ARM:armv7-unknown-linux-gnueabihf:armv7a-unknown-linux-gnueabihf\"\n"
        CONTENT+=" \"AArch64:aarch64-unknown-linux-gnu:aarch64-unknown-linux-gnu\"\n"
        CONTENT+=" )"
        echo -e "${CONTENT}" > /etc/portage/env/dev-lang/rust && \
            echo -en "(${BGon}created${Boff})" || die "failed to create /etc/portage/env/dev-lang/rust"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE
    return 0
}

buildtarget-qemu() {
    # this used to be a separate script cb-buildtarget-qemu
    old_dir="$(pwd)"
    cd /usr/${TARGET}
    message "now working in crossbuild target directory: [${Mon}$(pwd)${Boff}]"

    [[ $INTERACTIVE ]] && emerge_options="-av1" || emerge_options="-v1"

    message "building qemu for ${TARGET} ..."
    FEATURES="-getbinpkg" QEMU_USER_TARGETS="${QEMU_ARCH}" QEMU_SOFTMMU_TARGETS="${QEMU_ARCH}" \
        USE="static-user -plugins static-libs" emerge ${emerge_options} --buildpkg qemu || \
            die "failed to build qemu for ${TARGET}"
    right_status $TRUE

    message "installing qemu binary in ${TARGET} ..."
    ROOT=/usr/${TARGET}/ emerge ${emerge_options} --usepkgonly --nodeps qemu || \
        die "failed to build (install) qemu binary in ${TARGET}" \
    right_status $TRUE

    # cross-rust setup has been relocated to step 16 in cb-mkenv

    echo
    cd $old_dir
    message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
    return 0
}

run-dispatch-conf() {
    # run dispatch-conf to activate newly installed configs
    ROOT="/usr/${TARGET}/" dispatch-conf
    return $?
}

edit-make-conf() {
    # use system editor to edit config file
    ${EDITOR} /usr/${TARGET}/etc/portage/make.conf
    return $?
}

edit-package-use-platform() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.use/ -iname "*joetoo_${BOARD}")
    ${EDITOR} ${configfile}
    return $?
}

edit-package-use-common() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.use/ -iname "*joetoo_common")
    ${EDITOR} ${configfile}
    return $?
}

edit-package-accept-keywords() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.accept_keywords/ -iname "*joetoo")
    ${EDITOR} ${configfile}
    return $?
}

create-new-cross-compiler() {
    message "creating new crossdev cross compiler. Done after stage3 extraction"
    message "because crossdev may produce split-usr layout, and I prefer the"
    message "merged-usr layout that modern stage3 provides ..."
    echo
    FLAGGED=$FALSE
    for x in profiles metadata; do
        target_dir="/var/db/repos/crossdev/${x}"
        message_n "validating ${target_dir} ..."
        if [ ! -d ${target_dir} ] ; then
            echo -en " (${BYon}creating${Boff})"
            mkdir -p ${target_dir} && right_status $? || ( right_status $? && FLAGGED=$TRUE )
        else
            echo -en " (${BGon}valid${Boff})"
            right_status $TRUE
        fi
    done

    # validate or populate /var/db/repos/crossdev/metadata/layout.conf
    message_n "validating /var/db/repos/crossdev/metadata/layout.conf ..."
    if [ ! -f /var/db/repos/crossdev/metadata/layout.conf ] || \
       [ -z "$(grep 'masters = gentoo' /var/db/repos/crossdev/metadata/layout.conf 2>/dev/null)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'masters = gentoo' > /var/db/repos/crossdev/metadata/layout.conf && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # validate or populate /var/db/repos/crossdev/profiles/repo_name
    message_n "validating /var/db/repos/crossdev/profiles/repo_name ..."
    if [ ! -f /var/db/repos/crossdev/profiles/repo_name ] || \
       [ -z "$(grep 'crossdev' /var/db/repos/crossdev/profiles/repo_name)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'crossdev' > /var/db/repos/crossdev/profiles/repo_name && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # set permissions
    message_n "setting permission for portage on /var/db/repos/crossdev ..."
    chown -R portage:portage /var/db/repos/crossdev && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )

    # now actually build the new cross-compiler
    message "building new cross-compiler ..."
    crossdev -S -t ${TARGET} && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )
    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above" ; return 1
    else
        message "cross-compiler creation complete" ; return 0
    fi
}

validate_prerequisites() {
    separator "${PN}" "(${FUNCNAME[o]})"

    # Verify that the stockpile UPDATEIMAGE exists
    # do this first so we can assign BOARD and validate_targer
    message "verifying <UPDATEIMAGE> ..."
    if [ -f "${stockpile%/}/${UPDATEIMAGE}" ] ; then
        message_n "deriving BOARD"
        BOARD="$(echo ${UPDATEIMAGE}| cut -d'_' -f1)"
        result=$?
        if [ "$result" -eq 0 ] ; then
            echo -e -n " (${BGon}$BOARD${Boff})"
            right_status $TRUE
        else
            echo -e -n " (${BRon}error${Boff})"
            right_status 2
            return 2
        fi  # result
    else
        E_message "${stockpile%/}/${UPDATEIMAGE} does not exist"
        usaage
    fi  # updateimage existence
    # now use BOARD to validate TARGET
    validate_target ${BOARD} || usage

    # make sure there isn't already something mounted on this TARGET mountpoint
    MOUNTPOINT_BUSY=$FALSE
    LOOPDEV_BUSY=$FALSE
    message_n "checking for other active crossbuilding on TARGET mountpoint"
    findmnt_output=$(findmnt -M /usr/${TARGET} -Po SOURCE)
    if [ ! -z "${findmnt_output}" ] ; then
        right_status 1
        eval "${findmnt_output}"
        E_message "${BRon}$SOURCE${Boff} is already mounted on ${LBon}$TARGET${Boff}"
        MOUNTPOINT_BUSY=$TRUE
#        die "Please correct this before continuing"
    else
        echo -e -n " (${BGon}clear${Boff})"
        right_status $TRUE
    fi  # something else mounted for crossbuilding

    # make sure there isn't a ${BOARD}.img file already active for this board
    loop_dev=$(losetup -a -O NAME,BACK-FILE | grep "/usr/${BOARD}.img" | cut -d' ' -f1 | head -n1)
    if [ ! -z "${loop_dev}" ] ; then
        right_status 1
        E_message "${BRon}$loop_dev${Boff} is already active for ${LBon}/usr/${BOARD}.img${Boff}"
        LOOPDEV_BUSY=$TRUE
#        die "Please correct this before continuing"
    else
        echo -e -n " (${BGon}clear${Boff})"
        right_status $TRUE
    fi  # something else mounted for crossbuilding

    if [ $MOUNTPOINT_BUSY ] || [ $LOOPDEV_BUSY ] ; then
        message "running cb-umount to release busy device(s)"
        cb-umount "${BOARD}" || die "failed cb-umount ${BOARD}"
    fi

    # now check if a /usr/BOARD.img file is already in use
    message "checking for pre-existing $BOARD.img"
    cb-cleanup "${BOARD}"

    # now verify the crossdev repository for TARGET
    message_n "looking for /var/db/repos/crossdev/"
    if [ ! -d "/var/db/repos/crossdev" ] ; then
        echo -e -n " (${BRon}not found${Boff})"
        right_status 1
        die "please run ${BWon}eselect repository create crossdev /var/db/repos/crossdev${Boff}"
    else
        echo -e -n " (${BGon}found${Boff})"
        right_status $TRUE
        message_n "looking for /var/db/repos/crossdev/cross-${TARGET}"
        if [ ! -d "/var/db/repos/crossdev/cross-${TARGET}" ] ; then
            echo -e -n " (${BRon}not found${Boff})"
            right_status 1
            E_message "TARGET sub-repo will need to be re-generated (Ok to continue)"
        else
            echo -e -n " (${BGon}found${Boff})"
            right_status $TRUE
            message "TARGET sub-repo exists and will be updated (Ok to continue)"
        fi # sub-repo existence
    fi  # repo existence

    # now verify the TARGET crossdevelopment mountpoint still exists
    message_n "looking for /usr/${TARGET}"
    if [ ! -d "/usr/${TARGET}" ] ; then
        echo -e -n " (${BRon}not found${Boff})"
        right_status 1
        mkdir /usr/${TARGET} || die "failed to mkdir /usr/${TARGET}"
        echo -e -n " (${BGon}created${Boff})"
        right_status $TRUE
    else
        echo -e -n " (${BGon}found${Boff})"
        right_status $TRUE
    fi  # mountpoint existence

    # now copy the stockpile UPDATEIMAGE file to /usr/
    msg="${BYon}copy ${UPDATEIMAGE} from stockpile to /usr/ as ${BMon}${BOARD}.img${Boff}\n"
    msg+="(if you copied it manually, you can safely skip this)"
    new_prompt "${msg}"
    case ${response:0:1} in
        [yY] )
            cp "${stockpile%/}/${UPDATEIMAGE}" "/usr/${BOARD}.img" || die "failed to cp ${stockpile%/}/${UPDATEIMAGE} /usr/${BOARD}.img"
            echo -e -n " (${BGon}copied${Boff})"
            right_status $TRUE
            ;;
        [sS] ) echo -e -n " (${BMon}skipping${Boff})"
            right_status $TRUE
            ;;
        * ) die "Please correct this before continuing" ;;
    esac

    # now mount the new /usr/${BOARD}.img file on the crossdev $TARGET
    cb-mount "${BOARD}" || die "failed to cb-mount ${BOARD}"

    return 0
}

local_sanity_check() {
    separator "${PN}" "(${FUNCNAME[o]})"
    message "might not need this function if it can be combined in validate-prerequisites"
}




debug_marker() {
    bremoji "${heart_red}${VS16}" ; echo -n " "
    echo -e -n "${Ron}D${BRon}e${Yon}b${BYon}u${Gon}g${BGon}_${LBon}M${Bon}a${BBon}r${Mon}k${BMon}e${Won}r${BWon}!${Boff}"
    echo -n " " ; bremoji $explosion; echo
    exit 1
}



#-----[ main script ]---------------------------------------------
checkroot
separator ${PN} $(hostname)
# only stockpiled filename (<UPDATEIMAGE=>) -s required (w/ -u)
# option s (status) is the only one that can appear alone on the command line
# - otherwise it should be at least 2: -u <UPDATEIMAGE>
arglist="$@"
[ $# -eq 0 ] && E_message "null command line arguments" && usage
[ $# -eq 1 ] && [[ "$1" != "-"*"s"* ]] && [[ "$1" != "--status" ]] && E_message "invalid argument(s) [$arglist]" && usage
[ $# -lt 2 ] && E_message "invalid argument(s) [$arglist]" && usage
UPDATEIMAGE="$1"

# basic common approach -
# initialize variables (local function)
# validate_status_file  (script_header_joetoo_extended)
# process_cmdline (script_header_joetoo_extended)
# validate_prerequisites (not already crossbuilding; have crossdev, target mountpoint)
# validate_target which must follow process_cmdline (cb-common-functions)
# display_configuration so we can see what's what if insane (script_header_joetoo_extended)
# local_sanity_check (rather than one in cb-common-functions that won't fit)
# run_sequence (script_header_joetoo_extended)

# initialize variables and set default values
initialize_variables || die "Failed to initialize_variables"

validate_status_file ${mkupdstatusfile} || die "Failed to validate_status_file"

d_echo "cmdline: $*" 5
d_echo "processing cmdline args: $@" 5

# over-ride configuration with commandline input
separator ${PN} "(process_cmdline)"
echo "checking BPN: [$BPN]"
echo "local cmdline args: [/etc/${BPN}/local.cmdline_arguments]"
process_cmdline ${@} || usage

# validate prerequisites and derive BOARD and TARGET from UPDATEIMAGE
validate_prerequisites ${UPDATEIMAGE} || usage

display_configuration || die "Failed to display_configuration"

local_sanity_check  || die "Failed local_sanity_check"

run_sequence ${mkupdstatusfile} || die "Failed to run_sequence"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0

#debug_marker

