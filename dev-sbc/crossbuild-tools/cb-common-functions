#!/bin/bash
# crossbuild-common-functions    (c) joe.brendler  2025-2072
#
# to be sourced in programs that employ these functions
# /usr/sbin/scritp_header_joetoo must be sourced first
# /usr/sbin/scritp_header_joetoo_extended must be sourced for cli processing
#
# *** Add new boards to validate_target() and validate_source() ***
#
# (as of 7/18/25 validate_target and cb-mkenv are updated to
#  explicitly use the textual profile name to assign default profile
#  rather than numbers, since the numbers change)

BOARD=$1
VALID=$FALSE

# -----[changes 7/14/25 - for ver 0.6.14 ]--------------------------
# new_prompt() .......... moved to script_header_joetoo
# die() ................. moved to script_header_joetoo
# get_luks_keyfile() .... moved to script_header_joetoo
# get_luks_edev_name() .. moved to script_header_joetoo
# confirm_continue_or_exit . moved to script_header_joetoo_extended
# validate_status_file() ... moved to script_header_joetoo_extended
# linear_search() .......... moved to script_header_joetoo_extended
# run_sequence() ........... moved to script_header_joetoo_extended
# display_configuration .... moved to script_header_joetoo_extended
# process_cmdline .......... moved to script_header_joetoo_extended
# process_argument ......... moved to script_header_joetoo_extended
# process_compound_arg ..... moved to script_header_joetoo_extended
# usage-common-message ..... moved to /etc/${BPN}/local.usage
# (note: crossbuild-tools - specific arguments moved to --
#    local.cmdline_arguments
#    local.cmdline_compound_arguments
#    local.usage
#  to be installed at /etc/${BPN}/ by dev-sbc/crossbuild-tools ebuild)

validate_target() {
    # TARGET = crossbuild target for image generation
    [ $# -ne 1 ] && E_message "Error: must specify BOARD" && return 1
    BOARD=$1
    separator "${PN}" "(validate_target)"
    d_message "validating BOARD and target for BOARD: [ ${BOARD} ]" 3
    case $BOARD in
        "generic-amd64"         )
            TARGET=x86_64-pc-linux-gnu
            TARGET_ARCH=amd64
            QEMU_ARCH=x86_64
            STAGE3_SELECTOR="stage3-amd64-openrc-[0-9]"
            default_profile="default/linux/amd64/23.0"
            LLVM_TARGET="X86-64"
            VALID=$TRUE ;;
        "generic-armv6j"         )
            TARGET=armv6j-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv6j_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv6j_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "generic-armv7a"         )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "generic-aarch64"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2708-rpi-b"          )
            TARGET=armv6j-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv6j_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv6j_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2709-rpi-2-b"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2710-rpi-3-b"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2710-rpi-3-b-plus"   )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2711-rpi-4-b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2711-rpi-cm4-io"     )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2712-rpi-5-b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2712-rpi-cm5-cm5io"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3288-tinker-s"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-tinker-2"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-rock-pi-4c-plus" )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-rock-4se" )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588-rock-5b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588-radxa-rock-5b+"  )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-orangepi-5"     )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-orangepi-5b"    )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-rock-5c"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "fsl-imx8mq-phanbell"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-gxl-s905x-libretech-cc-v2"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-g12b-a311d-libretech-cc"          )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-sm1-s905d3-libretech-cc"          )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        *                        )
            VALID=$FALSE ;;
    esac

    if [[ $VALID ]] ; then
        d_message "BOARD ...........: ${BOARD}" 3
        d_message "TARGET ..........: ${TARGET}" 3
        d_message "TARGET_ARCH .....: ${TARGET_ARCH}" 3
        d_message "QEMU_ARCH .......: ${QEMU_ARCH}" 3
        d_message "default_profile..: ${default_profile}" 3
        d_message "LLVM_TARGET......: ${LLVM_TARGET}" 3
        d_message "${BGon}[valid target]${Boff}" 2
    else
        E_message "${BRon}[invalid target]${Boff}"
        # run the usage() function
        ## *** of whatever script sourced cb-common-functions ***
        usage
    fi
    echo
    return 0
}

validate_device() {
    # OUTPUTDEVICE = physical block device to which crossbuilt image will be copied/flashed/deployed
    [ $# -ne 1 ] && E_message "Error: must specify OUTPUTDEVICE" && return 1
    OUTPUTDEVICE=$1
    separator "${PN}" "(validate_device)"
    message_n "validating OUTPUTDEVICE: [ ${OUTPUTDEVICE} ] ..."
    if [ -b ${OUTPUTDEVICE} ] ; then
        right_status $TRUE
        message "running fdisk -l ${OUTPUTDEVICE} ..."
        fdisk -l ${OUTPUTDEVICE} | sed 's|^|    |'
    else
        right_status 1
        E_message "no such block device found for [ ${OUTPUTDEVICE} ]"
        exit 1
    fi
    # check if any part of this device is mounted - un-mount before continuing

    # (1) first unmount anything mounted to lvm in luks
    # note:  | sed 's|\\x0a| |' substitutes a space for the escaped newline
    #     control character in multiple mountpoints in lsblk -P output
    while read line; do
        # read a line from lsblk output (see below)
        if [[ ! -z $(echo $line) ]] ; then
           # use the line to assign NAME, TYPE, MOUNTPOINTS
           eval "${line}"
           d_message "${TYPE}: $NAME  MOUNTPOINTS: ${MOUNTPOINTS}" 2

           # (1.1) If this device appears to be mounted, check and if so try to unmount it
           if [[ ! -z ${MOUNTPOINTS} ]] ; then
               for x in ${MOUNTPOINTS}; do
                   # if it is in fact still mounted, unmount it
                   if [[ ! -z $(findmnt -ln ${x}) ]] ; then
                       umount -R ${x} && message "successfully ran umount -R ${x}" || \
                           die "failed to umount -R ${x}"
                   else
                       d_message "${x} is no longer mounted; continuing" 3
                   fi
               done
           else
               d_message "no MOUNTPOINTS for TYPE [$TYPE] NAME [$NAME]" 2
           fi

           # (1.2) get volume group name and fs_name for this LV (for joetoo standard lv naming)
           VG=$(echo $NAME | cut -d'-' -f1)
           fs_name=$(echo $NAME | cut -d'-' -f2)
           # (1.3) turn off swap, if it is turn on for this LV
           if [[ "${fs_name}" == "swap" ]] && \
              [[ ! -z "$(swapon --noheadings --show | grep ${NAME})" ]] ; then
               swapoff /dev/mapper/${NAME} && message "successfully ran swapoff /dev/mapper/${NAME}" || \
                   die "failed to run swapoff /dev/mapper/${NAME}"
           fi
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "lvm" | sed 's|\\x0a| |')
    # (2) next, release the volume group's LVs (ignore if no actual VG)
    if [[ ! -z $(lsblk ${OUTPUTDEVICE} | grep lvm) ]] ; then
        vgchange -an ${VG} >/dev/null && message "successfully ran vgchange -an ${VG} >/dev/null" || \
            die "failed to run vgchange -an ${VG} >/dev/null"
    else
        [ ! -z "${VG}" ] && d_message "no LVs active in VG [${VG}]" 2
    fi
    # (3) next, close any luks cyprt device
    while read line ; do
        if [[ ! -z $(echo $line) ]] ; then
            eval "${line}"
            d_message "TYPE: [${TYPE}] NAME: [$NAME]  MOUNTPOINTS: [${MOUNTPOINTS}]" 2
            cryptsetup luksClose ${NAME} && message "successfully ran cryptsetup luksClose ${NAME}" || \
                die "failed to run cryptsetup luksClose ${NAME}"
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "crypt" | sed 's|\\x0a| |')
    # (4) finally, unmount any mounted regular partitions
    while read line ; do
        if [[ ! -z $(echo $line) ]] ; then
            eval "${line}"
            if [[ ! -z ${MOUNTPOINTS} ]] ; then
                message_n "umounting MOUNTPOINTS: [${MOUNTPOINTS}] from partition [$NAME] ..."
                for x in ${MOUNTPOINTS}; do
                    umount -R ${x} && message "successfully ran umount -R ${x}" || \
                       die "failed to umount -R ${x}"
                done
            else
                d_message "no MOUNTPOINTS for TYPE: [$TYPE] NAME: [$NAME]" 2
            fi
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "part" | sed 's|\\x0a| |')

    # If we made it here without choking, then return success
    d_message "${BGon}[valid device]${Boff}" 2
    echo
    return 0
}

validate_source() {
    # "source" (in this context) means a running host system from which
    #      content will be collected, either --
    # (1) in preparation for (public) administrative addition of a new
    #      category of supported "BOARD" device(s) to those supported
    #      by this package ) via the database it generates for all
    #      build-users at /etc/crossbuild-tools/mkenv-files, or
    # (2) in preparation for (private) addition of a template for
    #      sensitive data from a build-user's machine(s) to the database
    #      of information maintained locally by the user at
    #      /etc/crossbuild-tools/mkimg-files
    BOARD=$1
    # look up what board this should be ...
#    model=$(lshw | grep -i -A5 $(hostname) | grep product | cut -d':' -f2 | sed 's/^[>
    model=$(cat /proc/device-tree/model | tr -d '\0')
    case ${model} in
        "" ) my_board="" ;;
        "Raspberry Pi Model B Rev 2" ) my_board="bcm2708-rpi-b" ;;
        "Raspberry Pi 2 Model B Rev 1.1" ) my_board="bcm2709-rpi-2-b" ;;
        "Raspberry Pi 3 Model B Rev 1.2" ) my_board="bcm2710-rpi-3-b" ;;
        "Raspberry Pi 3 Model B Plus Rev 1.3" ) my_board="bcm2710-rpi-3-b-plus" ;;
        "Raspberry Pi 4 Model B Rev 1.1" ) my_board="bcm2711-rpi-4-b" ;;
        "Raspberry Pi Compute Module 4 Rev 1.1" ) my_board="bcm2711-rpi-cm4-io" ;;
        "Raspberry Pi 5 Model B Rev 1.0" ) my_board="bcm2712-rpi-5-b" ;;
        "Raspberry Pi Compute Module 5 Rev 1.0" ) my_board="bcm2712-rpi-cm5-cm5io" ;;
        "Radxa ROCK Pi 4C+" ) my_board="rk3399-rock-pi-4c-plus" ;;
        "Radxa ROCK 4SE" ) my_board="rk3399-rock-4se" ;;
        "Radxa ROCK 5B" ) my_board="rk3588-rock-5b" ;;
        "Radxa ROCK 5B+" ) my_board="rk3588-radxa-rock-5b+" ;;
        "Orange Pi 5" ) my_board="rk3588s-orangepi-5" ;;
        "Orange Pi 5B" ) my_board="rk3588s-orangepi-5b" ;;
        "Radxa ROCK 5C" ) my_board="rk3588s-rock-5c" ;;
        "Freescale i.MX8MQ Phanbell" ) my_board="fsl-imx8mq-phanbell" ;;
        "Libre Computer AML-S905X-CC V2" ) my_board="meson-gxl-s905x-libretech-cc-v2" ;;
        "Libre Computer AML-S905D3-CC Solitude" ) my_board="meson-sm1-s905d3-libretech-cc" ;;
        "Libre Computer AML-A311D-CC Alta" ) my_board="meson-g12b-a311d-libretech-cc" ;;
    esac
    echo
    message "source reports it is [${model}], so source board is [${my_board}]"
    message "comparing my_board [${my_board}] and BOARD [${BOARD}] ..."
    if [[ "${my_board}" == "${BOARD}" ]] ; then
        message "this is a ${BGon}match${Boff}"
        return 0
    else
        E_message "this is a ${BRon}mismatch${Boff}"
        return 1
    fi
}

id_binhost_and_link_for_board() {
    d_message "in ${FUNCNAME[0]}" 5
    # identify binhost name (bh) and weblink string (link) for $1 (brd)
    local brd=$1
    case $brd in
        bcm2708-rpi-b          ) bh="raspi" ; link="armv6j-unknown-linux-gnueabihf-rpi1-packages" ;;
        bcm2709-rpi-2-b        ) bh="raspi23A" ; link="armv7a-unknown-linux-gnueabihf-rpi23A-packages" ;;
        bcm2710-rpi-3-b        ) bh="raspi23A" ; link="armv7a-unknown-linux-gnueabihf-rpi23A-packages" ;;
        bcm2710-rpi-3-b-plus   ) bh="raspi3" ; link="aarch64-unknown-linux-gnu-rpi3-packages" ;;
        bcm2711-rpi-4-b        ) bh="raspi4" ; link="aarch64-unknown-linux-gnu-rpi4-packages" ;;
        bcm2711-rpi-cm4-io     ) bh="raspi4" ; link="aarch64-unknown-linux-gnu-rpi4-packages" ;;
        bcm2712-rpi-5-b        ) bh="raspi5" ; link="aarch64-unknown-linux-gnu-rpi5-packages" ;;
        bcm2712-rpi-cm5-cm5io  ) bh="raspi5" ; link="aarch64-unknown-linux-gnu-rpi5-packages" ;;
        fsl-imx8mq-phanbell    ) bh="sweetpotato" ; link="aarch64-unknown-linux-gnu-sweetpotato-packages" ;;
        rk3288-tinker-s        ) bh="rk3288" ; link="armv7a-unknown-linux-gnueabihf-rk3288-packages" ;;
        rk3399-rock-4se        ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3399-rock-pi-4c-plus ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3399-tinker-2        ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3588-radxa-rock-5b+  ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588-rock-5b         ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-orangepi-5     ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-orangepi-5b    ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-rock-5c        ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        meson-g12b-a311d-libretech-cc   ) bh="alta" ; link="aarch64-unknown-linux-gnu-alta-packages" ;;
        meson-gxl-s905x-libretech-cc-v2 ) bh="sweetpotato" ; link="aarch64-unknown-linux-gnu-sweetpotato-packages" ;;
        meson-sm1-s905d3-libretech-cc   ) bh="solitude" ; link="aarch64-unknown-linux-gnu-solitude-packages" ;;
        * ) die "invalid board: $board" ; link="" ;;
    esac
    return 0
}

id_boards_for_binhost() {
    d_message "in ${FUNCNAME[0]}" 5
    # identify bh_candidate boards that can serve as binhost (reverse mapping of id_bh_and_link)
    local mybh=$1
    case $mybh in
        "raspi"       ) bh_boards=('bcm2708-rpi-b') ;;
        "raspi23A"    ) bh_boards=('bcm2709-rpi-2-b' 'bcm2710-rpi-3-b') ;;
        "raspi3"      ) bh_boards=('bcm2710-rpi-3-b-plus') ;;
        "raspi4"      ) bh_boards=('bcm2711-rpi-4-b' 'bcm2711-rpi-cm4-io') ;;
        "raspi5"      ) bh_boards=('bcm2712-rpi-5-b' 'bcm2712-rpi-cm5-cm5io') ;;
        "rk3288"      ) bh_boards=('rk3288-tinker-s') ;;
        "rk3399"      ) bh_boards=('rk3399-rock-4se' 'rk3399-rock-pi-4c-plus' 'rk3399-tinker-2') ;;
        "rk3588"      ) bh_boards=('rk3588-radxa-rock-5b+' 'rk3588-rock-5b' 'rk3588s-orangepi-5') ;
                        bh_boards+=('rk3588s-orangepi-5b' 'rk3588s-rock-5c') ;;
        "alta"        ) bh_boards=('meson-g12b-a311d-libretech-cc') ;;
        "solitude"    ) bh_boards=('meson-sm1-s905d3-libretech-cc') ;;
        "sweetpotato" ) bh_boards=('meson-gxl-s905x-libretech-cc-v2''fsl-imx8mq-phanbell') ;;
        * ) die "invalid binhost [$mybh] for ${FUNCNAME[0]}" ;;
    esac
    return 0
}


identify_root_device() {
    # identify the root device and assign global variables ROOT_DEVICE and ROOT_UUID
    # first, trap errors
    [ -z "${OUTPUTDEVICE}" ] && E_message "OUTPUTDEVICE not assigned" && return 1
    # identify the name and UUID of the root device (LV if LUKS, part if not)
    # lsblk doesn't know fs labels for lvm LVs, so we have to use blkid to get this
    message_n "identifying root device"
    d_message "LUKS: $(status_color $LUKS)$(TrueFalse $LUKS)${Boff}" 4
    [ $LUKS ] && rootdev_prefix="/dev/mapper/vg_${DEV_HOSTNAME}" || rootdev_prefix=${OUTPUTDEVICE}
    d_message "rootdev_prefix: $rootdev_prefix" 4

    # the root device can be labeled different ways on different devices...
    # algorithm
    #  (1) if the device is labled some version of root (e.g. root_fs, ROOT, ...) assign it
    #  (2) if there is only one partition, it is the "rootdev" regardless of its label; assign it
    #  (3) if none of multiple partitions are labeled "root" - then assign the highest as the "rootdev"
    LINE=$(blkid ${rootdev_prefix}*  | grep -i 'root')
    if [ ! -z "$LINE" ] || [ $partition_count -eq 1 ] ; then
        # case 1 or 2
        ROOT_DEVICE=$(echo $LINE | cut -d':' -f1)
        remainder=$(echo $LINE | cut -d':' -f2-) ; eval ${remainder}  #assigns LABEL, UUID, TYPE, etc
        ROOT_UUID="${UUID}"
    else
        # case 3 - assign the last partition as rootdev
#        ROOT_DEVICE=${rootdev_prefix}${p_prefix}${partition_count}  ### should be same as below
        LINE=$(blkid ${rootdev_prefix}* | tail -n1)
        ROOT_DEVICE=$(echo $LINE | cut -d':' -f1)
        remainder=$(echo $LINE | cut -d':' -f2-) ; eval ${remainder}  #assigns LABEL, UUID, TYPE, etc
        ROOT_UUID="${UUID}"
    fi
    echo -en " ( $ROOT_DEVICE | $ROOT_UUID )"
    right_status $TRUE
    d_message "ROOT_DEVICE: $ROOT_DEVICE   ROOT_UUID: $ROOT_UUID" 4
    return 0
}

install_files_from_source() {
    # SOURCE = (in this context) is a path to staged data already collected,
    #   to enable joetoo system image generation for this board
    SOURCE="$1"
    # ignore missing or empty SOURCE diretory and strip source directory name
    #   from each pathname to use relative to /usr/${TARGET}/
    for x in $(find ${SOURCE} -type f 2>/dev/null | sed "s|${SOURCE}||") ; do
        DESTINATION="/usr/${TARGET}/$(dirname ${x})"
        FILE="$(basename ${x})"
        if [ ! -d ${DESTINATION} ] ; then
            d_echo "" 3
            [ $verbosity -lt 3 ] && \
                d_message_n "${DESTINATION} (${BRon}does not exist${Boff})" 2 || \
                d_message "${DESTINATION} (${BRon}does not exist${Boff})" 2
            d_message "  TARGET......: ${TARGET}" 3
            d_message "  SOURCE......: ${SOURCE}" 3
            d_message "  x...........: ${x}" 4
            d_message "  dirname x...: $(dirname $x)" 4
            d_message "  basename x..: $(basename $x)" 4
            d_message "  DESTINATION.: ${DESTINATION}" 3
            d_message "  FILE........: ${FILE}" 3
            mkdir -p ${DESTINATION} && echo -en "(${BGon}created${Boff})" || die "failed to mkdir -p ${DESTINATION}"
            right_status $TRUE
            d_echo "" 3
        fi
        message_n "populating ${x} ..."
        cp ${SOURCE}${x} ${DESTINATION}/${FILE} && right_status $? || ( right_status $? && exit 1 )
    done
    return 0
}

TARGET-emerge-joetoo-platform-meta() {
    # use crossdev tools to emerge joetoo-platform-meta (platform-specific configs)
    # from the build-host, for the crossbuild target system
    options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    [[ $INTERACTIVE ]] && options+=" --ask"
    root="/usr/${TARGET}"
    uses="sbc ${BOARD} headless -plasma -gnome -http3 -quic -curl_quic_openssl"
    package="joetoo-base/joetoo-platform-meta"
    features="-collision-detect -protect-owned"
    ROOT="${root}" USE="${uses}" FEATURES="${features}" ${TARGET}-emerge ${package} ${options}
    echo
    message "Do not worry if some @system packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

TARGET-emerge-system() {
    # use crossdev tools to run emerge @system from the build-host, for the crossbuild target system
    options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    [[ $INTERACTIVE ]] && options+=" --ask"
    ${TARGET}-emerge @system ${options}
    echo
    message "Do not worry if some @system packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

TARGET-emerge-world() {
    # use crossdev tools to run emerge @world from the build-host, for the crossbuild target system
    options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    [[ $INTERACTIVE ]] && options+=" --ask"
    ${TARGET}-emerge @world ${options}
    echo
    message "Do not worry if some @world packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

validate-chroot-mountpoint-dirlist() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by both cb-chroot-target and cb-chroot-target-image
    # *** calling function must cd to new sysroot before calling this ***
    # check for (and if needed, create) directories needed for chroot mountpoints

    # dirlist must be set by the calling function
    dirlist="proc dev sys tmp dev/pts"
    dirlist+=" var/db/repos/gentoo var/db/repos/joetoo var/db/repos/crossdev"
    dirlist+=" chroot_sources_mountpoint lib/modules"

    d_message "looking for chroot mountpoints ..." 2
    for x in ${dirlist} ; do
        d_message_n "looking for $x" 3
        if [ ! -d $x ] ; then
            debug_do 'echo -e -n " (${BRon}not found${Boff)"' 3
            mkdir -pv $x >/dev/null 2>/dev/null || die "failed to mkdir -pv $x"
            debug_do 'echo -e -n " (${BGon}created${Boff})"' 3
        else
            debug_do 'echo -e -n " (${BGon}exists${Boff})"' 3
        fi
        d_right_status $TRUE 3
    done
    # now link the sources directory if it isn't
    d_message_n "(re)building link to kernel sources usr/src/linux" 2
    # if a directory by this name exists, remove it
    if [ -d usr/src/linux ] ; then
        rm -r usr/src/linux
        debug_do 'echo -e -n " (removed dir)"' 3
    fi
    if [ -d usr/src/chroot-sources-mountpoint ] ; then
        debug_do 'echo -e -n " (mountpoint exists)"' 3
    else
        mkdir usr/src/chroot-sources-mountpoint || die "failed to mkdir usr/src/chroot-sources-mountpoint"
        debug_do 'echo -e -n " (mountpoint created)"' 3
    fi
    ln -snf chroot-sources-mountpoint usr/src/linux || die "failed to create link for usr/src/linux for ${PN}"
    debug_do 'echo -e -n " (${BGon}created${Boff})"' 3
    d_right_status $TRUE 2

    d_message "done validating chroot mountpoint directories" 2
    return 0
}

mount-chroot-prep() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by both cb-chroot-target and cb-chroot-target-image
    # *** calling function must cd to new sysroot before calling this ***
    # mount_list must be set by calling function

    for tgt in ${mount_list}; do
        case $tgt in
            "proc" ) src="-t proc none" ;;
            "dev"  ) src="-o bind /dev" ;;
            "sys"  ) src="-o bind /sys" ;;
            "tmp"  ) src="-o bind /tmp" ;;
            "lib/modules" ) src="-o bind /lib/modules" ;; # not sure why we have to do this... seems like these (host's) modules would be wrong for target
            "dev/pts"     ) src="-o bind /dev/pts" ;;   # only for X
            "var/db/repos/joetoo"   ) src="-o bind /${tgt}" ;;
            "var/db/repos/gentoo"   ) src="-o bind /${tgt}" ;;
            "var/db/repos/crossdev" ) src="-o bind /${tgt}" ;;
        esac
        message_n "mounting $src on $tgt for ${PN} ..."
        mount $src $tgt >/dev/null 2>&1 || die "failed to mount $src on $tgt for ${PN}"
        right_status $TRUE
    done
    return 0
}

umount-chroot-prep() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by both cb-chroot-target and cb-chroot-target-image
    # *** calling function must cd to new sysroot before calling this ***
    # mount_list must be set by calling function
    for tgt in ${mount_list}; do
        message_n "un-mounting $tgt from chroot target for ${PN} ..."
        umount /usr/${TARGET}/$tgt ; result=$? ; right_status $result
        [ $result -eq 0 ] || FLAGGED=$TRUE
    done
    [ $FLAGGED ] && return 1 || return 0
}

sanity_check() {
    # sanity check configuration
    FLAGGED=$FALSE
    message "sanity-checking configuration ..."
    if [[ $DESTROY ]] && [ $starting_step -ne 0 ] ; then
        E_message "user specified DESTROY and non-zero starting_step"
        FLAGGED=$TRUE
    fi
    if [[ $CREATE ]] && [ $starting_step -ne 0 ] ; then
        E_message "user specified CREATE and non-zero starting_step"
        FLAGGED=$TRUE
    fi
    if [[ $CREATE ]] && [[ $DESTROY ]] ; then
        E_message "user specified both CREATE and DESTROY"
        FLAGGED=$TRUE
    fi

    # caution: -n tests true even when the variable is NULL
    #echo "BOARD: [${BOARD}]"
    #echo "TARGET: [${TARGET}]"
    #echo -n "-n: BOARD: " ; [ -n ${BOARD} ] && echo true || echo false
    #echo -n "-n: TARGET: " ; [ -n ${TARGET} ] && echo true || echo false
    #echo -n "-z: BOARD: " ; [ -z ${BOARD} ] && echo true || echo false
    #echo -n "-z: TARGET: " ; [ -z ${TARGET} ] && echo true || echo false
    #echo -n "len: BOARD: " ; echo ${#BOARD}
    #echo -n "len: TARGET: " ; echo ${#TARGET}
    #    if [ -n ${BOARD} ] && [ -n ${TARGET} ] ; then
    #    if [ ${#BOARD} -ne 0 ] && [ ${#TARGET} -ne 0 ] ; then

# dont need to check if both are set, since standard to run validate_target first makes that so
#    if [ ! -z ${BOARD} ] && [ ! -z ${TARGET} ] ; then
#        E_message "user specified both BOARD [${BOARD}] and TARGET [${TARGET}}"
#        message "OK: validate_target() will use BOARD and (re)assign TARGET"
#    fi

    if [ -z ${BOARD} ] && [ -z ${TARGET} ] ; then
        E_message "user specified neither BOARD nor TARGET"
        FLAGGED=$TRUE
    fi
    if [ -z ${BOARD} ] && [ -n ${TARGET} ] ; then
        E_message "user specified TARGET but no board"
        message_n "OK: auto-selecting generic board:"
        case ${TARGET} in
            "armv6j-unknown-linux-gnueabihf" ) export BOARD="generic-armv6j" ; echo -n " [${BOARD}]" ;;
            "armv7a-unknown-linux-gnueabihf" ) export BOARD="generic-armv7a" ; echo -n " [${BOARD}]" ;;
            "aarch64-unknown-linux-gnu"      ) export BOARD="generic-aarch64" ; echo -n " [${BOARD}]" ;;
            *                                ) E_message "invalid target ${TARGET}" ; FLAGGED=$TRUE ;;
        esac ; right_status $?
    fi
    if [[ "${PN}" == "cb-mkdev" ]] && [[ "${OUTPUTDEVICE}" == "" ]] ; then
        E_message "cb-mkdev requires both -b <BOARD> and -o <OUTPUTDEVICE>"
        FLAGGED=$TRUE
    fi
    message_n "overall sanity check:"
    if [[ ${FLAGGED} ]] ; then
        echo -en " ${BRon}(errors)${Boff}"
        right_status 1 ; usage
    else
        echo -en " ${BGon}(sane)${Boff}"
        right_status 0 ; return 0
    fi
}

format_warning() {
    separator "${PN}" "(format warning)"
    answer=""
    msg="   ${BRon}Warning:${BYon} this process will destroy all data on device [ ${BRon}${OUTPUTDEVICE}${BYon} ]\n${Boff}"
    # estimate message() function left side padding
    message_func_pad=4
    # adjust for non-printing chars and message() padding
    msg_width=$(( ${#msg} - $(( ${#BYon} + ${#BRon} + ${#BYon} + ${#BRon} + ${#Boff})) - $message_func_pad ))
    msg_banner="${BMon}$(repeat '*' ${msg_width})\n${Boff}"
    msg+="   ${BYon}Warning:${BRon} this process will destroy all data on device [ ${BYon}${OUTPUTDEVICE}${BRon} ]\n${Boff}"
    msg+="   ${BRon}Warning:${BYon} this process will destroy all data on device [ ${BRon}${OUTPUTDEVICE}${BYon} ]\n${Boff}"
    msg2="   ${BWon}Are you sure you want to continue?"
    echo
    prompt "${msg_banner}${msg}${BGon} * ${msg_banner}${msg2}"
    case ${answer:0:1} in
        [yY] ) message "Affirmative response from user; continuing" ;;
        [nN] ) E_message "Negative response from user; quitting"; exit 1 ;;
        * ) E_message "invalid response to format_warning"; exit 1 ;;
    esac
    return 0
}

smaller_script_common_usage_message() {
    echo
    message "  ${BYon}Exactly one <BOARD> must be specified --"
    echo -e "     ${LBon}${PN} currently supports these SBCs:${Boff}"
    while read board_model; do
        echo -e "         ${board_model}"
    done <<< $(joetoo-sbc-list | grep -v '\[')
    echo
    message "  ${BYon}Exactly one <TARGET> will be selected automatically. Examples:${Boff}"
    echo "         aarch64-unknown-linux-gnu"
    echo "         armv6j-unknown-linux-gnueabihf"
    echo "         armv7a-unknown-linux-gnueabihf"
    echo
    message "${BMon}  find additional information at ${LBon}/etc/crossbuild-tools/README${Boff}"
    echo
}
