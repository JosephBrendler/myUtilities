#!/bin/bash
# crossbuild-common-functions    (c) joe.brendler  2025-2072
#
# to be sourced in programs that employ these functions
# /usr/sbin/scritp_header_joetoo must be sourced first
# /usr/sbin/scritp_header_joetoo_extended must be sourced for cli processing
#
# *** Add new boards to validate_target() and validate_source() ***
#
# (as of 7/18/25 validate_target and cb-mkenv are updated to
#  explicitly use the textual profile name to assign default profile
#  rather than numbers, since the numbers change)

# -----[changes 7/14/25 - for ver 0.6.14 ]--------------------------
# new_prompt() .......... moved to script_header_joetoo
# die() ................. moved to script_header_joetoo
# get_luks_keyfile() .... moved to script_header_joetoo
# get_luks_edev_name() .. moved to script_header_joetoo
# confirm_continue_or_exit . moved to script_header_joetoo_extended
# validate_status_file() ... moved to script_header_joetoo_extended
# linear_search() .......... moved to script_header_joetoo_extended
# run_sequence() ........... moved to script_header_joetoo_extended
# display_configuration .... moved to script_header_joetoo_extended
# process_cmdline .......... moved to script_header_joetoo_extended
# process_argument ......... moved to script_header_joetoo_extended
# process_compound_arg ..... moved to script_header_joetoo_extended
# usage-common-message ..... moved to /etc/${BPN}/local.usage
# (note: crossbuild-tools - specific arguments moved to --
#    local.cmdline_arguments
#    local.cmdline_compound_arguments
#    local.usage
#  to be installed at /etc/${BPN}/ by dev-sbc/crossbuild-tools ebuild)

validate_target() {
    # TARGET = crossbuild target for image generation
    [ $# -ne 1 ] && E_message "Error: must specify BOARD" && return 1
    BOARD=$1
    VALID=$TRUE
    separator "${PN}" "(validate_target)"
    d_message "validating BOARD and target for BOARD: [ ${BOARD} ]" 3
    case $BOARD in
        "generic-amd64"         )
            TARGET=x86_64-pc-linux-gnu
            TARGET_ARCH=amd64
            QEMU_ARCH=x86_64
            STAGE3_SELECTOR="stage3-amd64-openrc-[0-9]"
            default_profile="default/linux/amd64/23.0"
            LLVM_TARGET="X86-64"
            VALID=$TRUE ;;
        "generic-armv6j"         )
            TARGET=armv6j-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv6j_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv6j_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "generic-armv7a"         )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "generic-aarch64"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2708-rpi-b"          )
            TARGET=armv6j-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv6j_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv6j_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2709-rpi-2-b"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2710-rpi-3-b"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="ARM"
            VALID=$TRUE ;;
        "bcm2710-rpi-3-b-plus"   )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2711-rpi-4-b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2711-rpi-cm4-io"     )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2712-rpi-5-b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "bcm2712-rpi-cm5-cm5io"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3288-tinker-s"        )
            TARGET=armv7a-unknown-linux-gnueabihf
            TARGET_ARCH=arm
            QEMU_ARCH=arm
            STAGE3_SELECTOR="stage3-armv7a_hardfp-openrc-[0-9]"
            default_profile="default/linux/arm/23.0/armv7a_hf"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-tinker-2"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-rock-pi-4c-plus" )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3399-rock-4se" )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588-rock-5b"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588-radxa-rock-5b+"  )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-orangepi-5"     )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-orangepi-5b"    )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "rk3588s-rock-5c"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "fsl-imx8mq-phanbell"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-gxl-s905x-libretech-cc-v2"        )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-g12b-a311d-libretech-cc"          )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        "meson-sm1-s905d3-libretech-cc"          )
            TARGET=aarch64-unknown-linux-gnu
            TARGET_ARCH=arm64
            QEMU_ARCH=aarch64
            STAGE3_SELECTOR="stage3-arm64-openrc-[0-9]"
            default_profile="default/linux/arm64/23.0"
            LLVM_TARGET="AArch64"
            VALID=$TRUE ;;
        *                        )
            VALID=$FALSE ;;
    esac

    if [[ $VALID ]] ; then
        d_message "BOARD ...........: ${BOARD}" 3
        d_message "TARGET ..........: ${TARGET}" 3
        d_message "TARGET_ARCH .....: ${TARGET_ARCH}" 3
        d_message "QEMU_ARCH .......: ${QEMU_ARCH}" 3
        d_message "default_profile..: ${default_profile}" 3
        d_message "LLVM_TARGET......: ${LLVM_TARGET}" 3
        d_message "${BGon}[valid target]${Boff}" 2
    else
        E_message "${BRon}[invalid target]${Boff}"
        # run the usage() function
        ## *** of whatever script sourced cb-common-functions ***
        usage
    fi
    echo
    return 0
}

validate_device() {
    # OUTPUTDEVICE = physical block device to which crossbuilt image will be copied/flashed/deployed
    [ $# -ne 1 ] && E_message "Error: must specify OUTPUTDEVICE" && return 1
    OUTPUTDEVICE=$1
    separator "${PN}" "(validate_device)"
    message_n "validating OUTPUTDEVICE: [ ${OUTPUTDEVICE} ] ..."
    if [ -b ${OUTPUTDEVICE} ] ; then
        right_status $TRUE
        message "running fdisk -l ${OUTPUTDEVICE} ..."
        fdisk -l ${OUTPUTDEVICE} | sed 's|^|    |'
    else
        right_status 1
        E_message "no such block device found for [ ${OUTPUTDEVICE} ]"
        exit 1
    fi
    # check if any part of this device is mounted - un-mount before continuing

    # (1) first unmount anything mounted to lvm in luks
    # note:  | sed 's|\\x0a| |' substitutes a space for the escaped newline
    #     control character in multiple mountpoints in lsblk -P output
    while read line; do
        # read a line from lsblk output (see below)
        if [[ ! -z $(echo $line) ]] ; then
           # use the line to assign NAME, TYPE, MOUNTPOINTS
           eval "${line}"
           d_message "${TYPE}: $NAME  MOUNTPOINTS: ${MOUNTPOINTS}" 2

           # (1.1) If this device appears to be mounted, check and if so try to unmount it
           if [[ ! -z ${MOUNTPOINTS} ]] ; then
               for x in ${MOUNTPOINTS}; do
                   # if it is in fact still mounted, unmount it
                   if [[ ! -z $(findmnt -ln ${x}) ]] ; then
                       umount -R ${x} && message "successfully ran umount -R ${x}" || \
                           die "failed to umount -R ${x}"
                   else
                       d_message "${x} is no longer mounted; continuing" 3
                   fi
               done
           else
               d_message "no MOUNTPOINTS for TYPE [$TYPE] NAME [$NAME]" 2
           fi

           # (1.2) get volume group name and fs_name for this LV (for joetoo standard lv naming)
           VG=$(echo $NAME | cut -d'-' -f1)
           fs_name=$(echo $NAME | cut -d'-' -f2)
           # (1.3) turn off swap, if it is turn on for this LV
           if [[ "${fs_name}" == "swap" ]] && \
              [[ ! -z "$(swapon --noheadings --show | grep ${NAME})" ]] ; then
               swapoff /dev/mapper/${NAME} && message "successfully ran swapoff /dev/mapper/${NAME}" || \
                   die "failed to run swapoff /dev/mapper/${NAME}"
           fi
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "lvm" | sed 's|\\x0a| |')
    # (2) next, release the volume group's LVs (ignore if no actual VG)
    if [[ ! -z $(lsblk ${OUTPUTDEVICE} | grep lvm) ]] ; then
        vgchange -an ${VG} >/dev/null && message "successfully ran vgchange -an ${VG} >/dev/null" || \
            die "failed to run vgchange -an ${VG} >/dev/null"
    else
        [ ! -z "${VG}" ] && d_message "no LVs active in VG [${VG}]" 2
    fi
    # (3) next, close any luks cyprt device
    while read line ; do
        if [[ ! -z $(echo $line) ]] ; then
            eval "${line}"
            d_message "TYPE: [${TYPE}] NAME: [$NAME]  MOUNTPOINTS: [${MOUNTPOINTS}]" 2
            cryptsetup luksClose ${NAME} && message "successfully ran cryptsetup luksClose ${NAME}" || \
                die "failed to run cryptsetup luksClose ${NAME}"
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "crypt" | sed 's|\\x0a| |')
    # (4) finally, unmount any mounted regular partitions
    while read line ; do
        if [[ ! -z $(echo $line) ]] ; then
            eval "${line}"
            if [[ ! -z ${MOUNTPOINTS} ]] ; then
                message_n "umounting MOUNTPOINTS: [${MOUNTPOINTS}] from partition [$NAME] ..."
                for x in ${MOUNTPOINTS}; do
                    umount -R ${x} && message "successfully ran umount -R ${x}" || \
                       die "failed to umount -R ${x}"
                done
            else
                d_message "no MOUNTPOINTS for TYPE: [$TYPE] NAME: [$NAME]" 2
            fi
        fi
    done <<< $(lsblk -y -b ${OUTPUTDEVICE} -o NAME,TYPE,MOUNTPOINTS -P | grep "part" | sed 's|\\x0a| |')

    # If we made it here without choking, then return success
    d_message "${BGon}[valid device]${Boff}" 2
    echo
    return 0
}

validate_source() {
    # "source" (in this context) means a running host system from which
    #      content will be collected, either --
    # (1) in preparation for (public) administrative addition of a new
    #      category of supported "BOARD" device(s) to those supported
    #      by this package ) via the database it generates for all
    #      build-users at /etc/crossbuild-tools/mkenv-files, or
    # (2) in preparation for (private) addition of a template for
    #      sensitive data from a build-user's machine(s) to the database
    #      of information maintained locally by the user at
    #      /etc/crossbuild-tools/mkimg-files
    BOARD=$1
    # look up what board this should be ...
#    model=$(lshw | grep -i -A5 $(hostname) | grep product | cut -d':' -f2 | sed 's/^[>
    model=$(cat /proc/device-tree/model | tr -d '\0')
    case ${model} in
        "" ) my_board="" ;;
        "Raspberry Pi Model B Rev 2" ) my_board="bcm2708-rpi-b" ;;
        "Raspberry Pi 2 Model B Rev 1.1" ) my_board="bcm2709-rpi-2-b" ;;
        "Raspberry Pi 3 Model B Rev 1.2" ) my_board="bcm2710-rpi-3-b" ;;
        "Raspberry Pi 3 Model B Plus Rev 1.3" ) my_board="bcm2710-rpi-3-b-plus" ;;
        "Raspberry Pi 4 Model B Rev 1.1" ) my_board="bcm2711-rpi-4-b" ;;
        "Raspberry Pi Compute Module 4 Rev 1.1" ) my_board="bcm2711-rpi-cm4-io" ;;
        "Raspberry Pi 5 Model B Rev 1.0" ) my_board="bcm2712-rpi-5-b" ;;
        "Raspberry Pi Compute Module 5 Rev 1.0" ) my_board="bcm2712-rpi-cm5-cm5io" ;;
        "Radxa ROCK Pi 4C+" ) my_board="rk3399-rock-pi-4c-plus" ;;
        "Radxa ROCK 4SE" ) my_board="rk3399-rock-4se" ;;
        "Radxa ROCK 5B" ) my_board="rk3588-rock-5b" ;;
        "Radxa ROCK 5B+" ) my_board="rk3588-radxa-rock-5b+" ;;
        "Orange Pi 5" ) my_board="rk3588s-orangepi-5" ;;
        "Orange Pi 5B" ) my_board="rk3588s-orangepi-5b" ;;
        "Radxa ROCK 5C" ) my_board="rk3588s-rock-5c" ;;
        "Freescale i.MX8MQ Phanbell" ) my_board="fsl-imx8mq-phanbell" ;;
        "Libre Computer AML-S905X-CC V2" ) my_board="meson-gxl-s905x-libretech-cc-v2" ;;
        "Libre Computer AML-S905D3-CC Solitude" ) my_board="meson-sm1-s905d3-libretech-cc" ;;
        "Libre Computer AML-A311D-CC Alta" ) my_board="meson-g12b-a311d-libretech-cc" ;;
    esac
    echo
    message "source reports it is [${model}], so source board is [${my_board}]"
    message "comparing my_board [${my_board}] and BOARD [${BOARD}] ..."
    if [[ "${my_board}" == "${BOARD}" ]] ; then
        message "this is a ${BGon}match${Boff}"
        return 0
    else
        E_message "this is a ${BRon}mismatch${Boff}"
        return 1
    fi
}

id_binhost_and_link_for_board() {
    d_message "in ${FUNCNAME[0]}" 5
    # identify binhost name (bh) and weblink string (link) for $1 (brd)
    local brd=$1
    case $brd in
        bcm2708-rpi-b          ) bh="raspi" ; link="armv6j-unknown-linux-gnueabihf-rpi1-packages" ;;
        bcm2709-rpi-2-b        ) bh="raspi23A" ; link="armv7a-unknown-linux-gnueabihf-rpi23A-packages" ;;
        bcm2710-rpi-3-b        ) bh="raspi23A" ; link="armv7a-unknown-linux-gnueabihf-rpi23A-packages" ;;
        bcm2710-rpi-3-b-plus   ) bh="raspi3" ; link="aarch64-unknown-linux-gnu-rpi3-packages" ;;
        bcm2711-rpi-4-b        ) bh="raspi4" ; link="aarch64-unknown-linux-gnu-rpi4-packages" ;;
        bcm2711-rpi-cm4-io     ) bh="raspi4" ; link="aarch64-unknown-linux-gnu-rpi4-packages" ;;
        bcm2712-rpi-5-b        ) bh="raspi5" ; link="aarch64-unknown-linux-gnu-rpi5-packages" ;;
        bcm2712-rpi-cm5-cm5io  ) bh="raspi5" ; link="aarch64-unknown-linux-gnu-rpi5-packages" ;;
        fsl-imx8mq-phanbell    ) bh="sweetpotato" ; link="aarch64-unknown-linux-gnu-sweetpotato-packages" ;;
        rk3288-tinker-s        ) bh="rk3288" ; link="armv7a-unknown-linux-gnueabihf-rk3288-packages" ;;
        rk3399-rock-4se        ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3399-rock-pi-4c-plus ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3399-tinker-2        ) bh="rk3399" ; link="aarch64-unknown-linux-gnu-rk3399-packages" ;;
        rk3588-radxa-rock-5b+  ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588-rock-5b         ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-orangepi-5     ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-orangepi-5b    ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        rk3588s-rock-5c        ) bh="rk3588" ; link="aarch64-unknown-linux-gnu-rk3588-packages" ;;
        meson-g12b-a311d-libretech-cc   ) bh="alta" ; link="aarch64-unknown-linux-gnu-alta-packages" ;;
        meson-gxl-s905x-libretech-cc-v2 ) bh="sweetpotato" ; link="aarch64-unknown-linux-gnu-sweetpotato-packages" ;;
        meson-sm1-s905d3-libretech-cc   ) bh="solitude" ; link="aarch64-unknown-linux-gnu-solitude-packages" ;;
        * ) die "invalid board: $board" ; link="" ;;
    esac
    return 0
}

id_boards_for_binhost() {
    d_message "in ${FUNCNAME[0]}" 5
    # identify bh_candidate boards that can serve as binhost (reverse mapping of id_bh_and_link)
    local mybh=$1
    case $mybh in
        "raspi"       ) bh_boards=('bcm2708-rpi-b') ;;
        "raspi23A"    ) bh_boards=('bcm2709-rpi-2-b' 'bcm2710-rpi-3-b') ;;
        "raspi3"      ) bh_boards=('bcm2710-rpi-3-b-plus') ;;
        "raspi4"      ) bh_boards=('bcm2711-rpi-4-b' 'bcm2711-rpi-cm4-io') ;;
        "raspi5"      ) bh_boards=('bcm2712-rpi-5-b' 'bcm2712-rpi-cm5-cm5io') ;;
        "rk3288"      ) bh_boards=('rk3288-tinker-s') ;;
        "rk3399"      ) bh_boards=('rk3399-rock-4se' 'rk3399-rock-pi-4c-plus' 'rk3399-tinker-2') ;;
        "rk3588"      ) bh_boards=('rk3588-radxa-rock-5b+' 'rk3588-rock-5b' 'rk3588s-orangepi-5') ;
                        bh_boards+=('rk3588s-orangepi-5b' 'rk3588s-rock-5c') ;;
        "alta"        ) bh_boards=('meson-g12b-a311d-libretech-cc') ;;
        "solitude"    ) bh_boards=('meson-sm1-s905d3-libretech-cc') ;;
        "sweetpotato" ) bh_boards=('meson-gxl-s905x-libretech-cc-v2' 'fsl-imx8mq-phanbell') ;;
        * ) die "invalid binhost [$mybh] for ${FUNCNAME[0]}" ;;
    esac
    return 0
}


identify_root_device() {
    # identify the root device and assign global variables ROOT_DEVICE and ROOT_UUID
    # first, trap errors
    [ -z "${OUTPUTDEVICE}" ] && E_message "OUTPUTDEVICE not assigned" && return 1
    # identify the name and UUID of the root device (LV if LUKS, part if not)
    # lsblk doesn't know fs labels for lvm LVs, so we have to use blkid to get this
    message_n "identifying root device"
    d_message "LUKS: $(status_color $LUKS)$(TrueFalse $LUKS)${Boff}" 4
    [ $LUKS ] && rootdev_prefix="/dev/mapper/vg_${DEV_HOSTNAME}" || rootdev_prefix=${OUTPUTDEVICE}
    d_message "rootdev_prefix: $rootdev_prefix" 4

    # the root device can be labeled different ways on different devices...
    # algorithm
    #  (1) if the device is labled some version of root (e.g. root_fs, ROOT, ...) assign it
    #  (2) if there is only one partition, it is the "rootdev" regardless of its label; assign it
    #  (3) if none of multiple partitions are labeled "root" - then assign the highest as the "rootdev"
    LINE=$(blkid ${rootdev_prefix}*  | grep -i 'root')
    if [ ! -z "$LINE" ] || [ $partition_count -eq 1 ] ; then
        # case 1 or 2
        ROOT_DEVICE=$(echo $LINE | cut -d':' -f1)
        remainder=$(echo $LINE | cut -d':' -f2-) ; eval ${remainder}  #assigns LABEL, UUID, TYPE, etc
        ROOT_UUID="${UUID}"
    else
        # case 3 - assign the last partition as rootdev
#        ROOT_DEVICE=${rootdev_prefix}${p_prefix}${partition_count}  ### should be same as below
        LINE=$(blkid ${rootdev_prefix}* | tail -n1)
        ROOT_DEVICE=$(echo $LINE | cut -d':' -f1)
        remainder=$(echo $LINE | cut -d':' -f2-) ; eval ${remainder}  #assigns LABEL, UUID, TYPE, etc
        ROOT_UUID="${UUID}"
    fi
    echo -en " ( $ROOT_DEVICE | $ROOT_UUID )"
    right_status $TRUE
    d_message "ROOT_DEVICE: $ROOT_DEVICE   ROOT_UUID: $ROOT_UUID" 4
    return 0
}

install_files_from_source() {
    # SOURCE = (in this context) is a path to staged data already collected,
    #   to enable joetoo system image generation for this board
    SOURCE="$1"
    # ignore missing or empty SOURCE diretory and strip source directory name
    #   from each pathname to use relative to /usr/${TARGET}/
    for x in $(find ${SOURCE} -type f 2>/dev/null | sed "s|${SOURCE}||") ; do
        DESTINATION="/usr/${TARGET}/$(dirname ${x})"
        FILE="$(basename ${x})"
        if [ ! -d ${DESTINATION} ] ; then
            d_echo "" 3
            [ $verbosity -lt 3 ] && \
                d_message_n "${DESTINATION} (${BRon}does not exist${Boff})" 2 || \
                d_message "${DESTINATION} (${BRon}does not exist${Boff})" 2
            d_message "  TARGET......: ${TARGET}" 3
            d_message "  SOURCE......: ${SOURCE}" 3
            d_message "  x...........: ${x}" 4
            d_message "  dirname x...: $(dirname $x)" 4
            d_message "  basename x..: $(basename $x)" 4
            d_message "  DESTINATION.: ${DESTINATION}" 3
            d_message "  FILE........: ${FILE}" 3
            mkdir -p ${DESTINATION} && echo -en "(${BGon}created${Boff})" || die "failed to mkdir -p ${DESTINATION}"
            right_status $TRUE
            d_echo "" 3
        fi
        message_n "populating ${x} ..."
        cp ${SOURCE}${x} ${DESTINATION}/${FILE} && right_status $? || ( right_status $? && exit 1 )
    done
    return 0
}

TARGET-emerge-joetoo-platform-meta() {
    # use crossdev tools to emerge joetoo-platform-meta (platform-specific configs)
    # from the build-host, for the crossbuild target system
    # explicitly set options and features
    # (use option -g/--getbinpkg vs feature b/c it triggers refresh of remote metadata where latter does not)
    # (use feature buildpkg vs option -b b/c it builds binaries for dependencies where latter does not)
    # (ignore collision for this package in this instance, since package.env may not exist yet)
    local options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    local features="${FEATURES} distcc sandbox parallel-fetch -pid-sandbox buildpkg binpkg-multi-instance"
    features="${features} -collision-detect -protect-owned"
    # explicitly set root and uses just for this package, which is foundational
    local root="/usr/${TARGET}"
    local uses="sbc ${BOARD} headless -plasma -gnome -lxde -http3 -quic -curl_quic_openssl"
    local package="joetoo-base/joetoo-platform-meta"
    [[ $INTERACTIVE ]] && options+=" --ask"
    ROOT="${root}" USE="${uses}" FEATURES="${features}" ${TARGET}-emerge ${package} ${options}
    echo
    message "Do not worry if some @system packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

TARGET-emerge-system() {
    # use crossdev tools to run emerge @system from the build-host, for the crossbuild target system
    # explicitly set options and features
    # (use option -g/--getbinpkg vs feature b/c it triggers refresh of remote metadata where latter does not)
    # (use feature buildpkg vs option -b b/c it builds binaries for dependencies where latter does not)
    local options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    local features="${FEATURES} distcc sandbox parallel-fetch -collision-detect -pid-sandbox buildpkg binpkg-multi-instance"
    [[ $INTERACTIVE ]] && options+=" --ask"
    FEATURES="${features}" ${TARGET}-emerge @system ${options}
    echo
    message "Do not worry if some @system packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

TARGET-emerge-perl-fix() {
    # use crossdev tools to run emerge @perl-fix from the build-host, for the crossbuild target system
    # build the list of dependent perl module packages (that would fail to cross-build without this wrapper)
#    local perl_fix_list=$(${TARGET}-emerge -p --columns --quiet @world 2>/dev/null | grep "dev-perl/" | awk '{print $2}')
    # use awk to id packages (column 2) that are a regex match (~) for ^dev-perl\/ (category = dev-perl)
    local perl_fix_list=$(${TARGET}-emerge -p --columns --quiet @world 2>/dev/null | awk '$2 ~ /^dev-perl\// {print $2}' | sort -u)
    # If no perl modules are found, exit gracefully
    if [[ -z "${perl_fix_list}" ]]; then
        message "No Perl modules found in @world. Skipping TARGET-emerge-perl-fix"
        return 0
    fi
    # Otherwise, use this wrapper to compile these packages
    local wrapper="/usr/sbin/cb-perl-wrapper"
    local target_conf_dir="/usr/${TARGET}/etc/portage"
    local env_perl_wrapper_conf="${target_conf_dir}/env/perl-wrapper.conf"
    local target_package_env_file="${target_conf_dir}/package.env/package.env"

    # Setup temporary cross-build scaffolding (on target)
    message "setting up temporary per-package crossbuild config for perl ..."
    message_n "creating ${target_conf_dir}/env"
    mkdir -p "${target_conf_dir}/env" || die "failed to mkdir -p ${target_conf_dir}/env"
    right_status $TRUE
    message_n "generating temporary perl-wrapper.conf"
    echo 'CC="/usr/sbin/cb-perl-wrapper"' > "${env_perl_wrapper_conf}" || die "failed to write line 1 to perl-wrapper.conf"
    echo -e -n " (${Mon}1${Boff})"
    echo 'CPP="/usr/sbin/cb-perl-wrapper"' >> "${env_perl_wrapper_conf}" || die "failed to write line 2 to perl-wrapper.conf"
    echo -e -n "(${Yon}2${Boff})"
    echo 'CXX="/usr/sbin/cb-perl-wrapper"' >> "${env_perl_wrapper_conf}" || die "failed to write line 3 to perl-wrapper.conf"
    echo -e -n "(${Gon}3${Boff})"
    right_status $TRUE
    message_n "appending dev-perl/* perl-wrapper.conf to target package.env"
    echo "dev-perl/* perl-wrapper.conf" >> "${target_package_env_file}" || die "failed to append dev-perl/* perl-wrapper.conf to target package.env"
    right_status $TRUE


    # explicitly set options and features
    # (use option -g/--getbinpkg vs feature b/c it triggers refresh of remote metadata where latter does not)
    # (use feature buildpkg vs option -b b/c it builds binaries for dependencies where latter does not)
    local options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    local features="${FEATURES} distcc sandbox parallel-fetch -collision-detect -pid-sandbox buildpkg binpkg-multi-instance"
    [[ $INTERACTIVE ]] && options+=" --ask"
    FEATURES="${features}" ${TARGET}-emerge ${perl_fix_list} ${options}

    # Remove the temporary cross-build scaffolding (would be incorrect for chroot or normal ops)
    #   remove the wrapper conf file that set CC= etc.
    message_n "removing temporary perl-wrapper.conf"
    rm -f "${env_perl_wrapper_conf}" || die "failed to rm -f ${env_perl_wrapper_conf}"
    right_status $TRUE
    # Remove ONLY the specific line we added to package.env
    message_n "removing just dev-perl/* perl-wrapper.conf from target package.env"
    sed -i '/dev-perl\/\* perl-wrapper.conf/d' "${target_package_env_file}" || \
        die "failed to remove dev-perl/* perl-wrapper.conf from target package.env"
    right_status $TRUE

    echo
    message "Do not worry if some @system packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

TARGET-emerge-world() {
    # use crossdev tools to run emerge @world from the build-host, for the crossbuild target system
    # explicitly set options and features
    # (use option -g/--getbinpkg vs feature b/c it triggers refresh of remote metadata where latter does not)
    # (use feature buildpkg vs option -b b/c it builds binaries for dependencies where latter does not)
    local options="--update --newuse --deep --verbose --keep-going --getbinpkg"
    local features="${FEATURES} distcc sandbox parallel-fetch -collision-detect -pid-sandbox buildpkg binpkg-multi-instance"
    [[ $INTERACTIVE ]] && options+=" --ask"
    FEATURES="${features}" ${TARGET}-emerge @world ${options}
    echo
    message "Do not worry if some @world packages fail to build (e.g. gcc, above)"
    message "Some must be compiled natively after chroot, in steps to follow"
    echo
    return 0
}

validate-chroot-mountpoint-dirlist() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by cb-chroot-env, cb-chroot-img, and cb-chroot-upd
    # *** calling function must cd to new sysroot before calling this ***
    # check for (and if needed, create) directories needed for chroot mountpoints

    # dirlist must be set by the calling function
    dirlist="proc dev sys tmp dev/pts"
    dirlist+=" var/db/repos/gentoo var/db/repos/joetoo var/db/repos/crossdev"
    dirlist+=" chroot_sources_mountpoint lib/modules"

    d_message "looking for chroot mountpoints ..." 2
    for x in ${dirlist} ; do
        d_message_n "looking for $x" 3
        if [ ! -d $x ] ; then
            d_do 'echo -e -n " (${BRon}not found${Boff)"' 3
            mkdir -pv $x >/dev/null 2>/dev/null || die "failed to mkdir -pv $x"
            d_do 'echo -e -n " (${BGon}created${Boff})"' 3
        else
            d_do 'echo -e -n " (${BGon}exists${Boff})"' 3
        fi
        d_right_status $TRUE 3
    done
    # now link the kernel sources directory if it isn't
    d_message_n "(re)building link to kernel sources usr/src/linux" 2
    # if a directory by this name (that is NOT a symlink) exists, remove it
    if [ -d usr/src/linux ] && [ ! -L usr/src/linux ]; then
        rm -r usr/src/linux
        d_do 'echo -e -n " (removed dir)"' 3
    fi
    # check the mountpoint; create if it doesn't exist
    if [ -d usr/src/chroot-sources-mountpoint ] ; then
        d_do 'echo -e -n " (mountpoint exists)"' 3
    else
        mkdir usr/src/chroot-sources-mountpoint || die "failed to mkdir usr/src/chroot-sources-mountpoint"
        d_do 'echo -e -n " (mountpoint created)"' 3
    fi
    # create kernel sources symlink
    ln -snf chroot-sources-mountpoint usr/src/linux || die "failed to create link for usr/src/linux for ${PN}"
    d_do 'echo -e -n " (${BGon}created${Boff})"' 3
    d_right_status $TRUE 2

    d_message "done validating chroot mountpoint directories" 2
    return 0
}

mount-chroot-prep() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by cb-chroot-env, cb-chroot-img, and cb-chroot-upd
    # *** calling function must cd to new sysroot before calling this ***
    # mount_list must be set by calling function
#
# ToDo: replicate chroot-prep commands in joetoo systems' / directory
#   using mix of bind, rbind, types, --make-slave, and options
#   do this in cb-common-functions' mount-chroot-prep()/unmount-chroot-prep()

    for tgt in ${mount_list}; do
        case $tgt in
            "proc" ) src="-t proc none" ;;
            "dev"  ) src="-o bind /dev" ;;
            "sys"  ) src="-o bind /sys" ;;
            "tmp"  ) src="-o bind /tmp" ;;
            "lib/modules" ) src="-o bind /lib/modules" ;; # not sure why we have to do this... seems like these (host's) modules would be wrong for target
            "dev/pts"     ) src="-o bind /dev/pts" ;;   # only for X
            "var/db/repos/joetoo"   ) src="-o bind /${tgt}" ;;
            "var/db/repos/gentoo"   ) src="-o bind /${tgt}" ;;
            "var/db/repos/crossdev" ) src="-o bind /${tgt}" ;;
        esac
        message_n "mounting $src on $tgt for ${PN} ..."
        mount $src $tgt >/dev/null 2>&1 || die "failed to mount $src on $tgt for ${PN}"
        right_status $TRUE
    done
    return 0
}

umount-chroot-prep() {
    d_message "now in ${FUNCNAME[0]}" 3
    # used by cb-chroot-env, cb-chroot-img, and cb-chroot-upd
    # *** calling function must cd to new sysroot before calling this ***
    # mount_list must be set by calling function
    for tgt in ${mount_list}; do
        message_n "un-mounting $tgt from chroot target for ${PN} ..."
        umount /usr/${TARGET}/$tgt ; result=$? ; right_status $result
        [ $result -eq 0 ] || FLAGGED=$TRUE
    done
    [ $FLAGGED ] && return 1 || return 0
}

sanity_check() {
    # sanity check configuration
    FLAGGED=$FALSE
    message "sanity-checking configuration ..."
    if [[ $DESTROY ]] && [ $starting_step -ne 0 ] ; then
        E_message "user specified DESTROY and non-zero starting_step"
        FLAGGED=$TRUE
    fi
    if [[ $CREATE ]] && [ $starting_step -ne 0 ] ; then
        E_message "user specified CREATE and non-zero starting_step"
        FLAGGED=$TRUE
    fi
    if [[ $CREATE ]] && [[ $DESTROY ]] ; then
        E_message "user specified both CREATE and DESTROY"
        FLAGGED=$TRUE
    fi

    # caution: -n tests true even when the variable is NULL
    #echo "BOARD: [${BOARD}]"
    #echo "TARGET: [${TARGET}]"
    #echo -n "-n: BOARD: " ; [ -n ${BOARD} ] && echo true || echo false
    #echo -n "-n: TARGET: " ; [ -n ${TARGET} ] && echo true || echo false
    #echo -n "-z: BOARD: " ; [ -z ${BOARD} ] && echo true || echo false
    #echo -n "-z: TARGET: " ; [ -z ${TARGET} ] && echo true || echo false
    #echo -n "len: BOARD: " ; echo ${#BOARD}
    #echo -n "len: TARGET: " ; echo ${#TARGET}
    #    if [ -n ${BOARD} ] && [ -n ${TARGET} ] ; then
    #    if [ ${#BOARD} -ne 0 ] && [ ${#TARGET} -ne 0 ] ; then

# dont need to check if both are set, since standard to run validate_target first makes that so
#    if [ ! -z ${BOARD} ] && [ ! -z ${TARGET} ] ; then
#        E_message "user specified both BOARD [${BOARD}] and TARGET [${TARGET}}"
#        message "OK: validate_target() will use BOARD and (re)assign TARGET"
#    fi

    if [ -z ${BOARD} ] && [ -z ${TARGET} ] ; then
        E_message "user specified neither BOARD nor TARGET"
        FLAGGED=$TRUE
    fi
    if [ -z ${BOARD} ] && [ -n ${TARGET} ] ; then
        E_message "user specified TARGET but no board"
        message_n "OK: auto-selecting generic board:"
        case ${TARGET} in
            "armv6j-unknown-linux-gnueabihf" ) export BOARD="generic-armv6j" ; echo -n " [${BOARD}]" ;;
            "armv7a-unknown-linux-gnueabihf" ) export BOARD="generic-armv7a" ; echo -n " [${BOARD}]" ;;
            "aarch64-unknown-linux-gnu"      ) export BOARD="generic-aarch64" ; echo -n " [${BOARD}]" ;;
            *                                ) E_message "invalid target ${TARGET}" ; FLAGGED=$TRUE ;;
        esac ; right_status $?
    fi
    if [[ "${PN}" == "cb-mkdev" ]] && [[ "${OUTPUTDEVICE}" == "" ]] ; then
        E_message "cb-mkdev requires both -b <BOARD> and -o <OUTPUTDEVICE>"
        FLAGGED=$TRUE
    fi
    message_n "overall sanity check:"
    if [[ ${FLAGGED} ]] ; then
        echo -en " ${BRon}(errors)${Boff}"
        right_status 1 ; usage
    else
        echo -en " ${BGon}(sane)${Boff}"
        right_status 0 ; return 0
    fi
}

format_warning() {
    separator "${PN}" "(format warning)"
    answer=""
    msg1="${BMon}*   ${BRon}Warning:${BYon} this process will destroy all data on device [ ${BRon}${OUTPUTDEVICE}${BYon} ]${Boff}   ${BMon}*${Boff}"
    msg2="${BMon}*   ${BYon}Warning:${BRon} this process will destroy all data on device [ ${BYon}${OUTPUTDEVICE}${BRon} ]${Boff}   ${BMon}*${Boff}"
    # estimate message() function left side padding
    message_func_pad=4
    # adjust for non-printing chars and message() padding
    #msg_width=$(( ${#msg} - $(( ${#BYon} + ${#BRon} + ${#BYon} + ${#BRon} + ${#Boff})) - $message_func_pad ))
    msg_width=$(_get_msg_len "$msg1")
    msg_banner="${BMon}$(repeat '*' ${msg_width})${Boff}"
    msg3="   ${BWon}Are you sure you want to continue?"
    echo
    printf '  %s\n' "$msg_banner"
    printf '  %s\n' "$msg1"
    printf '  %s\n' "$msg2"
    printf '  %s\n' "$msg1"
    printf '  %s\n' "$msg_banner"
    #prompt "${msg_banner}${msg}${BGon} * ${msg_banner}${msg2}"
    prompt "$msg3"
    case ${answer:0:1} in
        [yY] ) message "Affirmative response from user; continuing" ;;
        [nN] ) E_message "Negative response from user; quitting"; exit 1 ;;
        * ) E_message "invalid response to format_warning"; exit 1 ;;
    esac
    return 0
}

smaller_script_common_usage_message() {
    echo
    message "  ${BYon}Exactly one <BOARD> must be specified --"
    echo -e "     ${LBon}${PN} currently supports these SBCs:${Boff}"
    while read board_model; do
        echo -e "         ${board_model}"
    done <<< $(joetoo-sbc-list | grep -v '\[')
    echo
    message "  ${BYon}Exactly one <TARGET> will be selected automatically. Examples:${Boff}"
    echo "         aarch64-unknown-linux-gnu"
    echo "         armv6j-unknown-linux-gnueabihf"
    echo "         armv7a-unknown-linux-gnueabihf"
    echo
    message "${BMon}  find additional information at ${LBon}/etc/crossbuild-tools/README${Boff}"
    echo
}

buildtarget-qemu() {
    # this used to be a separate script cb-buildtarget-qemu
    old_dir="$(pwd)"
    cd /usr/${TARGET}
    message "now working in crossbuild target directory: [${Mon}$(pwd)${Boff}]"

    [[ $INTERACTIVE ]] && emerge_options="-av1" || emerge_options="-v1"

    message "building qemu for ${TARGET} ..."
    FEATURES="-getbinpkg" QEMU_USER_TARGETS="${QEMU_ARCH}" QEMU_SOFTMMU_TARGETS="${QEMU_ARCH}" \
        USE="static-user -plugins static-libs" emerge ${emerge_options} --buildpkg qemu || \
            die "failed to build qemu for ${TARGET}"
    right_status $TRUE

    message_n "installing qemu binary in ${TARGET} ..."
    # 20251218 - swithced from procedure of Gentoo's "crossbuild environment" to "Embedded" wiki
    cp "/usr/bin/qemu-${QEMU_ARCH}" "/usr/${TARGET}/usr/bin/" || die "failed to install qemu binary in ${TARGET}"
    right_status $TRUE

    # cross-rust setup has been relocated to prepare-cross-rust() function used by cb-mkenv/img/upd

    echo
    cd $old_dir
    message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
    return 0
}

copy-to-stockpile(){
    source_file="$1"   # full path to source file
    dest_file="$2"     # full path to destination file (in STOCKPILE)
    # copy ${source_file} to ${STOCKPILE}/${dest_file}
    # create STOCKPILE directory if it doesn't exist
    # assumes STOCKPILE to be assigned in the environment

    # check for existence of STOCKPILE directory (create if needed)
    message_n "examining STOCKPILE"
    if [ ! -d ${STOCKPILE} ] ; then
        echo -en " (${BRon}not found${Boff})"
        mkdir -p ${STOCKPILE} && \
            echo -en " (${BGon}created${Boff})" || die "failed to create STOCKPILE"
    else
        echo -en " (${BGon}found${Boff})"
    fi
    right_status $TRUE

    # Check for existing file and handle immutability
    message_n "looking for backing file"
    if [ -f "${dest_file}" ] ; then
        # If it's already there, we must UNSET immutable flag to allow backup/overwrite
        echo -e -n " (${BMon}found${Boff})"
        chattr -i "${dest_file}" 2>/dev/null || die "failed to unset immutability"
        echo -e -n " (${BGon}unset immutable attribute${Boff})"
        right_status $TRUE

        response=""
        msg="${BYon}${dest_file} already exists. ${BRon}Create backup?\n${Boff}"
        msg+="${BWon}(y|Y: backup; n|N: abort; s|S: skip/overwrite)${Boff}"
        new_prompt "${msg}"
        case ${response:0:1} in
            [yY] )
                message_n "backing up image file"
                cp "${dest_file}" "${dest_file}.bak" || die "failed to create backup"
                echo -e -n " (${BGon}backed-up${Boff})"
                right_status $TRUE
                ;;
            [sS] ) message_n "will overwrite image file"
                right_status $TRUE
                ;;
            * ) die "aborting as instructed [$response]" ;;
        esac
    else
        echo -e -n " (${BGon}not found${Boff})"
        right_status $TRUE
    fi
    # copy /usr/${BOARD}.img to ${STOCKPILE}/${UPDATEIMAGE}
    message_n "stockpiling ${source_file} as $(basename ${dest_file})"
    cp "${source_file}" "${dest_file}" >/dev/null 2>&1 || die "failed to cp ${source_file} ${dest_file}"
    echo -en " (${BGon}copied${Boff})"
    right_status $TRUE

    # make the stockpiled image file immutable
    message_n "protecting production image (chattr +i)"
    chattr +i "${dest_file}" || die "failed to set immutable flag"
    echo -e -n " (${BGon}immutable${Boff})"
    right_status $TRUE

    return 0

}

emerge-host-world() {
    options="--update --verbose --deep --newuse --getbinpkg --usepkg --keep-going"
    [ $INTERACTIVE ] && options+=" --ask"
    emerge @world ${options} ; result=$?
    return $result
}

remove-default-draft-make-conf() {
    # remove draft (chroot version of) make.conf so we can use the crossbuild version
    local target_dir="/usr/armv7a-unknown-linux-gnueabihf/etc/portage/"
    local pattern='._cfg*make.conf'

    message_n "maybe removing draft ${pattern}"
    if [ ! -z "$(find "${target_dir}" -type f -name "${pattern}" 2>/dev/null)" ] ; then
        echo -e -n " (${BRon}found${Boff})"
        find "${target_dir}" -type f -name "${pattern}" -delete || \
            die "failed to delete ${pattern}"
        echo -e -n " (${BGon}removed${Boff})"
    else
        echo -e -n " (${BGon}not found${Boff})"
    fi
    right_status $TRUE
    return 0
}

configure-make-conf-for-crossbuilding() {
    # remove any pending version of make.conf and accept delivery of chroot and crossbuild versions
    remove-default-draft-make-conf
    # change to the chroot version of make.conf installed by joetoo-platform-meta
    message_n "configuring make.conf for crossbuilding ..."
    newfile="/usr/${TARGET}/etc/portage/make.conf.crossbuild"
    oldfile="/usr/${TARGET}/etc/portage/make.conf"
    cp "${newfile}" "${oldfile}" || die "failed to cp ${newfile} ${oldfile}"
    right_status $TRUE
    # call validate-llvm-targets() to check the new make.conf
    message "calling validate-llvm-targets"
    local sbc_native_llvm_targets="${LLVM_TARGET} BFP WebAssembly SPIRV"
    validate-llvm-targets "/usr/${TARGET}/etc/portage/make.conf" "${sbc_native_llvm_targets}" || \
        die "failed to validate-llvm-targets in TARGET make.conf"
    return 0
}

configure-make-conf-for-chroot() {
    # remove any pending version of make.conf and accept delivery of chroot and crossbuild versions
    remove-default-draft-make-conf
    # change to the chroot version of make.conf installed by joetoo-platform-meta
    newfile="/usr/${TARGET}/etc/portage/make.conf.chroot"
    oldfile="/usr/${TARGET}/etc/portage/make.conf"
    message_n "configuring make.conf for chroot ..."
    cp "${newfile}" "${oldfile}" || die "failed to cp ${newfile} ${oldfile}"
    right_status $TRUE
    # call validate-llvm-targets() to check the new make.conf
    message "calling validate-llvm-targets"
    local sbc_native_llvm_targets="${LLVM_TARGET} BFP WebAssembly SPIRV"
    validate-llvm-targets "/usr/${TARGET}/etc/portage/make.conf" "${sbc_native_llvm_targets}" || \
        die "failed to validate-llvm-targets in TARGET make.conf"
    return 0
}

DEPRECATED_emerge-cross-rust-std() {
    # build cross-${TARGET}/rust-std
    options="--verbose --getbinpkg --usepkg"
    [ $INTERACTIVE ] && options+=" --ask"
    emerge cross-${TARGET}/rust-std ${options} ; result=$?
    return $result
}

rebuild-rust-and-llvm() {
    # rebuild @world to update rust and llvm with the new configuration, if it changed
    if [ $RUST_LLVM_CHANGE_FLAG ] ; then
        # configuration changed - rebuild
        message "${BYon}rust/llvm configuration ${BMon}changed -- rebuilding${Boff}"
        options="--update --verbose --deep --newuse --getbinpkg --usepkg"
        [ $INTERACTIVE ] && options+=" --ask"
        emerge @world ${options} ; result=$?
    else
        # configuration unchanged - just continue
        message "${BYon}rust/llvm configuration ${BGon}unchanged -- continuing${Boff}"
        right_status $TRUE
        result=0
    fi
    return $result
}

run-dispatch-conf() {
    # run dispatch-conf to activate newly installed configs
    ROOT="/usr/${TARGET}/" dispatch-conf
    return $?
}

edit-make-conf() {
    # use system editor to edit config file
    ${EDITOR} /usr/${TARGET}/etc/portage/make.conf
    return $?
}

edit-package-use-platform() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.use/ -iname "*joetoo_${BOARD}")
    ${EDITOR} ${configfile}
    return $?
}

edit-package-use-common() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.use/ -iname "*joetoo_common")
    ${EDITOR} ${configfile}
    return $?
}

edit-package-accept-keywords() {
    # use system editor to edit config file (it's numbered, so use find to id it)
    configfile=$(find /usr/${TARGET}/etc/portage/package.accept_keywords/ -iname "*joetoo")
    ${EDITOR} ${configfile}
    return $?
}

create-new-cross-compiler() {
    local target_dir=""
    message "creating new crossdev cross compiler. Done after stage3 extraction"
    message "because crossdev may produce split-usr layout, and I prefer the"
    message "merged-usr layout that modern stage3 provides ..."
    echo
    FLAGGED=$FALSE
    for x in profiles metadata; do
        target_dir="/var/db/repos/crossdev/${x}"
        message_n "validating ${target_dir} ..."
        if [ ! -d ${target_dir} ] ; then
            echo -en " (${BYon}creating${Boff})"
            mkdir -p ${target_dir} && right_status $? || ( right_status $? && FLAGGED=$TRUE )
        else
            echo -en " (${BGon}valid${Boff})"
            right_status $TRUE
        fi
    done

    # validate or populate /var/db/repos/crossdev/metadata/layout.conf
    message_n "validating /var/db/repos/crossdev/metadata/layout.conf ..."
    if [ ! -f /var/db/repos/crossdev/metadata/layout.conf ] || \
       [ -z "$(grep 'masters = gentoo' /var/db/repos/crossdev/metadata/layout.conf 2>/dev/null)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'masters = gentoo' > /var/db/repos/crossdev/metadata/layout.conf && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # validate or populate /var/db/repos/crossdev/profiles/repo_name
    message_n "validating /var/db/repos/crossdev/profiles/repo_name ..."
    if [ ! -f /var/db/repos/crossdev/profiles/repo_name ] || \
       [ -z "$(grep 'crossdev' /var/db/repos/crossdev/profiles/repo_name)" ] ; then
        echo -en " ${BYon}(populating)${Boff} ..."
        echo 'crossdev' > /var/db/repos/crossdev/profiles/repo_name && \
        right_status $? || ( right_status $? && FLAGGED=$TRUE )
    else
        echo -en " (${BGon}valid${Boff})"
        right_status $TRUE
    fi

    # set permissions
    message_n "setting permission for portage on /var/db/repos/crossdev ..."
    chown -R portage:portage /var/db/repos/crossdev && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )

    # now actually build the new cross-compiler
    message "building new cross-compiler ..."
    crossdev -S -t ${TARGET} && \
    right_status $? || ( right_status $? && FLAGGED=$TRUE )
    if [[ $FLAGGED ]] ; then
        E_message "failed clean exit; note red flags above" ; return 1
    else
        message "cross-compiler creation complete" ; return 0
    fi
}

prepare-cross-rust() {
    # Some packages depend on a rust cross toolchain, so --
    # update configs to use rust-bin as cross-compiler and
    #  set RUST_LLVM_CHANGE_FLAG=$TRUE in order to make rebuild-rust-and-llvm()
    #  update rust-bin [which is a dependency of crossbuild-tools], if needed)
    # (rebuild-rust-and-llvm() is the next step in cb-mkenv command sequence
    #  and in cb-mkupd's validate-prerequisites()

    # change this if we modify the configuration and need to rebuild rust-bin, llvm etc.
    export RUST_LLVM_CHANGE_FLAG=$FALSE

    # three (not five) things required to prepare cross-rust
    # (1) rust-src USE flag on rust and rust-bin in CHOST's package.use
    # (2) RUST_CROSS_TARGETS=() array set-up in /etc/portage/env/dev-lang/rust
    # (3) LLVM_TARGETS use-expand set-up in CHOST's make.conf
    # DEPRECATED (4) symlink for cross-${TARGET}/rust-std set up cross-rust in CHOSTs crossdev repo(s)
    # DEPRECATED (5) unmask cross-${TARGET}/rust-std in CHOSTs package.accept_keywords
    # 4 & 5 are residue of legacy gentoo crossbuild-environment wiki procedure

    # (1) rust-src USE flag on rust and rust-bin in CHOST's package.use
    # verify USE flag "dev-lang/rust rust-src"
    local host_package_use="/etc/portage/package.use/99rust"
    local target_dir=$(dirname "${host_package_use}")

    # verify the package.use directory exists; create if not
    message_n "looking for directory: $(dirname "${host_package_use}")"
    if [ -d "${target_dir}" ]; then
        echo -e -n " (${BGon}found${Boff})"
    else
        echo -e -n " (${BRon}not found${Boff})"
        mkdir -p "${target_dir}" || die "failed to  mkdir -p ${target_dir}"
        echo -e -n " (${BGon}created${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE
    # verify the package.use file exists; create if not
    message_n "looking for file: ${host_package_use}"
    if [ -f "${host_package_use}" ]; then
        echo -e -n " (${BGon}found${Boff})"
    else
        echo -e -n " (${BRon}not found${Boff})"
        touch "${host_package_use}" || die "failed to touch ${host_package_use}"
        echo -e -n " (${BGon}created${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE
    # verify that USE flag "dev-lang/rust rust-src" is in CHOST's package.use
    message_n "looking for \"dev-lang/rust rust-src\" in ${host_package_use}"
    if grep -qF -- "dev-lang/rust rust-src" "${host_package_use}" ; then
        echo -e -n " (${BGon}found${Boff})"
    else
        echo -e -n " (${BRon}not found${Boff})"
        echo -e "\ndev-lang/rust rust-src" >> "${host_package_use}" || \
            die "failed to append rust-src use flag"
        echo -e -n " (${BGon}appended${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE
    # verify USE flag "dev-lang/rust-bin rust-src"
    # (this should be unnecessary b/c I changed crossbuild-tools ebuild to depend
    #  on dev-lang/rust rather than rust-bin, but lets keep it for compatibility)
    message_n "looking for \"dev-lang/rust-bin rust-src\" in ${host_package_use}"
    if grep -qF -- "dev-lang/rust-bin rust-src" "${host_package_use}" ; then
        echo -e -n " (${BGon}found${Boff})"
    else
        echo -e -n " (${BRon}not found${Boff})"
        echo -e "\ndev-lang/rust-bin rust-src" >> "${host_package_use}" || \
            die "failed to append rust-src use flag"
        echo -e -n " (${BGon}appended${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE

    # (2) RUST_CROSS_TARGETS=() array set-up in /etc/portage/env/dev-lang/rust
    # validate or create /etc/portage/env/dev-lang/rust per-package env setting
    # (should be installed by this package's ebuild)
    message_n "examining /etc/portage/env/dev-lang/rust"
    if [ -e /etc/portage/env/dev-lang/rust ] ; then
        echo -en " (${BGon}found${Boff})"
    else
        # not found - create
        echo -en " (${BRon}not found${Boff})"
        CONTENT="RUST_CROSS_TARGETS=(\n"
        CONTENT+=" \"ARM:arm-unknown-linux-gnueabihf:armv6j-unknown-linux-gnueabihf\"\n"
        CONTENT+=" \"ARM:armv7-unknown-linux-gnueabihf:armv7a-unknown-linux-gnueabihf\"\n"
        CONTENT+=" \"AArch64:aarch64-unknown-linux-gnu:aarch64-unknown-linux-gnu\"\n"
        CONTENT+=" )"
        echo -e "${CONTENT}" > /etc/portage/env/dev-lang/rust || die "failed to create /etc/portage/env/dev-lang/rust"
        echo -en "(${BGon}created${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE

    # (3) LLVM_TARGETS use-expand set-up in CHOST's make.conf
    # (for crossbuilder development workstations) include all of: AArch64 ARM AVR RISCV X86 - to match target CPUs
    # (for SBCs make.conf) include only one of: AArch64 ARM AVR RISCV X86 - to match SBC CPUs
    # (for both) include BFP and WebAssembly - mandatory for modern Rust and Linux kernel-level tracing/security tools
    # (for both) include SPIRV - ensures that tools like mesa, opencl, or vulkan-loader can compile correctly if they require LLVM-based translation
    # (for crossbuilders) include AMDGPU and NVPTX - support compiling for amd/ati-radeon and nvidia gpus
    # *exclude* Hexagon Lanai LoongArch MSP430 Mips PowerPC Sparc SystemZ VE XCore - not needed
    local crossbuild_workstation_llvm_targets="AArch64 ARM AVR RISCV X86 BFP WebAssembly SPIRV AMDGPU NVPTX"
    # call validate-llvm-targets() to check the CHOST's make.conf
    validate-llvm-targets "/etc/portage/make.conf" "${crossbuild_workstation_llvm_targets}" || \
        die "failed to validate-llvm-targets in CHOST make.conf"

# DEPRECATED (4) symlink for cross-${TARGET}/rust-std set up cross-rust in CHOSTs crossdev repo(s)
# DEPRECATED (5) unmask cross-${TARGET}/rust-std in CHOSTs package.accept_keywords

    # if we got here (didn't die above) close action as OK and return exit status 0
    cd $old_dir
    message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
    return 0
}

validate-llvm-targets() {
    # 20260108 - extracted this code from prepare-cross-rust() so I can also call
    #   it from configure-make-conf-for-crossbuilding() and from configure-make-conf-for-chroot()
    # Validate the LLVM_TARGETS= assignment in this (target_file) make.conf
    local target_file="$1"
    local proper_targets="$2"
    local target_name="${LLVM_TARGET:-unknown}" # Fallback for logging

    # (for crossbuilder development workstations) include all of: AArch64 ARM AVR RISCV X86 - to match target CPUs
    # (for SBCs make.conf) include only one of: AArch64 ARM AVR RISCV X86 - to match SBC CPUs
    # (for both) include BFP and WebAssembly - mandatory for modern Rust and Linux kernel-level tracing/security tools
    # (for both) include SPIRV - ensures that tools like mesa, opencl, or vulkan-loader can compile correctly if they require LLVM-based translation
    # (for crossbuilders) include AMDGPU and NVPTX - support compiling for amd/ati-radeon and nvidia gpus
    # *exclude* Hexagon Lanai LoongArch MSP430 Mips PowerPC Sparc SystemZ VE XCore - not needed
    message_n "examining LLVM_TARGETS in ${target_file}; looking for ${target_name}"
    if grep -qF "LLVM_TARGETS=" "${target_file}" ; then
        # make.conf contains an assigment for LLVM_TARGETS - check if this board's target is in it?
        # safely extract LLVM_TARGETS using a subshell
        CURRENT_LLVM_TARGETS=$(source "${target_file}" 2>/dev/null && echo "${LLVM_TARGETS}")
        # space-pad both sides to ensure perfect match and accomodate "end of list" case
        if [[ " ${CURRENT_LLVM_TARGETS} " == *" ${target_name} "* ]] ; then
            # make.conf contains an assigment for LLVM_TARGETS - and our target is already included
            echo -en " (${BGon}found${Boff})"
        else
            # make.conf contains an assigment for LLVM_TARGETS - but our target is not (yet) included (edit to add)
            echo -e -n " (${BRon}not found${Boff})"
            # edit with sed using substitution command s, delimiter /, double-quotes for the filename variable,
            #   double-quotes for the whole sed command (vs single quotes) so encapsulated variable will expand,
            #   and escaped quotes for the variable inside the sed command, so it will expand safely
            sed -i "s/^LLVM_TARGETS=.*/LLVM_TARGETS=\"${proper_targets}\"/" "${target_file}"
            #       ^                 ^             ^^                 ^^ ^
            #       |                 |             ||                 || |
            #  start-sed subst   delimiter   esc-quote          esc-quote end-sed
            # ^LLVM_TARGETS=.*  -- match all of any line beginning LLVM_TARGETS= followed by zero or more of any character (except newlines)
            # replace with LLVM_TARGETS="${proper_targets}"
            [ $? -eq 0 ] || die "failed to update LLVM_TARGETS in ${target_file}"
            echo -e -n "(${BGon}updated${Boff})"
            export RUST_LLVM_CHANGE_FLAG=$TRUE
        fi
    else
        # make.conf does not contain an assignment for LLVM_TARGETS -- append one
        echo -en " (${BRon}not found${Boff})"
        echo -e "\nLLVM_TARGETS=\"${proper_targets}\"" >> "${target_file}" || \
            die "failed to append LLVM_TARGETS to ${target_file}"
        echo -en "(${BGon}appended${Boff})"
        export RUST_LLVM_CHANGE_FLAG=$TRUE
    fi
    right_status $TRUE
}
# not sure validate-llvm-targets() is all really necessary --
    #   all targets may be unconditionally enabled in llvm-core/llvm(?) depending on profile
    # Gentoo forum administrator Hu noted on Fri Sep 16, 2022 --
    # ( news regarding adjustment of profiles' package.use.force ) --
        # MichalGorny <mgorny@gentoo.org> (2021-11-04):
        # Enable all LLVM targets unconditionally.  Unfortunately, disabling targets tend to break
        # reverse dependencies (e.g. Rust) and we are yet to find a clean way of resolving that.
        # Compared to the damage potential, the increase of build time is a minor problem.  Users who
        # really insist of building a smaller system can un-force the flags at their own responsibility.

# confirmed as of 20260108, profile is still forcing USE for most targets globally
# $ emerge -pv llvm-core/llvm
# ...
# [binary   R    ] llvm-core/llvm-21.1.8-1:21/21.1::gentoo  USE="binutils-plugin libffi verify-sig xml zstd -debug
# (-debuginfod) -doc -exegesis -libedit -test -z3"
# ABI_X86="(64) -32 (-x32)"
# LLVM_TARGETS="(AArch64) (AMDGPU) (ARM) (AVR) (BPF) (Hexagon) (Lanai) (LoongArch) (MSP430) (Mips) (NVPTX) (PowerPC)
# (RISCV) (SPIRV) (Sparc) (SystemZ) (VE) (WebAssembly) (X86) (XCore) -ARC -CSKY -DirectX -M68k -Xtensa" 0 KiB

# Other footnotes regarding LLVM_TARGETS --
    # as of 7/18/2025, this is the content of /var/db/repos/gentoo/profiles/base/package.use.force
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_AArch64 llvm_targets_AMDGPU               <=== NOTE AArch64 AMDGPU
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_ARM llvm_targets_AVR llvm_targets_BPF     <=== NOTE ARM AVR BPF
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_Hexagon llvm_targets_Lanai
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_MSP430 llvm_targets_Mips
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_NVPTX llvm_targets_PowerPC                <=== NOTE NVPTX
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_RISCV llvm_targets_Sparc                  <=== NOTE RISCV
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_SystemZ llvm_targets_WebAssembly          <=== NOTE WebAssembly
    #    >=llvm-core/clang-13.0.1_rc llvm_targets_X86 llvm_targets_XCore                    <=== NOTE X86
    #    >=llvm-core/clang-14 llvm_targets_VE
    #    >=llvm-core/clang-16 llvm_targets_LoongArch
    #    >=llvm-core/clang-20 llvm_targets_SPIRV                                            <=== NOTE SPIRV
    #
    # as of 7/18/2025, this is the content of /var/db/repos/gentoo/profiles/arch/amd64/package.use.force
    #    dev-lang/rust llvm_targets_X86
    #    dev-ml/llvm llvm_targets_X86
    #    llvm-core/clang llvm_targets_X86
    #    llvm-core/llvm llvm_targets_X86
    # as of 7/18/2025, this is the content of /var/db/repos/gentoo/profiles/arch/arm64/package.use.force
    #    dev-lang/rust llvm_targets_AArch64
    #    dev-ml/llvm llvm_targets_AArch64
    #    llvm-core/clang llvm_targets_AArch64
    #    llvm-core/llvm llvm_targets_AArch64
    #
    # as of 7/18/2025, this is the content of /var/db/repos/gentoo/profiles/arch/arm/package.use.force
    #    dev-lang/rust llvm_targets_ARM
    #    dev-ml/llvm llvm_targets_ARM
    #    llvm-core/clang llvm_targets_ARM
    #    llvm-core/llvm llvm_targets_ARM
