#!/bin/bash
#
# cb-dashboard   (c) joe.brendler  2025-2072
# mount a crossbuild image file on its associated TARGET
#
source /usr/sbin/script_header_joetoo
VERBOSE=$TRUE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

d_message_n "sourcing BUILD ..." 3
source /etc/crossbuild-tools/BUILD ; d_right_status $? 3
d_message_n "sourcing BPN ..." 3
source /etc/crossbuild-tools/BPN ; d_right_status $? 3
source /usr/sbin/script_header_joetoo_extended

#-----[ variables ]--------------------------------------------------------------------------
selector=""

user="joe"
webroot="/var/www/localhost/htdocs/"
stockpile_dir="/home/${user}/sbc-stockpile/"

PN=$(basename $0)

# specify cross-build targets to look for
declare -a TARGETS
# load TARGETS array with selected directory names (starting "cross") output by find command
# use -print0 to safely pass filenames potentially containing whitespace
# use readarray -d $'\0' /// NOT -d '' 
#/// also provide final null terminator with ; printf '\0'
#readarray -d $'\0' -t TARGETS < <(find /var/db/repos/crossdev/ -mindepth 1 -maxdepth 1 -type d -name 'cross*' -print0; printf '\0')
# apparently don't need the final \0 terminator - it creates a blank element
readarray -d $'\0' -t TARGETS < <(find /var/db/repos/crossdev/ -mindepth 1 -maxdepth 1 -type d -name 'cross*' -print0)

#-----[ functions ]--------------------------------------------------------------------------

d_message_n "sourcing cb-common-functions ..." 3
source /usr/sbin/cb-common-functions ; d_right_status $? 3

usage() {
    E_message "${BRon}usage: ${BGon}${PN}${Boff}"
    echo -e "${BMon} * ${Boff}(no arguments)"
    smaller_script_common_usage_message
    exit
}

show-dashboard() {
    local selector=""  # string used to target various function calls

    echo
    separator "${PN}-${BUILD}" "( crossdev TARGETs in /var/db/repos/crossdev/ )"
    for TARGET in ${TARGETS[@]}; do echo -e "    ${LBon}${TARGET}${Boff}"; done
    echo
    # crossbuild stuff first (selected by '/usr/')
    # for each active loopdevice, show backing file and mounts
    separator "${PN}-${BUILD}" "(active crossbuild loop devices)"
    show-loopdev-backfile-and-mounts "/usr/"
    [ $? -eq 0 ] && echo   ## echo only if something was presented in output (don't waste space if not)

    # now display anything else mounted on one of our TARGETs (e.g. proc, dev, sys for chroot...)
    separator "${PN}-${BUILD}" "(other mounts - e.g. for chroot)"
    for TARGET in ${TARGETS[@]}; do
        selector="${TARGET}"
        show-mounts "${selector}" | grep -v "loop"
    done

    # now show any other mounts on /dev/sd devices
    selector="/dev/sd"
    separator "${PN}-${BUILD}" "(${selector} - possible OUTPUTDEVICE)"
    show-mounts "${selector}"

    # now display anything mounted on /mnt/gentoo (possible outputdevice)
    selector="/mnt/gentoo"
    separator "${PN}-${BUILD}" "(${selector} - mounted root_fs)"
    show-mounts "${selector}"

    # display status of repositories in various /usr/${TARGET} directories
    separator "${PN}-${BUILD}" "(crossbuild repository status)"
    show-target-repositories-status

    echo
    # now do binhosts (selected by 'stockpile')
    separator "${PN}-${BUILD}" "(active binhost loop devices)"
    show-loopdev-backfile-and-mounts "stockpile"
    [ $? -eq 0 ] && echo   ## echo only if something was presented in output

    # now show links at webroot/packages/ and their targets
    separator "${PN}-${BUILD}" "(linked binhost web services)"
    show-binary-package-services

    echo
    # now show contents of stockpile
    separator "${PN}-${BUILD}" "(stockpile contents)"
    show-stockpile-contents
    echo

}

show-stockpile-contents() {
    local selector=""
    local category=""

    for selector in "env" "img" "qcow2" ; do
        d_message "selector: [${selector}]" 5
        case $selector in
            "env" ) category="environments" ;;
            "img" ) category="images" ;;
            *     ) category="other developed images" ;;
        esac
        message "${BMon}crossbuild ${category} (*.${selector})${Boff}"
        show-stockpile-filesizes "*.${selector}"
    done

}

show-stockpile-filesizes() {
    local APPARENT_SIZE_BYTES=""
    local apparent_gibs=""
    local ACTUAL_SIZE_BYTES=""
    local actual_gibs=""
    local filter="$1"    # filename(s) used to filger find command output

    local -a filenames   # array of filenames found by find command

    readarray -t filenames < <(find ${stockpile_dir} -maxdepth 1 -type f -name "${filter}" -printf '%f\n' | sort -h)

    for ((i=0; i<${#filenames[@]}; i++)) ; do
#        echo; echo ${filenames[$i]}; echo $(repeat '-' ${#filenames[$i]}) ;
        APPARENT_SIZE_BYTES=$(stat -c%s "${stockpile_dir%/}/${filenames[$i]}") ;
        apparent_gibs=$(echo "scale=1; (($APPARENT_SIZE_BYTES / 1000 / 1000 / 1000))" | bc) ;
        ACTUAL_SIZE_BYTES=$(du -B 1 "${stockpile_dir%/}/${filenames[$i]}" | awk '{print $1}') ;
        actual_gibs=$(echo "scale=1; (($ACTUAL_SIZE_BYTES / 1000 / 1000 / 1000))" | bc) ;
        echo -e "    ${BYon}${filenames[$i]}${Boff} ( apparent size: ${Mon}${apparent_gibs}GiB${Boff} ; actual size: ${Gon}${actual_gibs}GiB${Boff} )" ;
    done
}

show-mounts() {
    local src=""    # mountpoint source found in findmnt output
    local tgt=""    # mountpoint target found in findmnt output
    local fstype="" # filesystem type found in findmnt output
    local opts=""   # mount options found in findmnt output
    local ro_rw=""  # string to represent read-only/read-write option if present in opts

    local -a mounts_found  # array of lines of output from findmnt command

    # display anything mounted on /dev/sd devices (possible outputdevice)
    d_message "  in ${FUNCNAME[0]} with selector: ${selector}" 5
    # -S /dev/sd*: filters for devices originating from /dev/sd*.
    # -n: suppresses the header line.
    # -l: provides a list format.
    # -o SOURCE,TARGET,FSTYPE: specifies the exact output columns.
    # -r: provides raw output, disabling special formatting.
    readarray -t mounts_found < <(findmnt -lno SOURCE,TARGET,FSTYPE,OPTIONS | grep -E "^${selector}")
    d_message "mounts_found[@]: ${mounts_found[@]}" 5
    if [ ! ${#mounts_found[@]} -eq 0 ] ; then
        d_message "#: ${#mounts_found[@]}" 6
        for ((i=0; i<${#mounts_found[@]}; i++)) ; do
            echo ${mounts_found[$i]}
            eval $(echo ${mounts_found[$i]} | awk '{print "src="$1"; tgt="$2"; fstype="$3"; opts="$4}')
            d_message "src: $src   tgt: $tgt   fstype: $fstype   opts: $opts" 5
            # check mount options for ro/rw (read-only/read-write)
            if scan_for_mount_option "${mount_options}" "ro" ; then
                ro_rw="(${BGon}ro${Boff})"
            elif scan_for_mount_option "${mount_options}" "rw" ; then
                ro_rw="(${BRon}rw${Boff})"
            else
                ro_rw="(${BYon}no ro/rw${Boff})"
            fi
            echo -e "        ${BYon}${src}${Boff} is mounted ${ro_rw} at ${LBon}${tgt}${Boff} with fs_type ${BMon}${fstype}${Boff}"
        done
    fi
}

show-target-repositories-status() {
    # display the status of (gentoo and joetoo) repositories if anything is mounted at /usr/${TARGET}/
    local TARGET_DIR="" # path to target repository (element of TARGETS array)
    local TARGET=""     # one of the tuples (crossdev targets/repository directory names) in global array TARGETS
    local repo_list=""  # list of repositories
    local repo=""       # one repository selected
    local repo_path=""  # path to the one repo selected
    local repo_info=""  # info returned by file command

   # display status of repositories in various /usr/${TARGET} directories
#    for TARGET in $(echo $TARGETS | sed 's:\\|: :g'); do
    for TARGET_DIR in "${TARGETS[@]}" ; do
        # extract just <tuple> from /var/db/repos/crossdev/"cross-<tuple>"
        TARGET="$(basename ${TARGET_DIR} | sed 's|cross-||')"
        repo_list="gentoo joetoo"
        if [ -d /usr/${TARGET}/var/db/repos ] ; then
            # this target has content; list it and look for repos
            echo -e "    ${BMon}/usr/${TARGET}/var/db/repos${Boff}"
            for repo in ${repo_list} ; do
                if [ -d /usr/${TARGET}/var/db/repos/${repo} ] ; then
                    repo_path="/usr/${TARGET}/var/db/repos/${repo}"
                    if [ -e ${repo_path} ] ; then
                        repo_info=$(file "${repo_path}" | awk '{print $2}')
                        echo -e "        ${BYon}${repo_path}${Boff} is a ${BWon}${repo_info}${Boff}"
                    else
                        echo -e "        ${BYon}${repo_path} ${BRon}does not exist${Boff}"
                    fi  # full repo path
                else
                    dE_message "no directory found for [/usr/${TARGET}/var/db/repos/${repo}]" 5
                fi  # /var/db/repos/${repo}
            done # repo_list
        else
                dE_message "no directory found for [/usr/${TARGET}/var/db/repos]" 5
        fi  # /var/db/repos
    done # TARGETS
}

show-loopdev-backfile-and-mounts() {
    # output info about loop devices and backing files found using selector $1
    # return 0 if successful; 1 if no results found; 2 if error
    [ ! $# -eq 1 ] && E_message "argument null; ${FUNCNAME[0]} requires selector" && exit 1
    local selector="$1"     # selector for matching output of losetup
    local loop_dev=""       # loop device
    local backing_file=""   # backing file attached to loop device
    local loop_dev_part=""  # partition within loop device (backing file image)
    local mountpoint=""     # mountpoint at which loop device partition is mounted
    local fstype=""         # file system type
    local mount_options=""  # string containing all mount options for a line of findmnt output
    local ro_rw=""          # string to return within informative program output

    local -a loop_devices
    local -a mounts_found

    readarray -t loop_devices < <(losetup -lnO NAME,BACK-FILE | grep "${selector}" | sort -h)
    if [ ${#loop_devices[@]} -gt 0 ] ; then
        for ((i=0; i<${#loop_devices[@]}; i++)) ; do
            # identify the loop_dev name and its backing_file
            loop_dev="$(echo ${loop_devices[$i]} | cut -d' ' -f1)"
            backing_file="$(echo ${loop_devices[$i]} | cut -d' ' -f2)"
            if [ ! -z "${loop_dev}" ] ; then
                echo -e "    ${BMon}${loop_dev}${Boff} is backed by file: ${BWon}${backing_file}${Boff}"
                # identify this loop_dev's mounts
                readarray -t mounts_found < <(findmnt -lno SOURCE,TARGET,FSTYPE,OPTIONS | grep -E "^${loop_dev}")
                for ((j=0; j<${#mounts_found[@]}; j++)) ; do
                    loop_dev_part="$(echo ${mounts_found[$j]} | cut -d' ' -f1)"
                    mountpoint="$(echo ${mounts_found[$j]} | cut -d' ' -f2)"
                    fstype="$(echo ${mounts_found[$j]} | cut -d' ' -f3)"
                    mount_options="$(echo ${mounts_found[$j]} | cut -d' ' -f4)"
                    d_message "mount_options: [$mount_options]" 5
                    # check mount options for ro/rw (read-only/read-write)
                    if scan_for_mount_option "${mount_options}" "ro" ; then
                        ro_rw="(${BGon}ro${Boff})"
                    elif scan_for_mount_option "${mount_options}" "rw" ; then
                        ro_rw="(${BRon}rw${Boff})"
                    else
                        ro_rw="(${BYon}no ro/rw${Boff})"
                    fi
                    echo -e "        ${BYon}${loop_dev_part}${Boff} is mounted ${ro_rw} at ${LBon}${mountpoint}${Boff}"
                done # mounts found for loop_dev
            else
                # no loop device on this line of output (error)
                die "something wrong here - no loop device on this entry of non-zero array"
            fi
        done # loop_devices
    else
        # no loop devices found by losetupp command
        return 1
    fi  # no loop devices
}

scan_for_mount_option() {
    # return 0 if the options string $1 contains the queried option $2; 1 if not found, 2 if error
    if [ ! $# -eq 2 ] ; then
        E_message "Usage: ${FUNCNAME[0]} \"<full_options_string>\" \"<search_option>\""
        return 2
    fi

    local full_options_string="$1"                 # the string with all mount options returned by findmnt command (externally)
    local search_option="$2"                       # the mount option to check for in full options string
    local padded_options=",$full_options_string,"  # Pad the string with commas to reliably check for options at the start/end.

    if [[ "$padded_options" == *",$search_option,"* ]]; then
        return 0 # Success (option found)
    else
        return 1 # Failure (option not found)
    fi
}

show-binary-package-services() {
    # display links in webroot and their link_targets
    d_message "  in ${FUNCNAME[0]}" 5
    local website="${webroot%/}/packages"  # binary package repository website
    local link=""                          # link name found by find command
    local link_target=""                   # target of link extracted from output of file command

    echo; message "${BWon}links at binhost website: ${BMon}${website}${Boff}"
    for link in $(find ${website} -maxdepth 1 -mindepth 1 -type l -printf '%f\n'); do
        echo -e -n "    ${BYon}${link}"
        link_target=$(echo $(file ${website%/}/${link}) | awk '{print $NF}');
        echo -e "${BWon} --> ${LBon}${link_target}${Boff}"
    done
}

#-----[ main script ]----------------------------------------------------------------------
checkroot
clear
separator "$(hostname)" ""${PN}-${BUILD}""
[ $# -ne 0 ] && usage

old_dir="$(pwd)"
cd /usr/
d_message "now working in parent of crossbuild target directory: [${Mon}$(pwd)${Boff}]" 1
d_message "#: ${#TARGETS[@]}" 4
d_message "\${TARGETS[@]}:" 5
debug_do 'for TARGET in ${TARGETS[@]}; do echo "    $TARGET"; done' 5

show-dashboard || die "failed to show-dashboard"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0
