#!/bin/bash
#
# cb-dashboard   (c) joe.brendler  2025-2072
# mount a crossbuild image file on its associated TARGET
#
source /usr/sbin/script_header_joetoo
VERBOSE=$TRUE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

d_message_n "sourcing BUILD ..." 3
source /etc/crossbuild-tools/BUILD ; d_right_status $? 3
d_message_n "sourcing BPN ..." 3
source /etc/crossbuild-tools/BPN ; d_right_status $? 3
source /usr/sbin/script_header_joetoo_extended

#-----[ variables ]--------------------------------------------------------------------------
selector=""

webroot="/var/www/localhost/htdocs/"

PN=$(basename $0)

# specify cross-build targets to look for
#TARGETS="aarch64-unknown-linux-gnu\|armv7a-unknown-linux-gnueabihf\|armv6j-unknown-linux-gnueabihf"
#TARGETS="aarch64-unknown-linux-gnu armv7a-unknown-linux-gnueabihf armv6j-unknown-linux-gnueabihf"
# detect crossdev build targets actually installed (in repo)
#TARGETS=( $(find /var/db/repos/crossdev/ -mindepth 1 -maxdepth 1 -type d -name 'cross*' -printf '%f\n' | sed 's|^cross-||') )
readarray -d'' TARGETS < <(find /var/db/repos/crossdev/ -mindepth 1 -maxdepth 1 -type d -name 'cross*' -print0)

#-----[ functions ]--------------------------------------------------------------------------

d_message_n "sourcing cb-common-functions ..." 3
source /usr/sbin/cb-common-functions ; d_right_status $? 3

usage() {
    E_message "${BRon}usage: ${BGon}${PN}${Boff}"
    echo -e "${BMon} * ${Boff}(no arguments)"
    smaller_script_common_usage_message
    exit
}

show-dashboard() {
    echo
    separator ${PN} "( crossdev TARGETs in /var/db/repos/crossdev/ )"
    for TARGET in ${TARGETS[@]}; do echo -e "    ${LBon}${TARGET}${Boff}"; done
    echo
    # crossbuild stuff first (selected by '/usr/')
    # for each active loopdevice, show backing file and mounts
    separator ${PN} "(active crossbuild loop devices)"
    show-loopdev-backfile-and-mounts "/usr/"

    # now display anything else mounted on one of our TARGETs (e.g. proc, dev, sys for chroot...)
    separator ${PN} "(other mounts - e.g. for chroot)"
    for TARGET in ${TARGETS[@]}; do
        selector="${TARGET}"
        show-mounts "${TARGET}" | grep -v "loop"
    done

    # now show any other mounts on /dev/sd devices
    selector="/dev/sd"
    separator ${PN} "(${selector} - possible OUTPUTDEVICE)"
    show-mounts "${selector}"

    # now display anything mounted on /mnt/gentoo (possible outputdevice)
    selector="/mnt/gentoo"
    separator ${PN} "(${selector} - mounted root_fs)"
    show-mounts "${selector}"

    # display status of repositories in various /usr/${TARGET} directories
    separator ${PN} "(crossbuild repository status)"
    show-target-repositories-status

    echo
    # now do binhosts (selected by 'stockpile')
    separator ${PN} "(active binhost loop devices)"
    show-loopdev-backfile-and-mounts "stockpile"

    echo
    # now show links at webroot/packages/ and their targets
    separator ${PN} "(linked binhost web services)"
    show-binary-package-services

    echo
    # now show contents of stockpile
    separator ${PN} "(stockpile contents)"
    message "crossbuild environments (*.env)"
    find /home/joe/sbc-stockpile/ -maxdepth 1 -type f -name '*.env' -printf '%f\n' | sort -h | sed 's|^|    |'
    echo
    message "deployed images (*.img)"
    find /home/joe/sbc-stockpile/ -maxdepth 1 -type f -name '*.img' -printf '%f\n' | sort -h | sed 's|^|    |'
    echo
    message "other developed images (*.qcow2)"
    find /home/joe/sbc-stockpile/ -maxdepth 1 -type f -name '*.qcow2' -printf '%f\n' | sort -h | sed 's|^|    |'

}

show-mounts() {
    # display anything mounted on /dev/sd devices (possible outputdevice)
    d_message "  in ${FUNCNAME[0]} with selector: ${selector}" 5
    # -S /dev/sd*: filters for devices originating from /dev/sd*.
    # -n: suppresses the header line.
    # -l: provides a list format.
    # -o SOURCE,TARGET,FSTYPE: specifies the exact output columns.
    # -r: provides raw output, disabling special formatting.
    readarray -t mounts_found < <(findmnt -lno SOURCE,TARGET,FSTYPE | grep -E "^${selector}")
    d_message "mounts_found[@]: ${mounts_found[@]}" 5
    if [ ! ${#mounts_found[@]} -eq 0 ] ; then
        d_message "#: ${#mounts_found[@]}" 6
        for ((i=0; i<${#mounts_found[@]}; i++)) ; do
            echo ${mounts_found[$i]}
            eval $(echo ${mounts_found[$i]} | awk '{print "src="$1"; tgt="$2"; fstype="$3}')
            d_message "src: $src   tgt: $tgt   fstype: $fstype" 5
            echo -e "        ${BYon}${src}${Boff} is mounted at ${LBon}${tgt}${Boff} with fs_type ${BMon}${fstype}${Boff}"
        done
    fi
}

show-target-repositories-status() {
   # display status of repositories in various /usr/${TARGET} directories
#    for TARGET in $(echo $TARGETS | sed 's:\\|: :g'); do
    for TARGET in ${TARGETS} ; do
        repo_list="gentoo joetoo"
        for repo in ${repo_list} ; do
            if [ -d /usr/${TARGET}/var/db/repos ] ; then
                repo_path="/usr/${TARGET}/var/db/repos/${repo}"
                if [ -e ${repo_path} ] ; then
                    repo_info=$(file ${repo_path} | cut -d':' -f2)
                    echo -e "    ${LBon}${repo_path}${Boff} is a ${BWon}${repo_info}${Boff}"
                else
                    echo -e "    ${LBon}${repo_path} ${BRon}does not exist${Boff}"
                fi  # full repo path
            fi  # /var/db/repos
        done # repo_list
    done # TARGETS
}

show-loopdev-backfile-and-mounts() {
    [ ! $# -eq 1 ] && E_message "argument null; ${FUNCNAME[0]} requires selector" && exit 1
    selector="$1"
    readarray -t loop_devices < <(losetup -lnO NAME,BACK-FILE | grep "${selector}" | sort -h)
    for ((i=0; i<${#loop_devices[@]}; i++)) ; do
        # identify the loop_dev name and its backing_file
        loop_dev="$(echo ${loop_devices[$i]} | cut -d' ' -f1)"
        backing_file="$(echo ${loop_devices[$i]} | cut -d' ' -f2)"
        if [ ! -z "${loop_dev}" ] ; then
            echo -e "    ${BMon}${loop_dev}${Boff} is backed by file: ${BWon}${backing_file}${Boff}"
            # identify this loop_dev's mounts
            readarray -t mounts_found < <(findmnt -lno SOURCE,TARGET,FSTYPE | grep -E "^${loop_dev}")
            for ((j=0; j<${#mounts_found[@]}; j++)) ; do
                loop_dev_part="$(echo ${mounts_found[$j]} | cut -d' ' -f1)"
                mountpoint="$(echo ${mounts_found[$j]} | cut -d' ' -f2)"
                echo -e "        ${BYon}${loop_dev_part}${Boff} is mounted at ${LBon}${mountpoint}${Boff}"
            done # mounts found for loop_dev
        fi
    done # loop_devices
}

show-binary-package-services() {
    # display links in webroot and their link_targets
    d_message "  in ${FUNCNAME[0]}" 5
    website="${webroot%/}/packages"
    echo; message "${BWon}binhost website: ${BMon}${website}${Boff}"
    for link in $(find ${website} -maxdepth 1 -mindepth 1 -type l -printf '%f\n'); do
        message_n ${BYon}${link}
        link_target=$(echo $(file ${website%/}/${link}) | awk '{print $NF}');
        echo -e "${BWon} --> ${LBon}${link_target}${Boff}"
    done
}

#-----[ main script ]----------------------------------------------------------------------
checkroot
clear
separator "$(hostname)" "${PN}"
[ $# -ne 0 ] && usage

old_dir="$(pwd)"
cd /usr/
d_message "now working in parent of crossbuild target directory: [${Mon}$(pwd)${Boff}]" 1
d_message "#: ${#TARGETS[@]}" 4
d_message "\${TARGETS[@]}:" 5
debug_do 'for TARGET in ${TARGETS[@]}; do echo "    $TARGET"; done' 5

show-dashboard || die "failed to show-dashboard"

echo
cd $old_dir
d_message "now working in previous directory: [${Mon}$(pwd)${Boff}]" 1
exit 0
