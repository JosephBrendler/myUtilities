#!/bin/bash
#
# cb-mount-binhost   (c) joe.brendler  2025-2072
# mount a stockpiled crossbuild environment image file (*.env) for use as a binary package server
#
# update 20251014 - syntax cb-mount-binhost <BACKING_FILE>
# rather than old syntax cb-mount-binhost <BOARD> <MOUNTPOINT>
#
source /usr/sbin/script_header_joetoo
message_n "sourcing BUILD ..."
source /etc/crossbuild-tools/BUILD ; right_status $?
message_n "sourcing BPN ..."
source /etc/crossbuild-tools/BPN ; right_status $?
source /usr/sbin/script_header_joetoo_extended

VERBOSE=$TRUE
# set default verbosity only if it is not already set
[ -z $verbosity ] && verbosity=3

PN=$(basename $0)

user="joe"
stockpile_dir="/home/${user}/sbc-stockpile"
binhost_mountpoint_dir="/mnt"

message_n "sourcing cb-common-functions ..."
source /usr/sbin/cb-common-functions ; right_status $?
TARGET=""
MOUNTPOINT=""

usage() {
    echo
    E_message "${BRon}usage: ${BGon}${PN} <BACKING_FILE>${Boff}"
    echo
    message "  ${BYon}Exactly one <BACKING_FILE> must be specified"
    echo
    message "  ${LBon}<BACKING_FILE> must be a stockpiled SBC crossbuild image or environment file.${Boff}"
    message "  ${LBon}These are currently available --${Boff}"
    # set shell globbing options to count files in the mountpoint directory
    # nullglob ensures that a pattern matching no files expands to nothing
    # (rather than the pattern itself), and dotglob includes dotfiles (hidden files)
    # The files array will be empty if the directory is empty
    shopt -s nullglob dotglob
    images=("${stockpile_dir%/}"/*.env "${stockpile_dir%/}"/*.img)
    [ ${#images[@]} -eq 0 ] && die "There are no stockpiled crossbuild .env or .img files available"
    for image in ${images[@]}; do echo "         $(basename ${image})" ; done
    shopt -u nullglob dotglob # Unset the options after use
    echo
    message "  ${BMon}<BACKING_FILE> must be basename only, do not include path${Boff}"
    echo
    message "  ${LBon}<MOUNTPOINT> will be chosen analytically${Boff}"
    echo "         e.g. /mnt/sweetpotato_binhost"
    echo
    message "${BMon}find additionl information at /etc/crossbuild-tools/README"
    echo
    exit
}

validate_stockpile_image() {
    # return 0 if properly named image file exists in the stockpile directory
    [ ! -f ${stockpile_dir%/}/${BACKING_FILE} ] && die "stockpile image file [${stockpile_dir%/}/${BACKING_FILE}] does not exist"
    return 0
}

validate_mountpoint() {
    d_message "in ${FUNCNAME[0]}" 5
    # return 0 if valid (directory exists and is empty)
    [ ! -d ${MOUNTPOINT} ] && die "mountpoint [${MOUNTPOINT}] does not exist"
    # set shell globbing options to count files in the mountpoint directory
    # nullglob ensures that a pattern matching no files expands to nothing
    # (rather than the pattern itself), and dotglob includes dotfiles (hidden files)
    # The files array will be empty if the directory is empty
    shopt -s nullglob dotglob
    files=("${MOUNTPOINT%/}"/*)
    [ ${#files[@]} -ne 0 ] && die "mountpoint directory [${MOUNTPOINT}] is not empty."
    shopt -u nullglob dotglob # Unset the options after use
    return 0
}

mount-board-image-as-read-only-binhost() {
    d_message "in ${FUNCNAME[0]}" 5
    # inspect target (mount point) - is anything mounted? (un-mount)
    d_message "MOUNTPOINT ......: ${MOUNTPOINT}" 1
    d_echo 1
    if [ ! -z "$(findmnt -n -M ${MOUNTPOINT})" ] ; then
#        E_message "${BYon}the following devices are already mounted on ${MOUNTPOINT} --${Boff}"
#        mount | grep "on ${MOUNTPOINT}" | sed 's|^|    |'
        E_message "${BYon}the following device is already mounted on ${MOUNTPOINT} --${Boff}"
        findmnt -n -M ${MOUNTPOINT} | sed 's|^|    |'
        exit 1
    else
        message "nothing is mounted on ${MOUNTPOINT} ; continuing"
    fi
    # inspect for loop devices attached to BOARD stockpile image file
    message "looking for loop device attached to ${stockpile_dir%/}/${BOARD}.env ..."
    loop_dev=$(losetup -a | grep "${stockpile_dir%/}/${BACKING_FILE}" | cut -d':' -f1)
    if [ ! -z "${loop_dev}" ] ; then
        E_message "${BYon}${loop_dev} is already attached to ${stockpile_dir%/}/${BACKING_FILE}"
        exit 1
    else
        message "no loop device is yet attached to ${stockpile_dir%/}/${BACKING_FILE}; continuing"
    fi
    # attach the binhost backing file with kernel-level read-only protection
    message_n "attaching loop device (read-only)"
#    img_loop_dev=$(losetup --find --show --partscan ${stockpile_dir%/}/${BACKING_FILE}) && \
#        ( echo -n " (${img_loop_dev})" && right_status $? ) || ( right_status $? && exit 1 )
    img_loop_dev=$(losetup --find --show --partscan --read-only ${stockpile_dir%/}/${BACKING_FILE}) && \
        ( echo -n " (${img_loop_dev})" && right_status $? ) || ( right_status $? && exit 1 )
    # Get partition device names
    message_n "getting device name for partition 1 ..."
    img_partition1_dev="${img_loop_dev}p1" && result=$? && \
    echo -n " ( ${img_partition1_dev} )" && \
    right_status ${result} || ( right_status $? && exit 1 )
    message_n "getting device name for partition 2 ..."
    img_partition2_dev="${img_loop_dev}p2" && result=$? && \
    echo -n " ( ${img_partition2_dev} )" && \
    right_status ${result} || ( right_status $? && exit 1 )

    # Run a non-destructive fsck (-n opens fs RO and assumes 'no' to all repairs - ok for RO images)
    message_n "checking filesystem integrity (RO check)..."
    e2fsck -n ${img_partition2_dev} >/dev/null 2>&1
    result=$?
    case $result in
        0   ) echo -e -n " (${BGon}clean${Boff})"; mount_opts="ro" ;;
        1|2 ) echo -e -n " (${BYon}recoverable dirty journal${Boff})"; mount_opts="ro,noload" ;;
        *   ) die "${BRon}e2fsck detected corruption on ${img_partition2_dev}!${Boff} Fix before continuing"
    esac
    right_status $TRUE

    # now mount the partitions with mount-layer (filesystem) read-only protection
    message_n "mounting rootfs (${img_partition2_dev}) on ${MOUNTPOINT}/ (read-only) ..."
#    mount ${img_partition2_dev} ${MOUNTPOINT}/ && right_status $? || ( right_status $? && exit 1 )
    mount -o ${mount_opts} ${img_partition2_dev} ${MOUNTPOINT}/ || die "failed to mount -o ro ${img_partition2_dev} ${MOUNTPOINT}/"
    right_status $TRUE
    message_n "mounting bootfs (${img_partition1_dev}) on ${MOUNTPOINT}/boot/ (read-only) ..."
#    mount ${img_partition1_dev} ${MOUNTPOINT}/boot/ && right_status $? || ( right_status $? && exit 1 )
    mount -o ro ${img_partition1_dev} ${MOUNTPOINT}/boot/ || die "failed to mount -o ro ${img_partition1_dev} ${MOUNTPOINT}/boot/"
    right_status $TRUE

    return 0
}

sanity_check() {
    d_message "in ${FUNCNAME[0]}" 5
    # placeholder for future sanity checks
    return 0
}

#-----[ main script ]---------------------------------------------
checkroot
[ $# -ne 1 ] && usage
BACKING_FILE=$1
separator "${PN}" "(${BACKING_FILE})"
# get BOARD from BACKING_FILE filename
# (remove the extension) (then remove the text from the first underscore onwards)
BOARD="${BACKING_FILE%.*}";  BOARD="${BOARD%%_*}"
d_message "BACKING_FILE: [$BACKING_FILE]; BOARD: [$BOARD]" 4
validate_target ${BOARD} || die "Failed to validate_target [${BOARD}]"
validate_stockpile_image ${BACKING_FILE} || die "Failed to validate_stockpile_image ${BACKING_FILE}"

# id the appropriate binhost name for this board and use that to id MOUNTPOINT
bh=""
id_binhost_and_link_for_board ${BOARD} || die "failed to id_binhost_and_link_for_board ${BOARD}"
MOUNTPOINT="${binhost_mountpoint_dir%/}/${bh}_binhost"
# not make sure it exists
validate_mountpoint ${MOUNTPOINT} || die "Failed to validate_mountpoint [${MOUNTPOINT}]"
sanity_check || die "failed sanity_check"

old_dir="$(pwd)"
cd $(dirname ${MOUNTPOINT}) || die "Failed to change director to parent of mountpoint [${MOUNTPOINT}]"
message "now working in parent of crossbuild binhost MOUNTPOINT directory: [${Mon}$(pwd)${Boff}]"

#mount-board-image-as-crossbuild-binhost || die "failed to mount-board-image-as-crossbuild-binhost"
mount-board-image-as-read-only-binhost || die "failed to mount-board-image-as-read-only-binhost"

echo
cd $old_dir
message "now working in previous directory: [${Mon}$(pwd)${Boff}]"
exit 0
